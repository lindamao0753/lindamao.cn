<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>Git | lindamao</title>
<link rel="shortcut icon" href="/favicon.ico?v=1676374319079">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Git" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>lindamao</span>
            </a>  
          
        </div>
        
          <p class="subtitle">lindamao</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">lindamao</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>此博客用于记录平时学习相关 有问题欢迎指正</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">15</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E6%8A%80%E5%B7%A71%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE">技巧1:优化配置</a>
<ul>
<li><a href="#%E6%9F%A5%E6%89%BE%E9%A1%BA%E5%BA%8F">查找顺序</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE">修改配置</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%AE%BE%E7%BD%AE">显示当前设置</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE">一些有用的配置</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E5%B7%A72%E5%88%AB%E5%90%8Dalias">技巧2:别名(alias)</a>
<ul>
<li><a href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%88%AB%E5%90%8D">一些有用的别名</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E5%B7%A7-3%E6%9F%A5%E6%89%BE-commits-%E5%92%8C%E6%9B%B4%E6%94%B9">技巧 3：查找 Commits 和更改</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87commits%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE">通过commits信息查找</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E6%9B%B4%E6%94%B9%E6%9F%A5%E6%89%BE">通过更改查找</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E6%97%A5%E6%9C%9F%E6%9F%A5%E6%89%BE">通过日期查找</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E5%B7%A74%E6%B7%BB%E5%8A%A0hunk">技巧4:添加hunk</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7-5-%E5%82%A8%E8%97%8Fstash%E6%9B%B4%E6%94%B9%E8%80%8C%E4%B8%8D%E6%8F%90%E4%BA%A4">技巧 5： 储藏（stash）更改而不提交</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a></li>
<li><a href="#%E7%BD%97%E5%88%97">罗列</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88">浏览</a></li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>
<li><a href="#%E6%B8%85%E7%90%86">清理</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E5%B7%A7-6%E7%A9%BA%E8%BF%90%E8%A1%8Cdry-run">技巧 6：空运行（Dry Run）</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7-7%E5%AE%89%E5%85%A8%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81">技巧 7：安全强制推送</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7-8%E4%BF%AE%E6%94%B9-commit-%E4%BF%A1%E6%81%AF">技巧 8：修改 commit 信息</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7-9%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2">技巧 9：修改历史</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7-10%E5%AD%98%E6%A1%A3%E8%B7%9F%E8%B8%AA%E6%96%87%E4%BB%B6">技巧 10：存档跟踪文件</a></li>
<li><a href="#%E9%A2%9D%E5%A4%96%E6%8F%90%E9%86%92%E5%8D%95%E7%A0%B4%E6%8A%98%E5%8F%B7">额外提醒：单破折号</a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://lindamao.cn/post/git/"> Git </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-07-12 15:32:32">2022-07-12</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >8<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >1811<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h1 id="技巧1优化配置">技巧1:优化配置</h1>
<p>Git 在全局、用户和本地级别上都是高度可配置的。</p>
<p><a href="https://git-scm.com/docs/git-config">git配置文档</a></p>
<h2 id="查找顺序">查找顺序</h2>
<p>每个设置都可以被覆盖：</p>
<pre><code>本地级别:
项目文件夹/.git/config
用户级别:
用户目录/.config/git
用户目录/.gitconfig
全局级别：
git目录/etc/gitconfig
</code></pre>
<h2 id="修改配置">修改配置</h2>
<pre><code class="language-bash"># 全局设置
git config --global &lt;keypath&gt; &lt;value&gt;
# 本地设置
git config &lt;keypath&gt; &lt;value&gt;
</code></pre>
<h2 id="显示当前设置">显示当前设置</h2>
<pre><code class="language-bash"># 显示当前设置及其来源
git config --list --show-origin
</code></pre>
<h2 id="一些有用的配置">一些有用的配置</h2>
<pre><code class="language-bash"># 设定身份
git config --global user.name&quot;&lt;your name&gt;&quot;
git config --global user.email &lt;your email&gt;
</code></pre>
<h1 id="技巧2别名alias">技巧2:别名(alias)</h1>
<p><a href="%5Bhttps://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D%5D(https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D)">Git 别名</a></p>
<p>创建别名来保存常用的git命令：</p>
<pre><code class="language-bash"># 创建别名
git config --global alias.&lt;alias-name&gt; &quot;&lt;git command&gt;&quot;
# 使用别名
git &lt;alias-name&gt; &lt;more optional arguments&gt;
</code></pre>
<h2 id="一些有用的别名">一些有用的别名</h2>
<pre><code class="language-bash"># 撤销上次提交
git config --global alias.undo &quot;reset --soft HEAD^&quot;
# 将暂存区更新修订到上次提交 (不改变提交信息)
git config --global alias.amend &quot;commit --amend --no-edit&quot;
# 压缩的状态输出
git config --global alias.st &quot;status -sb&quot;
# 用 GRAPH 为日志着色
git config --global alias.lg &quot;log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'&quot;
# 删除所有已合并的分支
git config --global alias.rmb &quot;!git branch --merged | grep -v '*' | xargs -n 1 git branch -d&quot;
# 贡献排行
git config --global alias.rank &quot;shortlog -n -s --no-merges&quot;
</code></pre>
<h1 id="技巧-3查找-commits-和更改">技巧 3：查找 Commits 和更改</h1>
<h2 id="通过commits信息查找">通过commits信息查找</h2>
<pre><code class="language-bash"># 通过 commit 信息查找 (所有分支)
git log --all --grep='&lt;search term&gt;'
# 通过 commit 信息查找 (包含 reflog)
git log-g --grep='&lt;search term&gt;'
</code></pre>
<h2 id="通过更改查找">通过更改查找</h2>
<pre><code class="language-bash"># 通过更新的内容查找
git log -S '&lt;search term&gt;'
</code></pre>
<h2 id="通过日期查找">通过日期查找</h2>
<pre><code class="language-bash"># 通过日期范围查找
git log --after='DEC 152019' --until='JAN 102020'
</code></pre>
<h1 id="技巧4添加hunk">技巧4:添加hunk</h1>
<p>git add <filepath> 不仅能添加文件的所有变更， --path / -p 参数还可以交互式暂存区块。</p>
<pre><code class="language-bash"># 补丁命令
y = 暂存区块
n = 不暂存这个区块
q = 退出
a = 暂存当前文件的此区块以及所有剩余区块
d = 不暂存当前文件的此区块以及所有剩余区块
/ = 查找区块 (正则表达式)
s = 划分成更小的区块
e = 手动编辑区块
? = 打印帮助说明
g = 选择要前往的区块
j = 将区块设为未定，查看下一个未定区块
J = 将区块设为未定，查看下一个区块
k = 将区块设为未定，查看上一个未定区块
J = 将区块设为未定，查看下一个区块
</code></pre>
<h1 id="技巧-5-储藏stash更改而不提交">技巧 5： 储藏（stash）更改而不提交</h1>
<p>stash 将当前的更改临时搁置起来。在它的帮助下，可以返回当前状态的索引，并能在稍后应用已储藏的更改。</p>
<p>默认情况下，仅储藏当前跟踪文件中的更改，新文件将被忽略。</p>
<p>我们可以独立地创建和应用多个 stash。</p>
<p><a href="%5Bhttps://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86%5D(https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86)">Git 工具 - 储藏与清理</a></p>
<h2 id="创建">创建</h2>
<pre><code class="language-bash"># 创建新的 STASH
git stash
# 创建新的 STASH (包含未追踪的更改)
git stash -u/--include-untracked
# 创建新的 STASH 并命名
git stash save&quot;&lt;stash name&gt;&quot;
# 交互式储藏
git stash -p
</code></pre>
<h2 id="罗列">罗列</h2>
<pre><code class="language-bash"># 列出所有的 STASH (为其他命令提供 &quot;n&quot;)
git stash list
</code></pre>
<h2 id="浏览">浏览</h2>
<pre><code class="language-bash"># 浏览 STASH 内容
git stash show
# 浏览 STASH 差异
git stash show -p
</code></pre>
<h2 id="应用">应用</h2>
<pre><code class="language-bash"># 应用上一个 STASH (删除 stash)
git stash pop
# 应用上一个 STASH (保留 stash)
git stash apply
# 应用特定的 STASH (n = stash 列表序号)
git stash pop/apply stash@{n}
# 从 STASH 创建新的分支 (n = stash 列表序号)
git stash branch &lt;newbranch name&gt; stash@{n}
# 从 STASH 应用单个文件 (n = stash 列表序号)
git checkout stash@{n} -- &lt;filepath&gt;
</code></pre>
<h2 id="清理">清理</h2>
<pre><code class="language-bash"># 删除特定的 STASH (n = stash 列表序号)
git stash drop stash@{n}
# 删除所有的 STASH
git stash clear
</code></pre>
<h1 id="技巧-6空运行dry-run">技巧 6：空运行（Dry Run）</h1>
<p>许多 git 操作可能具有破坏性，例如， git clean -f 将删除所有未跟踪的文件，而且无法恢复。</p>
<p>要避免出现这种灾难性的结果，许多命令都支持 <em>dry-run</em> ，可以在实际产生结果前对其进行检查。不过遗憾的是，使用的选项不完全一致：</p>
<pre><code class="language-bash">git clean -n/--dry-run
git add -n/--dry-run
git rm -n/--dry-run
# GIT MERGE 模拟 DRY-RUN
git merge --no-commit --no-ff &lt;branch&gt;
git diff --cached
git merge --abort
</code></pre>
<h1 id="技巧-7安全强制推送">技巧 7：安全强制推送</h1>
<p>在处理旧的 commit、创建新的 head 等情况时时很容易弄乱分支。 git push --force 可以覆盖远程变更，但不应该这样做！</p>
<p>git push --force 是一种具有破坏性且危险的操作，因为它无条件生效，并且会破坏其他提交者已经推送的所有 commit。这对于其他人的代码仓库来说不一定是致命的，但是改变历史记录并影响其他人并不是一个好主意。</p>
<p>更好的选择是使用 git push --force-with-lease 。</p>
<p>git 不会无条件地覆盖上游的远程仓库，而是检查是否有本地不可用的远程更改。如果有，它会失败并显示一条“stale info”消息，并告诉我们需要先运行 git fetch 。</p>
<p><a href="https://git-scm.com/docs/git-push#Documentation/git-push.txt---force-with-leaseltrefnamegt">git push</a></p>
<h1 id="技巧-8修改-commit-信息">技巧 8：修改 commit 信息</h1>
<p>Commit 是不可变的，且不能更改。不过可以用一条新的 commit 信息修订现有的 commit，这会覆盖原始 commit，因此请勿在已推送的 commit 中使用它。</p>
<pre><code class="language-bash">git commit --amend -m &quot;&lt;new commit message&gt;&quot;
</code></pre>
<h1 id="技巧-9修改历史">技巧 9：修改历史</h1>
<p>修改代码仓库的历史不仅限于修改上次提交信息，使用 git rebase 可以修改多个提交：</p>
<pre><code class="language-bash"># 提交的范围
git rebase -i/--interactive HEAD~&lt;number of commits&gt;
# 该 hash 之后的所有提交
git rebase -i/--interactive &lt;commit hash&gt;
</code></pre>
<p>在配置的编辑器中倒序列出所有的 commit，像这样：</p>
<pre><code class="language-bash">#&lt;command&gt;&lt;commit hash&gt;&lt;commit message&gt;
pick5df8fbc revamped logic
pick ca5154e README typos fixed
pick a104aff added awesome new feature
</code></pre>
<p>通过更改编辑器中的实际内容，可以为 git 提供一个方案，来说明如何进行 rebase：</p>
<pre><code class="language-bash"># p, pick = 使用提交而不更改
# r, reword = 修改提交信息
# e, edit = 编辑提交
# s, squash = 汇合提交
# f, fixup = 类似 &quot;squash&quot;，但是会丢弃提交信息
# x, exec = 运行命令 (其余行)
# d, drop = 移除提交
</code></pre>
<p>保存编辑器后，git 将运行该方案以重写历史记录。</p>
<p>e, edit 会暂停 rebase，就可以编辑代码仓库的当前状态。完成编辑后，运行 git rebase --continue 。</p>
<p>如果过程中出现问题（例如合并冲突），我们需要重新开始，可以使用 git rebase --abort 。</p>
<p><a href="https://git-scm.com/docs/git-rebase">git-rebase</a></p>
<h1 id="技巧-10存档跟踪文件">技巧 10：存档跟踪文件</h1>
<p>可以使用不同格式（ zip 或 tar ）来压缩特定引用的跟踪文件：</p>
<pre><code class="language-bash">git archive --format&lt;format&gt; --output&lt;filename&gt; &lt;ref&gt;
</code></pre>
<p><ref> 可以是一个分支、commit hash 或者一个标签。</p>
<p><a href="https://git-scm.com/docs/git-archive">git-archive</a></p>
<h1 id="额外提醒单破折号">额外提醒：单破折号</h1>
<p>有一个快捷方式可以表示刚用过的分支：一个单破折号 -</p>
<pre><code class="language-bash">git checkout my-branch
# 当前分支：my-branch
&lt;dosome git operations, e.g. adding/commiting&gt;
git checkout develop
# 当前分支：develop
git merge -
# 将 my-branch 合并到 develop
</code></pre>
<p>单破折号等同于 @{-1} 。</p>
<p><a href="https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-ltbranchgt">git-checkout</a></p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      lindamao
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://lindamao.cn/post/git/" title="Git">https://lindamao.cn/post/git/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="数据库连接超时问题解决" href="https://lindamao.cn/post/shu-ju-ku-lian-jie-chao-shi-wen-ti-jie-jue/">数据库连接超时问题解决</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="数据库连接超时问题解决" href="https://lindamao.cn/post/shu-ju-ku-lian-jie-chao-shi-wen-ti-jie-jue/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Jrebel配置远程热部署" href="https://lindamao.cn/post/jrebel-pei-zhi-yuan-cheng-re-bu-shu/">Jrebel配置远程热部署</a>
        <a class="nav-mobile-next" title="Jrebel配置远程热部署" href="https://lindamao.cn/post/jrebel-pei-zhi-yuan-cheng-re-bu-shu/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/winsdows11-tiao-guo-lian-wang/"" data-c="
          &lt;p&gt;现在新买回来的电脑原厂几乎都是win11系统 如果联网就等于激活了 如果激活后在验机的时候出现问题将不好进行退换 这里提供winsdow11跳过联网的方法&lt;br&gt;
第1步：选国家（地区）&lt;br&gt;
第2步：选输入法，点是&lt;br&gt;
第3步：选第二种输入法，可以“跳过”&lt;br&gt;
第4步：联网界面：按下键盘的Shift+F10或Fn+Shift+F10&lt;br&gt;
（能插网线的电脑先不插网线，过程可能会自动重启电脑）&lt;br&gt;
会弹出管理员框，用键盘输入：taskmgr  再按回车键（Enter）&lt;br&gt;
此时会出现任务管理器 点击详细信息&lt;br&gt;
找到网络连接流，鼠标右键点击——结束任务，即可跳过联网&lt;br&gt;
到这一步 已经跳过联网了 后面的步骤根据自己的电脑的需求进行修改 验完机可以再联网&lt;/p&gt;
">Winsdows11跳过联网</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/shu-ju-ku-lian-jie-chao-shi-wen-ti-jie-jue/"" data-c="
          &lt;p&gt;今天上班在产线上遇到了这么一个bug&lt;br&gt;
com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure&lt;br&gt;
数据库连接超时是指当服务连接到数据库但不对其做任何操作时等待到一定时间之后，这个链接就会与数据库断开，当再次对数据库进行操作时会报数据库连接超时或者连接关闭异常。mysql的连接默认最长等待时间为28800s也就是8个小时。&lt;br&gt;
根据实施反应在出现这个异常之后的时间里服务是正常的但是对DB的查询无法正常执行&lt;br&gt;
问题排查&lt;br&gt;
1.先检查DB的连接配置 公司用的是mybaits 这里根据自身实际情况再进行排查&lt;br&gt;
查看mysql连接最大超时时间&lt;br&gt;
&lt;code&gt;show global variables like &#39;%timeout%&#39;;&lt;/code&gt;&lt;br&gt;
发现产线上的wait_timeout为1800s 也就是30min 这里开始怀疑是不是事务的执行超过了30min 但是还没有有力证据证明&lt;br&gt;
2.紧接着根据日志排查发现出事情的那天相关任务的执行耗时超过了30min 在线上拿到以往没出事情的日志来看任务的执行时间都是少于30min 也就证实了上述猜想是对的 正常是把wait_timeou参数调大一点就行了&lt;br&gt;
跟组长讨论了以往的情况 了解到以前也出现过类似情况 而解决方法也正如我上述所述&lt;br&gt;
修改完参数大小之后重启服务 之后根据实施反馈上述问题再也没出现过&lt;br&gt;
一般情况下 等待超时timeout为 28800s 也就是8小时 事务的执行完成 一般都是在这个时间段内&lt;br&gt;
注意点：&lt;br&gt;
1.一般情况下谨慎修改产线程参数&lt;br&gt;
2.wait_timeout 和interactive_time需要同时修改才能生效&lt;/p&gt;
">数据库连接超时问题解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/git/"" data-c="
          &lt;h1 id=&#34;技巧1优化配置&#34;&gt;技巧1:优化配置&lt;/h1&gt;
&lt;p&gt;Git 在全局、用户和本地级别上都是高度可配置的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-config&#34;&gt;git配置文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;查找顺序&#34;&gt;查找顺序&lt;/h2&gt;
&lt;p&gt;每个设置都可以被覆盖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本地级别:
项目文件夹/.git/config
用户级别:
用户目录/.config/git
用户目录/.gitconfig
全局级别：
git目录/etc/gitconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改配置&#34;&gt;修改配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 全局设置
git config --global &amp;lt;keypath&amp;gt; &amp;lt;value&amp;gt;
# 本地设置
git config &amp;lt;keypath&amp;gt; &amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;显示当前设置&#34;&gt;显示当前设置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 显示当前设置及其来源
git config --list --show-origin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一些有用的配置&#34;&gt;一些有用的配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设定身份
git config --global user.name&amp;quot;&amp;lt;your name&amp;gt;&amp;quot;
git config --global user.email &amp;lt;your email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧2别名alias&#34;&gt;技巧2:别名(alias)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;%5Bhttps://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D%5D(https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D)&#34;&gt;Git 别名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建别名来保存常用的git命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建别名
git config --global alias.&amp;lt;alias-name&amp;gt; &amp;quot;&amp;lt;git command&amp;gt;&amp;quot;
# 使用别名
git &amp;lt;alias-name&amp;gt; &amp;lt;more optional arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;一些有用的别名&#34;&gt;一些有用的别名&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 撤销上次提交
git config --global alias.undo &amp;quot;reset --soft HEAD^&amp;quot;
# 将暂存区更新修订到上次提交 (不改变提交信息)
git config --global alias.amend &amp;quot;commit --amend --no-edit&amp;quot;
# 压缩的状态输出
git config --global alias.st &amp;quot;status -sb&amp;quot;
# 用 GRAPH 为日志着色
git config --global alias.lg &amp;quot;log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&#39;&amp;quot;
# 删除所有已合并的分支
git config --global alias.rmb &amp;quot;!git branch --merged | grep -v &#39;*&#39; | xargs -n 1 git branch -d&amp;quot;
# 贡献排行
git config --global alias.rank &amp;quot;shortlog -n -s --no-merges&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧-3查找-commits-和更改&#34;&gt;技巧 3：查找 Commits 和更改&lt;/h1&gt;
&lt;h2 id=&#34;通过commits信息查找&#34;&gt;通过commits信息查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 通过 commit 信息查找 (所有分支)
git log --all --grep=&#39;&amp;lt;search term&amp;gt;&#39;
# 通过 commit 信息查找 (包含 reflog)
git log-g --grep=&#39;&amp;lt;search term&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;通过更改查找&#34;&gt;通过更改查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 通过更新的内容查找
git log -S &#39;&amp;lt;search term&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;通过日期查找&#34;&gt;通过日期查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 通过日期范围查找
git log --after=&#39;DEC 152019&#39; --until=&#39;JAN 102020&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧4添加hunk&#34;&gt;技巧4:添加hunk&lt;/h1&gt;
&lt;p&gt;git add &lt;filepath&gt; 不仅能添加文件的所有变更， --path / -p 参数还可以交互式暂存区块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 补丁命令
y = 暂存区块
n = 不暂存这个区块
q = 退出
a = 暂存当前文件的此区块以及所有剩余区块
d = 不暂存当前文件的此区块以及所有剩余区块
/ = 查找区块 (正则表达式)
s = 划分成更小的区块
e = 手动编辑区块
? = 打印帮助说明
g = 选择要前往的区块
j = 将区块设为未定，查看下一个未定区块
J = 将区块设为未定，查看下一个区块
k = 将区块设为未定，查看上一个未定区块
J = 将区块设为未定，查看下一个区块
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧-5-储藏stash更改而不提交&#34;&gt;技巧 5： 储藏（stash）更改而不提交&lt;/h1&gt;
&lt;p&gt;stash 将当前的更改临时搁置起来。在它的帮助下，可以返回当前状态的索引，并能在稍后应用已储藏的更改。&lt;/p&gt;
&lt;p&gt;默认情况下，仅储藏当前跟踪文件中的更改，新文件将被忽略。&lt;/p&gt;
&lt;p&gt;我们可以独立地创建和应用多个 stash。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;%5Bhttps://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86%5D(https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86)&#34;&gt;Git 工具 - 储藏与清理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 创建新的 STASH
git stash
# 创建新的 STASH (包含未追踪的更改)
git stash -u/--include-untracked
# 创建新的 STASH 并命名
git stash save&amp;quot;&amp;lt;stash name&amp;gt;&amp;quot;
# 交互式储藏
git stash -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;罗列&#34;&gt;罗列&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有的 STASH (为其他命令提供 &amp;quot;n&amp;quot;)
git stash list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;浏览&#34;&gt;浏览&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 浏览 STASH 内容
git stash show
# 浏览 STASH 差异
git stash show -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 应用上一个 STASH (删除 stash)
git stash pop
# 应用上一个 STASH (保留 stash)
git stash apply
# 应用特定的 STASH (n = stash 列表序号)
git stash pop/apply stash@{n}
# 从 STASH 创建新的分支 (n = stash 列表序号)
git stash branch &amp;lt;newbranch name&amp;gt; stash@{n}
# 从 STASH 应用单个文件 (n = stash 列表序号)
git checkout stash@{n} -- &amp;lt;filepath&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;清理&#34;&gt;清理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 删除特定的 STASH (n = stash 列表序号)
git stash drop stash@{n}
# 删除所有的 STASH
git stash clear
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧-6空运行dry-run&#34;&gt;技巧 6：空运行（Dry Run）&lt;/h1&gt;
&lt;p&gt;许多 git 操作可能具有破坏性，例如， git clean -f 将删除所有未跟踪的文件，而且无法恢复。&lt;/p&gt;
&lt;p&gt;要避免出现这种灾难性的结果，许多命令都支持 &lt;em&gt;dry-run&lt;/em&gt; ，可以在实际产生结果前对其进行检查。不过遗憾的是，使用的选项不完全一致：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clean -n/--dry-run
git add -n/--dry-run
git rm -n/--dry-run
# GIT MERGE 模拟 DRY-RUN
git merge --no-commit --no-ff &amp;lt;branch&amp;gt;
git diff --cached
git merge --abort
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧-7安全强制推送&#34;&gt;技巧 7：安全强制推送&lt;/h1&gt;
&lt;p&gt;在处理旧的 commit、创建新的 head 等情况时时很容易弄乱分支。 git push --force 可以覆盖远程变更，但不应该这样做！&lt;/p&gt;
&lt;p&gt;git push --force 是一种具有破坏性且危险的操作，因为它无条件生效，并且会破坏其他提交者已经推送的所有 commit。这对于其他人的代码仓库来说不一定是致命的，但是改变历史记录并影响其他人并不是一个好主意。&lt;/p&gt;
&lt;p&gt;更好的选择是使用 git push --force-with-lease 。&lt;/p&gt;
&lt;p&gt;git 不会无条件地覆盖上游的远程仓库，而是检查是否有本地不可用的远程更改。如果有，它会失败并显示一条“stale info”消息，并告诉我们需要先运行 git fetch 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-push#Documentation/git-push.txt---force-with-leaseltrefnamegt&#34;&gt;git push&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;技巧-8修改-commit-信息&#34;&gt;技巧 8：修改 commit 信息&lt;/h1&gt;
&lt;p&gt;Commit 是不可变的，且不能更改。不过可以用一条新的 commit 信息修订现有的 commit，这会覆盖原始 commit，因此请勿在已推送的 commit 中使用它。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git commit --amend -m &amp;quot;&amp;lt;new commit message&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;技巧-9修改历史&#34;&gt;技巧 9：修改历史&lt;/h1&gt;
&lt;p&gt;修改代码仓库的历史不仅限于修改上次提交信息，使用 git rebase 可以修改多个提交：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 提交的范围
git rebase -i/--interactive HEAD~&amp;lt;number of commits&amp;gt;
# 该 hash 之后的所有提交
git rebase -i/--interactive &amp;lt;commit hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在配置的编辑器中倒序列出所有的 commit，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#&amp;lt;command&amp;gt;&amp;lt;commit hash&amp;gt;&amp;lt;commit message&amp;gt;
pick5df8fbc revamped logic
pick ca5154e README typos fixed
pick a104aff added awesome new feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过更改编辑器中的实际内容，可以为 git 提供一个方案，来说明如何进行 rebase：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# p, pick = 使用提交而不更改
# r, reword = 修改提交信息
# e, edit = 编辑提交
# s, squash = 汇合提交
# f, fixup = 类似 &amp;quot;squash&amp;quot;，但是会丢弃提交信息
# x, exec = 运行命令 (其余行)
# d, drop = 移除提交
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存编辑器后，git 将运行该方案以重写历史记录。&lt;/p&gt;
&lt;p&gt;e, edit 会暂停 rebase，就可以编辑代码仓库的当前状态。完成编辑后，运行 git rebase --continue 。&lt;/p&gt;
&lt;p&gt;如果过程中出现问题（例如合并冲突），我们需要重新开始，可以使用 git rebase --abort 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-rebase&#34;&gt;git-rebase&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;技巧-10存档跟踪文件&#34;&gt;技巧 10：存档跟踪文件&lt;/h1&gt;
&lt;p&gt;可以使用不同格式（ zip 或 tar ）来压缩特定引用的跟踪文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git archive --format&amp;lt;format&amp;gt; --output&amp;lt;filename&amp;gt; &amp;lt;ref&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;ref&gt; 可以是一个分支、commit hash 或者一个标签。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-archive&#34;&gt;git-archive&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;额外提醒单破折号&#34;&gt;额外提醒：单破折号&lt;/h1&gt;
&lt;p&gt;有一个快捷方式可以表示刚用过的分支：一个单破折号 -&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout my-branch
# 当前分支：my-branch
&amp;lt;dosome git operations, e.g. adding/commiting&amp;gt;
git checkout develop
# 当前分支：develop
git merge -
# 将 my-branch 合并到 develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单破折号等同于 @{-1} 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs/git-checkout#Documentation/git-checkout.txt-ltbranchgt&#34;&gt;git-checkout&lt;/a&gt;&lt;/p&gt;
">Git</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/jrebel-pei-zhi-yuan-cheng-re-bu-shu/"" data-c="
          &lt;h1 id=&#34;jrebel配置远程热部署&#34;&gt;Jrebel配置远程热部署&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jrebel.com/products/jrebel/learn&#34;&gt;官方教程文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载Jrebel和Xrebel相应的版本。（&lt;a href=&#34;https://www.jrebel.com/products/jrebel/download/prev-releases&#34;&gt;Jrebel官网下载&lt;/a&gt;、&lt;a href=&#34;https://www.jrebel.com/products/xrebel/download&#34;&gt;Xrebel官网下载&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;激活地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://jrebel.cicoding.cn/{GUID}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;https://www.guidgen.com/{GUID}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传到服务器上，并解压。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;激活插件：下面两个命令随便一条都行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./bin/activate.sh http://jrebel.cicoding.cn/{GUID} {用户邮箱}
java -jar jrebel.jar -activate http://jrebel.cicoding.cn/{GUID} {用户邮箱}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置远程密码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;java -jar jrebel.jar -set-remote-password {要设置的密码}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;idea设置&#34;&gt;Idea设置&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Idea安装相关插件，详见：&lt;a href=&#34;https://mxecy.cn/post/idea-jrebel/&#34;&gt;Jrebel配置&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置远程服务器：&lt;a href=&#34;https://manuals.jrebel.com/jrebel/remoteserver/intellij.html&#34;&gt;官网配置教程&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;File -&amp;gt; JRebel &amp;amp; Xrebel -&amp;gt; Jrebel Startup -&amp;gt; 勾选[Run on a remote server or VM]
File -&amp;gt; JRebel &amp;amp; Xrebel -&amp;gt; Jrebel Remote Servers -&amp;gt; 点+添加新服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用的时候，只需要添加几个启动参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-javaagent:{xrebel路径}\xrebel.jar # 启动Xrebel
-agentpath:{jrebel路径}\lib\libjrebel64.so # 启动jrebel
-Drebel.remoting_plugin=true # 启动远程插件
-Drebel.remoting_port={端口号} # 可选，针对没有http的程序才使用，会添加一个jetty容器提供服务。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Jrebel配置远程热部署</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/rabbitmq/"" data-c="
          &lt;h2 id=&#34;1-什么是中间件&#34;&gt;1. 什么是中间件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。&lt;/p&gt;
&lt;p&gt;中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要使用消息中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中间件特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件时位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。&lt;/p&gt;
&lt;p&gt;也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：&lt;/p&gt;
&lt;p&gt;（1）满足大量应用的需要&lt;/p&gt;
&lt;p&gt;（2）运行于多种硬件和 OS平台&lt;/p&gt;
&lt;p&gt;（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互&lt;/p&gt;
&lt;p&gt;（4）支持标准的协议&lt;/p&gt;
&lt;p&gt;（5）支持标准的接口&lt;/p&gt;
&lt;p&gt;由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。&lt;/p&gt;
&lt;p&gt;简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在项目中什么时候使用中间件技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和成本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。&lt;/p&gt;
&lt;p&gt;但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和经历去探讨和研究。&lt;/p&gt;
&lt;h2 id=&#34;2-中间件技术及架构的概述&#34;&gt;2. 中间件技术及架构的概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;学习中间件的方式和技巧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解中间件在项目架构中的作用，以及各中间件的底层实现&lt;/li&gt;
&lt;li&gt;可以使用一些类比的生活概念去理解中间件&lt;/li&gt;
&lt;li&gt;使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用&lt;/li&gt;
&lt;li&gt;尝试用 java技术去实现中间件的原理&lt;/li&gt;
&lt;li&gt;静下来去思考中间件在项目中设计的和使用的原因&lt;/li&gt;
&lt;li&gt;如果找到对应的代替总结方案&lt;/li&gt;
&lt;li&gt;尝试编写博文总结类同中间件技术的对比和使用场景&lt;/li&gt;
&lt;li&gt;学会查看中间件的源码以及开源项目和博文&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是消息中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实际的项目中，大部分的企业项目开发中，在早起都采用的是单体的架构模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单体架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在企业开发当中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点：就是把所有的业务和模块，源代码，静态资源文件等都放在一个工程中，如果其中的一个模块升级或者迭代发生一个很小的变动都会重新编译和重新部署项目。这种这狗存在的问题是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;耦合度太高&lt;/li&gt;
&lt;li&gt;不易维护&lt;/li&gt;
&lt;li&gt;服务器的成本高&lt;/li&gt;
&lt;li&gt;以及升级架构的复杂度也会增大&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就有后续的分布式架构系统。如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;何谓分布式系统：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗一点：就是一个请求由服务器端的多个服务（服务或者系统）协同处理完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和单体架构不同的是，单体架构是一个请求发起 jvm调度线程（确切的是 tomcat线程池）分配线程 Thread来处理请求直到释放，而分布式系统是：一个请求时由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就像建设一个小房子很快就能够搞定，如果你要建设一个鸟巢或者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展到后期的时候要去部署和思考的问题。我们也不难看出来：分布式架构系统存在的特点和问题如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习成本高，技术栈过多&lt;/li&gt;
&lt;li&gt;运维成本和服务器成本增高&lt;/li&gt;
&lt;li&gt;人员的成本也会增高&lt;/li&gt;
&lt;li&gt;项目的负载度也会上升&lt;/li&gt;
&lt;li&gt;面临的错误和容错性也会成倍增加&lt;/li&gt;
&lt;li&gt;占用的服务器端口和通讯的选择的成本高&lt;/li&gt;
&lt;li&gt;安全性的考虑和因素逼迫可能选择 RMI/MQ相关的服务器端通讯&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务系统的独立，占用的服务器资源减少和占用的硬件成本减少，确切的说是：可以合理的分配服务资&lt;/li&gt;
&lt;li&gt;源，不造成服务器资源的浪费&lt;/li&gt;
&lt;li&gt;系统的独立维护和部署，耦合度降低，可插拔性&lt;/li&gt;
&lt;li&gt;系统的架构和技术栈的选择可以变的灵活（而不是单纯地选择 java）&lt;/li&gt;
&lt;li&gt;弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-基于消息中间件的分布式系统的架构&#34;&gt;3. 基于消息中间件的分布式系统的架构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;利用可靠的消息传递机制进行系统和系统直接的通讯&lt;/li&gt;
&lt;li&gt;通过提供消息传递和消息的派对机制，它可以在分布式系统环境下扩展进程间的通讯&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;消息中间件应用的场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;跨系统数据传递&lt;/li&gt;
&lt;li&gt;高并发的流量削峰&lt;/li&gt;
&lt;li&gt;数据的并发和异步处理&lt;/li&gt;
&lt;li&gt;大数据分析与传递&lt;/li&gt;
&lt;li&gt;分布式事务比如你有一个数据要进行迁移或者请求并发过多的时候，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如你有10 W的并发请求下订单，我们可以在这些订单入库之前，我们可以把订单请求堆积到消息队列中，让它稳健可靠的入库和执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的消息中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ActiveMQ、RabbitMQ、Kafka、RocketMQ等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消息中间件的本质及设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务&lt;/p&gt;
&lt;p&gt;MQ消息队列：负责数据的传接受，存储和传递，所以性能要高于普通服务和技术&lt;/p&gt;
&lt;p&gt;谁来生产消息，存储消息和消费消息呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消息中间件的核心组成部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息的协议&lt;br&gt;
消息的持久化机制&lt;br&gt;
消息的分发策略&lt;br&gt;
消息的高可用，高可靠&lt;br&gt;
消息的容错机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实不论选择单体架构还是分布式架构都是项目开发的一个阶段，在什么阶段选择合适的架构方式，而不能盲目追求，最后造成的后果和问题都需要自己买单。但作为一个开发人员学习和探讨新的技术使我们每个程序开发者都应该去保持和思考的问题。当我们没办法去改变社会和世界的时候，我们为了生活和生存那就必须要迎合企业和市场的需求，发挥你的价值和所学的才能，创造价值和实现自我&lt;/p&gt;
&lt;h2 id=&#34;4-消息队列协议&#34;&gt;4. 消息队列协议&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓协议是指：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流&lt;/li&gt;
&lt;li&gt;和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高&lt;/li&gt;
&lt;li&gt;协议对数据格式和计算机之间交换数据都必须严格遵守规范&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;网络协议的三要素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序&lt;/li&gt;
&lt;li&gt;语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应&lt;/li&gt;
&lt;li&gt;时序：时序是对事件发生顺序的详细说明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的 http请求协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法：http规定了请求报文和响应报文的格式&lt;/li&gt;
&lt;li&gt;语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）&lt;/li&gt;
&lt;li&gt;时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而消息中间件采用的并不是 http协议，而常见的消息中间件协议有有：OpenWire、AMQP、MQTT、Kafka，OpenMessage协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试题：为什么消息中间件不直接使用 http协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速&lt;/li&gt;
&lt;li&gt;大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;AMQP协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现由 RabbitMQ等&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式事务支持&lt;/li&gt;
&lt;li&gt;消息的持久化支持&lt;/li&gt;
&lt;li&gt;高性能和高可靠的消息处理优势&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;MQTT协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MQTT协议（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;轻量&lt;/li&gt;
&lt;li&gt;结构简单&lt;/li&gt;
&lt;li&gt;传输快，不支持事务&lt;/li&gt;
&lt;li&gt;没有持久化设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;适用于计算能力有限&lt;/li&gt;
&lt;li&gt;低带宽&lt;/li&gt;
&lt;li&gt;网络不稳定的场景&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;支持者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OpenMessage协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构简单&lt;/li&gt;
&lt;li&gt;解析速度快&lt;/li&gt;
&lt;li&gt;支持事务和持久化设计&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Kafka协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kafka协议是基于 TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构简单&lt;/li&gt;
&lt;li&gt;解析速度快&lt;/li&gt;
&lt;li&gt;无事务支持&lt;/li&gt;
&lt;li&gt;有持久化设计&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协议：实在 tcp/ip协议基础之上构建的一种约定俗称的规范和机制、它的主要目的可以让客户端（应用程序 java，go）进行沟通和通讯。并且这种写一下规范必须具有持久性，高可用，高可靠的性能&lt;/p&gt;
&lt;h2 id=&#34;5-消息队列持久化&#34;&gt;5. 消息队列持久化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;持久化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的持久化方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6-消息的分发策略&#34;&gt;6. 消息的分发策略&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;消息的分发策略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MQ消息 队列有如下几个角色&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生产者&lt;/li&gt;
&lt;li&gt;存储消息&lt;/li&gt;
&lt;li&gt;消费者&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;场景分析一&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C15.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fQ6t7C7S-1615813808736)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315134437071.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;场景分析二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C16.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l0CNvOUV-1615813808737)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315134747313.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发&lt;br&gt;
消息分发策略的机制和对比&lt;/p&gt;
&lt;h2 id=&#34;7-消息队列高可用和高可靠&#34;&gt;7. 消息队列高可用和高可靠&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是高可用机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力&lt;/p&gt;
&lt;p&gt;当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群模式1 - Master-slave主从共享数据的部署方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;集群模式2 - Master-slave主从同步部署方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，以为消息的拷贝和同步会占用很大的带宽和网络资源。在后去的 rabbitmq中会有使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群模式3 - 多主集群同步部署模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释：和上面的区别不是特别的大，但是它的写入可以往任意节点去写入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群模式4 - 多主集群转发部署模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群模式5 Master-slave与 Broker-cluster组合的方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是高可靠机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓高可靠是指：系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠&lt;/p&gt;
&lt;p&gt;在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的&lt;/p&gt;
&lt;p&gt;如何保证中间件消息的可靠性呢，可以从两个方面考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息的传输：通过协议来保证系统间数据解析的正确性&lt;/li&gt;
&lt;li&gt;消息的存储区可靠：通过持久化来保证消息的可靠性&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;二-入门及安装&#34;&gt;二、入门及安装&lt;/h1&gt;
&lt;h2 id=&#34;1-rabbitmq入门及安装&#34;&gt;1. RabbitMQ入门及安装&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1dX4y1V73G?p=27&lt;/p&gt;
&lt;h3 id=&#34;01-概述&#34;&gt;01 概述&lt;/h3&gt;
&lt;p&gt;简单概述：&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个开源的遵循 AMQP协议实现的基于 Erlang语言编写，支持多种客户端（语言），用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征&lt;/p&gt;
&lt;h3 id=&#34;02下载rabbitmq&#34;&gt;02下载RabbitMQ&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载地址：https://www.rabbitmq.com/download.html&lt;/li&gt;
&lt;li&gt;环境准备：CentOS7.x + /Erlang&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RabbitMQ是采用 Erlang语言开发的，所以系统环境必须提供 Erlang环境，第一步就是安装 Erlang&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C24.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WVkC8e8q-1615876872944)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315164044604.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;03-安装erlang&#34;&gt;03 安装Erlang&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;查看系统版本号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;安装下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /usr/rabbitmq
ca /usr//rabbitmq
# 将安装包上传到linux系统中
erlang-22.0.7-1.el7.x86_64.rpm
rabbitmq-server-3.7.18-1.el7.noarch.rpm

rpm -Uvh erlang-solutions-2.0-1.noarch.rpm
yum install -y erlang
erl -v
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;04-安装socat&#34;&gt;04 安装socat&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;安装下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;yum install -y socat
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;05-安装rabbitmq&#34;&gt;05 安装rabbitmq&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C26.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;安装下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rpm -Uvh rabbitmq-server-3.7.18-1.el7.noarch.rpm
yum install rabbitmq-server -y
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;启动服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 启动服务
systemctl start rabbitmq-server
# 查看服务状态，如图
systemctl status rabbitmq-server.service
# 开机自启动
systemctl enable rabbitmq-server
# 停止服务
systemctl stop rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-rabbitmqweb管理界面及授权操作&#34;&gt;2. RabbitMQWeb管理界面及授权操作&lt;/h2&gt;
&lt;h3 id=&#34;01-rabbitmq管理界面&#34;&gt;01 RabbitMQ管理界面&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况下，是没有安装web端的客户端插件，需要安装才可以生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：rabbitmq有一个默认账号和密码是：&lt;code&gt;guest&lt;/code&gt;默认情况只能在 localhost本计下访问，所以需要添加一个远程登录的用户&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;安装完毕以后，重启服务即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl restart rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定要记住，在对应服务器（阿里云，腾讯云等）的安全组中开放&lt;code&gt;15672&lt;/code&gt;端口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在浏览器访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C28.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;# 10.关闭防火墙服务
systemctl disable firewalld
Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
systemctl stop firewalld   
# 11.访问web管理界面
http://10.15.0.8:15672/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;02-授权账号和密码&#34;&gt;02 授权账号和密码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;新增用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl add_user admin admin
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;设置用户分配操作权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl set_user_tags admin administrator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户级别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;administrator：可以登录控制台、查看所有信息、可以对 rabbitmq进行管理&lt;/li&gt;
&lt;li&gt;monitoring：监控者 登录控制台，查看所有信息&lt;/li&gt;
&lt;li&gt;policymaker：策略制定者 登录控制台，指定策略&lt;/li&gt;
&lt;li&gt;managment 普通管理员 登录控制台&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为用户添加资源权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rabbitmqctl set_permissions -p / admin &amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;&amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;网页登录成功&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;03小结&#34;&gt;03小结：&lt;/h3&gt;
&lt;h2 id=&#34;3-rabbitmq之docker安装&#34;&gt;3. RabbitMQ之Docker安装&lt;/h2&gt;
&lt;h3 id=&#34;01-dokcer安装rabbitmq&#34;&gt;01 Dokcer安装RabbitMQ&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟化容器技术 - Docker的安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C31.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;docker的相关命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C32.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;安装rabbitmq&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C33.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;可以直接走图中代码，不用走下面两项！&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取rabbit镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;docker pull rabbitmq:management
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;创建并运行容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;docker run -id --name=myrabbit -p 15672:15672 rabbitmq:management
--hostname：指定容器主机名称
--name:指定容器名称
-p：将mq端口号映射到本地
或者运行时设置用户和密码
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C34.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-787v1Med-1615876872953)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315173500241.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C35.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-84RcXU0z-1615876872954)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315173924970.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;访问网页，访问成功！&lt;/p&gt;
&lt;h2 id=&#34;4-rabbitmq的角色分类&#34;&gt;4. RabbitMQ的角色分类&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C36.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C37.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;三-入门案例&#34;&gt;三、入门案例&lt;/h1&gt;
&lt;h2 id=&#34;1-rabbitmq入门案例-simple-简单模式&#34;&gt;1. RabbitMQ入门案例 - Simple 简单模式&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1dX4y1V73G?p=44 实现步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jdk1.8&lt;/li&gt;
&lt;li&gt;构建一个 maven工程&lt;/li&gt;
&lt;li&gt;导入 rabbitmq的 maven依赖&lt;/li&gt;
&lt;li&gt;启动 rabbitmq-server服务&lt;/li&gt;
&lt;li&gt;定义生产者&lt;/li&gt;
&lt;li&gt;定义消费者&lt;/li&gt;
&lt;li&gt;观察消息的在 rabbitmq-server服务中的进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;01-构建一个maven工程&#34;&gt;01 构建一个maven工程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C38.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;02-导入依赖&#34;&gt;02 导入依赖&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;java原生依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.10.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;03-第一种模型&#34;&gt;03 第一种模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C39.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在上图的模型中，有以下概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生产者，也就是要发送消息的程序&lt;/li&gt;
&lt;li&gt;消费者：消息的接受者，会一直等待消息到来。&lt;/li&gt;
&lt;li&gt;消息队列：图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//简单模式
public class Producer{
    //1.创建连接工厂
    ConnectionFactory connectionFactory = new ConnectionFactory();
    connectionFactory.setHost(&amp;quot;10.15.0.9&amp;quot;);
    connectionFactory.setPort(5672);
    connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
    connectionFactory.setPassword(&amp;quot;admin&amp;quot;);
    connectionFactory.setVirtualHost(&amp;quot;/&amp;quot;);
    Connection connection = connectionFactory.newConnection(&amp;quot;生产者&amp;quot;);
    //2.创建通道
    Channel channel = connection.createChannel();
    //3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息
    /*参数1: 是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失
      参数2:是否独占队列 
      参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除
        参数4:携带附属属性
    */
    String queueName = &amp;quot;queue1&amp;quot;;
    channel.queueDeclare(queueName,false,false,false,null);
    //4.发送消息给队列queue
    /*参数1: 交换机
      参数2:队列、路由key
      参数3:消息的状态控制
        参数4:消息主题
    */
    //面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机
    String message = &amp;quot;Hello&amp;quot;;
    channel.basicPublish(&amp;quot;&amp;quot;,message, null,message.getBytes());
    //5.关闭
    channel.close();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//简单模式
public class Consumer{
    //1.创建连接工厂
    ConnectionFactory connectionFactory = new ConnectionFactory();
    connectionFactory.setHost(&amp;quot;10.15.0.9&amp;quot;);
    connectionFactory.setPort(5672);
    connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
    connectionFactory.setPassword(&amp;quot;admin&amp;quot;);
    connectionFactory.setVirtualHost(&amp;quot;/&amp;quot;);
    Connection connection = connectionFactory.newConnection(&amp;quot;生产者&amp;quot;);
    //2.创建通道
    Channel channel = connection.createChannel();
    //3.接受内容
    channel.basicConsume(&amp;quot;queue1&amp;quot;,true,new DefaultConsumer(){
        public void handle(String consumerTag, Delivery message) throws IOException {
          System.out.println(new String(&amp;quot;收到消息是&amp;quot; + new String(meassage.getBody()),&amp;quot;UTF-8&amp;quot;));
        },new CancelCallback(){
            public void handle(String consumerTag) throws IOException {
                System.out.println(&amp;quot;接受失败了&amp;quot;);
        }
      });
    //4.关闭
    channel.close();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-什么是amqp&#34;&gt;2. 什么是AMQP&lt;/h2&gt;
&lt;h3 id=&#34;01-什么是amqp&#34;&gt;01 什么是AMQP&lt;/h3&gt;
&lt;p&gt;AMQP全称：Advanced Message Queuing Protocol（高级消息队列协议）。是应用层协议的一个开发标准，为面向消息的中间件设计&lt;/p&gt;
&lt;h3 id=&#34;02-amqp生产者流转过程&#34;&gt;02 AMQP生产者流转过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C40.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-78cQpQXh-1615906714913)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315201857946.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;03-amqp消费者流转过程&#34;&gt;03 AMQP消费者流转过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C41.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-rabbitmq的核心组成部分&#34;&gt;3. RabbitMQ的核心组成部分&lt;/h2&gt;
&lt;h3 id=&#34;01-rabbitmq的核心组成部分&#34;&gt;01 RabbitMQ的核心组成部分&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C43.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C42.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;02-rabbitmq整体架构是什么样子的&#34;&gt;02 RabbitMQ整体架构是什么样子的？&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C44.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;03-rabbitmq的运行流程&#34;&gt;03 RabbitMQ的运行流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C45.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;04-rabbitmq支持的消息模型&#34;&gt;04 RabbitMQ支持的消息模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C46.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C47.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;简单模式 Simple&lt;/li&gt;
&lt;li&gt;工作模式 Work&lt;/li&gt;
&lt;li&gt;发布订阅模式&lt;/li&gt;
&lt;li&gt;路由模式&lt;/li&gt;
&lt;li&gt;主题 Topic模式&lt;/li&gt;
&lt;li&gt;参数模式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-rabbitmq入门案例-fanout-模式&#34;&gt;4. RabbitMQ入门案例 - fanout 模式&lt;/h2&gt;
&lt;h3 id=&#34;01-rabbitmq的模式之发布订阅模式&#34;&gt;01 RabbitMQ的模式之发布订阅模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;图解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C48.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;发布订阅模式的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;web操作查看视频&lt;/li&gt;
&lt;li&gt;类型：fanout&lt;/li&gt;
&lt;li&gt;特点：Fanout - 发布与订阅模式，是一种广播机制，它是没有路由 key的模式&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//简单模式
public class Producer{
    //1.创建连接工厂
    ConnectionFactory connectionFactory = new ConnectionFactory();
    connectionFactory.setHost(&amp;quot;10.15.0.9&amp;quot;);
    connectionFactory.setPort(5672);
    connectionFactory.setUsername(&amp;quot;admin&amp;quot;);
    connectionFactory.setPassword(&amp;quot;admin&amp;quot;);
    connectionFactory.setVirtualHost(&amp;quot;/&amp;quot;);
    Connection connection = connectionFactory.newConnection(&amp;quot;生产者&amp;quot;);
    //2.创建通道
    Channel channel = connection.createChannel();
    //3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息
    /*参数1: 是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失
      参数2:是否独占队列 
      参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除
        参数4:携带附属属性
    */
    String queueName = &amp;quot;queue1&amp;quot;;
    channel.queueDeclare(queueName,false,false,false,null);
    //4.发送消息给队列queue
    /*参数1: 交换机
      参数2:队列、路由key
      参数3:消息的状态控制
        参数4:消息主题
    */
    //面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机
    String message = &amp;quot;Hello&amp;quot;;
    //5.准备交换机
    String exchangeName = &amp;quot;fanout-exchange&amp;quot;;
    //6.定义路由key
    String routeKey = &amp;quot;&amp;quot;;
    //7.指定交换机的类型
    String type = &amp;quot;fanout&amp;quot;;
    channel.basicPublish(exchangeName,routeKey, null,message.getBytes());
    //8.关闭
    channel.close();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码一样，使用线程启动测试而已！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C49.jpg&#34; alt=&#34;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uud19sfq-1615906714934)(C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210315222738258.png)]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;此处没有通过代码去绑定交换机和队列，而是通过可视化界面去绑定的！&lt;/p&gt;
&lt;h2 id=&#34;5-rabbitmq入门案例-direct-模式&#34;&gt;5. RabbitMQ入门案例 - Direct 模式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//6.定义路由key
String routeKey = &amp;quot;email&amp;quot;;
//7.指定交换机的类型
String type = &amp;quot;direct&amp;quot;;
channel.basicPublish(exchangeName,routeKey, null,message.getBytes());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-rabbitmq入门案例-topic-模式&#34;&gt;6. RabbitMQ入门案例 - Topic 模式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C50.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//6.定义路由key
String routeKey = &amp;quot;com.order.test.xxx&amp;quot;;
//7.指定交换机的类型
String type = &amp;quot;direct&amp;quot;;
channel.basicPublish(exchangeName,routeKey, null,message.getBytes());
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码创建及绑定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//5.准备交换机
String exchangeName = &amp;quot;direct_message_exchange&amp;quot;;
String exchangeType = &amp;quot;direct&amp;quot;;
//如果你用界面把queue和exchange的关系先绑定话，代码就不需要在编写这些声明代码可以让代码变得更简洁
//如果用代码的方式去声明，我们要学习一下
//6.声明交换机 所谓的持久化就是指，交换机会不会随着服务器重启造成丢失
channel.exchangeDeclare(exchangeName,exchangeType,true);

//7.声明队列
channel.queueDeclare(&amp;quot;queue5&amp;quot;,true,false,false,null);
channel.queueDeclare(&amp;quot;queue6&amp;quot;,true,false,false,null);
channel.queueDeclare(&amp;quot;queue7&amp;quot;,true,false,false,null);

//8.绑定队列和交换机的关系
channel.queueBind(&amp;quot;queue5&amp;quot;,exchangeName,&amp;quot;order&amp;quot;);
channel.queueBind(&amp;quot;queue6&amp;quot;,exchangeName,&amp;quot;order&amp;quot;);
channel.queueBind(&amp;quot;queue7&amp;quot;,exchangeName,&amp;quot;course&amp;quot;);

channel.basicPublish(exchangeName,course, null,message.getBytes());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-rabbitmq入门案例-work模式&#34;&gt;7. RabbitMQ入门案例 - Work模式&lt;/h2&gt;
&lt;h3 id=&#34;01-work模式轮询模式round-robin&#34;&gt;01 Work模式轮询模式（Round-Robin）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;图解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？&lt;/p&gt;
&lt;p&gt;主要有两种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;轮询模式的分发：一个消费者一条，按均分配&lt;/li&gt;
&lt;li&gt;公平分发：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；按劳分配&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟简单模式一样！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建两个一样的！&lt;/p&gt;
&lt;h3 id=&#34;02-work模式公平分发模式&#34;&gt;02 Work模式公平分发模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟简单模式一样！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//简单模式
public class Consumer{
    //3.接受内容
    //指标定义出来
    channel.basicQos(1);
    channel.basicConsume(&amp;quot;queue1&amp;quot;,false,new DefaultConsumer(){
        public void handle(String consumerTag, Delivery message) throws IOException {
          System.out.println(new String(&amp;quot;收到消息是&amp;quot; + new String(meassage.getBody()),&amp;quot;UTF-8&amp;quot;));
          //改成手动应答
          channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);
        },new CancelCallback(){
            public void handle(String consumerTag) throws IOException {
                System.out.println(&amp;quot;接受失败了&amp;quot;);
        }
      });
    //4.关闭
    channel.close();
    connection.close();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建两个一样的！&lt;/p&gt;
&lt;h2 id=&#34;8-rabbitmq使用场景&#34;&gt;8. RabbitMQ使用场景&lt;/h2&gt;
&lt;h3 id=&#34;01-解耦-削峰-异步&#34;&gt;01 解耦、削峰、异步&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;同步异步的问题（串行）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;串行方式：将订单信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C52.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void makeOrder(){
    //1.发送订单
    //2.发送短信服务
    //3.发送email服务
    //4.发送app服务
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;并行方式 异步线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并行方式：将订单信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C53.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void test(){
    //异步
    theadpool.submit(new Callable&amp;lt;Object&amp;gt;{
        //1.发送短信服务
    })
    //异步
    theadpool.submit(new Callable&amp;lt;Object&amp;gt;{
        //2.
    })
    //异步
    theadpool.submit(new Callable&amp;lt;Object&amp;gt;{
        //3.
    })
    //异步
    theadpool.submit(new Callable&amp;lt;Object&amp;gt;{
        //4.
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;耦合度高&lt;/li&gt;
&lt;li&gt;需要自己写线程池自己维护成本太高&lt;/li&gt;
&lt;li&gt;出现了消息可能会丢失，需要你自己做消息补偿&lt;/li&gt;
&lt;li&gt;如何保证消息的可靠性你自己写&lt;/li&gt;
&lt;li&gt;如果服务器承载不了，你需要自己去写高可用&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;异步消息队列的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C54.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完全解耦，用 MQ建立桥接&lt;/li&gt;
&lt;li&gt;有独立的线程池和运行模型&lt;/li&gt;
&lt;li&gt;出现了消息可能会丢失，MQ有持久化功能&lt;/li&gt;
&lt;li&gt;如何保证消息的可靠性，死信队列和消息转移等&lt;/li&gt;
&lt;li&gt;如果服务器承载不了，你需要自己去写高可用，HA镜像模型高可用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照以上约定，用户的响应时间相当于是订单信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍&lt;/p&gt;
&lt;h3 id=&#34;02-高内聚低耦合&#34;&gt;02 高内聚，低耦合&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C55.jpg&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完全解耦，用 MQ建立桥接&lt;/li&gt;
&lt;li&gt;有独立的线程池和运行模型&lt;/li&gt;
&lt;li&gt;出现了消息可能会丢失，MQ有持久化功能&lt;/li&gt;
&lt;li&gt;如何保证消息的可靠性，死信队列和消息转移等&lt;/li&gt;
&lt;li&gt;如果服务器承载不了，你需要自己去写高可用，HA镜像模型高可用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照以上约定，用户的响应时间相当于是订单信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20QPS。比串行提高了3倍，比并行提高了两倍&lt;/p&gt;
&lt;h1 id=&#34;四-springboot案例&#34;&gt;四、Springboot案例&lt;/h1&gt;
&lt;h2 id=&#34;1-fanout-模式&#34;&gt;1. Fanout 模式&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1dX4y1V73G?p=44&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;application.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# 服务端口
server:
  port: 8080
# 配置rabbitmq服务
spring:
    rabbitmq:
        username: admin
        password: admin
        virtual-host: /
        host: 127.0.0.1
        port: 5672
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OrderService.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderService{
    @Autowired
    private RabbitTemplate rabbitTemplate;
    //模拟用户下单
    public void makeOrder(String userid,String productid,int num){
        //1.根据商品id查询库存是否足够
        //2.保存订单
        String orderId = UUID.randomUUID().toString();
        sout(&amp;quot;订单生产成功：&amp;quot;+orderId);
        //3.通过MQ来完成消息的分发
        //参数1：交换机 参数2：路由key/queue队列名称 参数3：消息内容
        String exchangeName = &amp;quot;fanout_order_exchange&amp;quot;;
        String routingKey = &amp;quot;&amp;quot;;
        rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;application.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# 服务端口
server:
  port: 8080
# 配置rabbitmq服务
spring:
    rabbitmq:
        username: admin
        password: admin
        virtual-host: /
        host: 127.0.0.1
        port: 5672
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RabbitMqConfiguration{
    //1.声明注册fanout模式的交换机
    @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange(&amp;quot;fanout_order_exchange&amp;quot;,true,false);
    }
    //2.声明队列
    @Bean
    public Queue smsQueue(){
        return new Queue(&amp;quot;sms.fanout.queue&amp;quot;,true);
    }
    @Bean
    public Queue duanxinQueue(){
        return new Queue(&amp;quot;duanxin.fanout.queue&amp;quot;,true);
    }
    @Bean
    public Queue emailQueue(){
        return new Queue(&amp;quot;email.fanout.queue&amp;quot;,true);
    }
    //3.完成绑定关系
    @Bean
    public Binding smsBingding(){
        return BindingBuilder.bin(smsQueue()).to(fanoutExchange());
    }
    @Bean
    public Binding duanxinBingding(){
        return BindingBuilder.bin(duanxinQueue()).to(fanoutExchange());
    }
    @Bean
    public Binding emailBingding(){
        return BindingBuilder.bin(emailQueue()).to(fanoutExchange());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FanoutSmsConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queue = {&amp;quot;sms.direct.queue&amp;quot;})
public class FanoutSmsConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;sms接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FanoutDuanxinConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queue = {&amp;quot;duanxin.direct.queue&amp;quot;})
public class FanoutDuanxinConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;duanxin接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FanoutEmailConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(queue = {&amp;quot;duanxin.direct.queue&amp;quot;})
public class FanoutEmailConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;email接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-direct-模式&#34;&gt;2. Direct 模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;OrderService.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderService{
    @Autowired
    private RabbitTemplate rabbitTemplate;
    //模拟用户下单
    public void makeOrder(String userid,String productid,int num){
        //1.根据商品id查询库存是否足够
        //2.保存订单
        String orderId = UUID.randomUUID().toString();
        sout(&amp;quot;订单生产成功：&amp;quot;+orderId);
        //3.通过MQ来完成消息的分发
        //参数1：交换机 参数2：路由key/queue队列名称 参数3：消息内容
        String exchangeName = &amp;quot;direct_order_exchange&amp;quot;;
        String routingKey = &amp;quot;&amp;quot;;
        rabbitTemplate.convertAndSend(exchangeName,&amp;quot;email&amp;quot;,orderId);
        rabbitTemplate.convertAndSend(exchangeName,&amp;quot;duanxin&amp;quot;,orderId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;RabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class RabbitMqConfiguration{
    //1.声明注册fanout模式的交换机
    @Bean
    public DirectExchange directExchange(){
        return new DirectExchange(&amp;quot;direct_order_exchange&amp;quot;,true,false);
    }
    //2.声明队列
    @Bean
    public Queue smsQueue(){
        return new Queue(&amp;quot;sms.direct.queue&amp;quot;,true);
    }
    @Bean
    public Queue duanxinQueue(){
        return new Queue(&amp;quot;duanxin.direct.queue&amp;quot;,true);
    }
    @Bean
    public Queue emailQueue(){
        return new Queue(&amp;quot;email.direct.queue&amp;quot;,true);
    }
    //3.完成绑定关系
    @Bean
    public Binding smsBingding(){
        return BindingBuilder.bin(smsQueue()).to(fanoutExchange()).with(&amp;quot;sms&amp;quot;);
    }
    @Bean
    public Binding duanxinBingding(){
        return BindingBuilder.bin(duanxinQueue()).to(fanoutExchange()).with(&amp;quot;duanxin&amp;quot;);
    }
    @Bean
    public Binding emailBingding(){
        return BindingBuilder.bin(emailQueue()).to(fanoutExchange()).with(&amp;quot;email&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-topic-模式&#34;&gt;3. Topic 模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;生产者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderService{
    @Autowired
    private RabbitTemplate rabbitTemplate;
    //模拟用户下单
    public void makeOrder(String userid,String productid,int num){
        //1.根据商品id查询库存是否足够
        //2.保存订单
        String orderId = UUID.randomUUID().toString();
        sout(&amp;quot;订单生产成功：&amp;quot;+orderId);
        //3.通过MQ来完成消息的分发
        //参数1：交换机 参数2：路由key/queue队列名称 参数3：消息内容
        String exchangeName = &amp;quot;direct_order_exchange&amp;quot;;
        String routingKey = &amp;quot;com.duanxin&amp;quot;;
        rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;消费者（采用注解）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;FanoutSmsConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(bindings = @QueueBinding(
    value = @Queue(value = &amp;quot;sms.topic.queue&amp;quot;,durable = &amp;quot;true&amp;quot;,antoDelete = &amp;quot;false&amp;quot;),
    exchange = @Exchange(value = &amp;quot;topic_order_exchange&amp;quot;,type = &amp;quot;ExchangeTypes.TOPIC&amp;quot;)
    key = &amp;quot;#.sms.#&amp;quot;
))
public class TopicSmsConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;sms接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FanoutDuanxinConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(bindings = @QueueBinding(
    value = @Queue(value = &amp;quot;duanxin.topic.queue&amp;quot;,durable = &amp;quot;true&amp;quot;,antoDelete = &amp;quot;false&amp;quot;),
    exchange = @Exchange(value = &amp;quot;topic_order_exchange&amp;quot;,type = &amp;quot;ExchangeTypes.TOPIC&amp;quot;)
    key = &amp;quot;#.duanxin.#&amp;quot;
))
public classTopicDuanxinConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;duanxin接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FanoutEmailConsumer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@RabbitListener(bindings = @QueueBinding(
    value = @Queue(value = &amp;quot;email.topic.queue&amp;quot;,durable = &amp;quot;true&amp;quot;,antoDelete = &amp;quot;false&amp;quot;),
    exchange = @Exchange(value = &amp;quot;topic_order_exchange&amp;quot;,type = &amp;quot;ExchangeTypes.TOPIC&amp;quot;)
    key = &amp;quot;#.email.#&amp;quot;
))
public class TopicEmailConsumer{
    @RabbitHandler
    public void reviceMessage(String message){
        sout(&amp;quot;email接收到了的订单信息是：&amp;quot;+message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-rabbitmq高级&#34;&gt;五、RabbitMQ高级&lt;/h1&gt;
&lt;p&gt;##1.  过期时间TTL&lt;/p&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1dX4y1V73G?p=44&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过期时间 TTl表示可以对消息设置预期的时间，在这个时间内都可以被消费者接收获取；过了之后消息将自动被删除。RabbitMQ可以对消息和队列设置 TTL，目前有两种方法可以设置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间&lt;/li&gt;
&lt;li&gt;第二种方法是对消息进行单独设置，每条消息 TTL可以不同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上述两种方法同时使用，则消息的过期时间以两者 TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的 TTL值，就称为 dead message被投递到死信队列，消费者将无法再收到该消息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置队列TTL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;RabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class TTLRabbitMQConfiguration{
    //1.声明注册direct模式的交换机
    @Bean
    public DirectExchange ttldirectExchange(){
        return new DirectExchange(&amp;quot;ttl_direct_exchange&amp;quot;,true,false);}
    //2.队列的过期时间
    @Bean
    public Queue directttlQueue(){
        //设置过期时间
        Map&amp;lt;String,Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;();
        args.put(&amp;quot;x-message-ttl&amp;quot;,5000);//这里一定是int类型
        return new Queue(&amp;quot;ttl.direct.queue&amp;quot;,true,false,false,args);}

    @Bean
    public Binding ttlBingding(){
        return BindingBuilder.bin(directttlQueue()).to(ttldirectExchange()).with(&amp;quot;ttl&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;设置消息TTL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderService{
    @Autowired
    private RabbitTemplate rabbitTemplate;
    //模拟用户下单
    public void makeOrder(String userid,String productid,int num){
        //1.根据商品id查询库存是否足够
        //2.保存订单
        String orderId = UUID.randomUUID().toString();
        sout(&amp;quot;订单生产成功：&amp;quot;+orderId);
        //3.通过MQ来完成消息的分发
        //参数1：交换机 参数2：路由key/queue队列名称 参数3：消息内容
        String exchangeName = &amp;quot;ttl_order_exchange&amp;quot;;
        String routingKey = &amp;quot;ttlmessage&amp;quot;;
        //给消息设置过期时间
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor(){
            public Message postProcessMessage(Message message){
                //这里就是字符串
                message.getMessageProperties().setExpiration(&amp;quot;5000&amp;quot;);
                message.getMessageProperties().setContentEncoding(&amp;quot;UTF-8&amp;quot;);
                return message;
            }
        }
        rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId,messagePostProcessor);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class TTLRabbitMQConfiguration{
    //1.声明注册direct模式的交换机
    @Bean
    public DirectExchange ttldirectExchange(){
        return new DirectExchange(&amp;quot;ttl_direct_exchange&amp;quot;,true,false);}
    //2.队列的过期时间
    @Bean
    public Queue directttlQueue(){
        //设置过期时间
        Map&amp;lt;String,Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;();
        args.put(&amp;quot;x-message-ttl&amp;quot;,5000);//这里一定是int类型
        return new Queue(&amp;quot;ttl.direct.queue&amp;quot;,true,false,false,args);}
    @Bean
    public Queue directttlMessageQueue(){
        return new Queue(&amp;quot;ttlMessage.direct.queue&amp;quot;,true,false,false,args);}

    @Bean
    public Binding ttlBingding(){
        return BindingBuilder.bin(directttlMessageQueue()).to(ttldirectExchange()).with(&amp;quot;ttlmessage&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-死信队列&#34;&gt;2. 死信队列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DLX，全称 &lt;code&gt;Dead-Letter-Exchange&lt;/code&gt;，可以称之为死信交换机，也有人称之为死信邮箱。当消息再一个队列中变成死信之后，它能被重新发送到另一个交换机中，这个交换机就是 DLX，绑定 DLX的队列就称之为死信队列。消息变成死信，可能是由于以下原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息被拒绝&lt;/li&gt;
&lt;li&gt;消息过期&lt;/li&gt;
&lt;li&gt;队列达到最大长度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性，当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的 DLX上去，进而被路由到另一个队列，即死信队列。&lt;/p&gt;
&lt;p&gt;要想使用死信队列，只需要在定义队列的时候设置队列参数&lt;code&gt;x-dead-letter-exchange&lt;/code&gt;指定交换机即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DeadRabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class DeadRabbitMqConfiguration{
    //1.声明注册direct模式的交换机
    @Bean
    public DirectExchange deadDirect(){
        return new DirectExchange(&amp;quot;dead_direct_exchange&amp;quot;,true,false);}
    //2.队列的过期时间
    @Bean
    public Queue deadQueue(){
        return new Queue(&amp;quot;dead.direct.queue&amp;quot;,true);}
    @Bean
    public Binding deadbinds(){
        return BindingBuilder.bind(deadDirect()).to(deadQueue()).with(&amp;quot;dead&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;RabbitMqConfiguration.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class TTLRabbitMQConfiguration{
    //1.声明注册direct模式的交换机
    @Bean
    public DirectExchange ttldirectExchange(){
        return new DirectExchange(&amp;quot;ttl_direct_exchange&amp;quot;,true,false);}
    //2.队列的过期时间
    @Bean
    public Queue directttlQueue(){
        //设置过期时间
        Map&amp;lt;String,Object&amp;gt; args = new HashMap&amp;lt;&amp;gt;();
        //args.put(&amp;quot;x-max-length&amp;quot;,5);
        args.put(&amp;quot;x-message-ttl&amp;quot;,5000);//这里一定是int类型
        args.put(&amp;quot;x-dead-letter-exchange&amp;quot;,&amp;quot;dead_direct_exchange&amp;quot;);
        args.put(&amp;quot;x-dead-letter-routing-key&amp;quot;,&amp;quot;dead&amp;quot;);//fanout不需要配置
        return new Queue(&amp;quot;ttl.direct.queue&amp;quot;,true,false,false,args);}
    @Bean
    public Queue directttlMessageQueue(){
        return new Queue(&amp;quot;ttlMessage.direct.queue&amp;quot;,true,false,false,args);}

    @Bean
    public Binding ttlBingding(){
        return BindingBuilder.bin(directttlMessageQueue()).to(ttldirectExchange()).with(&amp;quot;ttlmessage&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C73.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-内存磁盘的监控&#34;&gt;3. 内存磁盘的监控&lt;/h2&gt;
&lt;h3 id=&#34;01-rabbitmq内存警告&#34;&gt;01 RabbitMQ内存警告&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C74.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;02-rabbitmq的内存控制&#34;&gt;02 RabbitMQ的内存控制&lt;/h3&gt;
&lt;p&gt;参考帮助文档：&lt;code&gt;http://www.rabbbitmq.com/configure.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当出现警告的时候，可以通过配置去修改和调整&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令的方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rabbitmqctl set_vm_memory_high_watermark &amp;lt;fraction&amp;gt;
rabbitmqctl set_vm_memory_high_watermark absolute 50MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fraction/value 为内存阈值。默认情况是：0.4/2GB，代表的含义是：当 RabbitMQ的内存超过40%时，就会产生警告并且会阻塞所有生产者的连接。通过此命令修改阈值在 Broker重启以后将会失效，通过修改配置文件设置的阈值则不会随着重启而消失，但修改了配置文件一样要重启 Broker才会生效&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C75.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;配置文件方式 rabbitmq.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C76.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;03-rabbitmq的内存换页&#34;&gt;03 RabbitMQ的内存换页&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C77.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;04-rabbitmq的磁盘预警&#34;&gt;04 RabbitMQ的磁盘预警&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C78.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-集群&#34;&gt;4.  集群&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C79.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;01-集群搭建&#34;&gt;01 集群搭建&lt;/h3&gt;
&lt;p&gt;配置的前提是你的 rabbitmq可以运行起来，比如&lt;code&gt;ps aix|grep rebbitmq&lt;/code&gt;你能看到相关进程，又比如运行&lt;code&gt;rabbitmqct status&lt;/code&gt;你可以看到类似如下信息而不报错：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C80.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;02-单机多实例搭建&#34;&gt;02 单机多实例搭建&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C81.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;启动第二个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C82.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;验证启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ps aux|grep rabbitmq
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;rabbit-1操作作为主节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C83.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;rabbit-2操作作为从节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C84.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;验证集群状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C85.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Web监控&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C86.jpg&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-分布式事务&#34;&gt;5. 分布式事务&lt;/h2&gt;
&lt;h3 id=&#34;01-简述&#34;&gt;01 简述&lt;/h3&gt;
&lt;p&gt;分布式事务指事务的操作位于不同的节点上，需要保证事务的ACID特性。&lt;/p&gt;
&lt;p&gt;例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务&lt;/p&gt;
&lt;h3 id=&#34;02-分布式事务方式&#34;&gt;02 分布式事务方式&lt;/h3&gt;
&lt;p&gt;在分布式系统中，要实现分布式事务，无外乎哪几种解决方案。&lt;/p&gt;
&lt;p&gt;####①两阶段提交（2PC）需要数据库严商&lt;/p&gt;
&lt;p&gt;两阶段提交（Two-phase Commit，2PC），通过引协调者（coordinator）来协调参与者的行为，并最终决定这些参与者是否真正要执行事务。&lt;/p&gt;
&lt;h5 id=&#34;准备阶段&#34;&gt;准备阶段&lt;/h5&gt;
&lt;p&gt;协调者询问参与事务是否执行成功，参与者发回事务执行结果&lt;/p&gt;
&lt;p&gt;#####提交阶段&lt;br&gt;
如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务;否则，协调者发送通知让参与者回滚事务。&lt;br&gt;
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。&lt;/p&gt;
&lt;h5 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;同步阻塞所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。&lt;/li&gt;
&lt;li&gt;单点问题协调者在2PC中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会—直等待状态，无法完成其它操作。&lt;/li&gt;
&lt;li&gt;数据不一致在阶段二，如果协调者只发送了部分Commit 消息，此时网络发生异常，那么只有部分参与者接收到Commit消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。&lt;/li&gt;
&lt;li&gt;太过保守任意一个节点失败就会导致整个事务失败，没有完善的容错机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####②补偿事务（TCC）严选，阿里、蚂蚁金服&lt;/p&gt;
&lt;p&gt;TCC 其实就是采用的补偿机制，其核心思想是:针对每个操作，都要注册一个与其对应的确认和补偿（撒销）操作。它分为三个阶段:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try阶段主要是对业务系统做检测及资源预留&lt;/li&gt;
&lt;li&gt;Confirm阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认---Confirm阶段是不会出错的。即:只要Try成功,Confirm一定成功。&lt;/li&gt;
&lt;li&gt;Cancel阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子，假入Bob要向Smith转账，思路大概是:我们有一个本地方法，里面依次调用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在Try阶段，要先调用远程接口把Smith 和 Bob 的钱给冻结起来。&lt;/li&gt;
&lt;li&gt;在 Confirm阶段，执行远程调用的转账的操作，转账成功进行解冻。&lt;/li&gt;
&lt;li&gt;如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法(Cancel)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点:跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些&lt;br&gt;
缺点:缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。&lt;/p&gt;
&lt;p&gt;####③本地消息（异步确保）比如：支付宝、微信支付主动查询支付状态，对账单的形式&lt;/p&gt;
&lt;p&gt;本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终—致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。&lt;/li&gt;
&lt;li&gt;之后将本地消息表中的消息转发到Kafka等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。&lt;/li&gt;
&lt;li&gt;在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C90.jpg&#34; alt=&#34;image-20210501231747242&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;优点：一种非常经典的实现，避免了分布式事务，实现了最终—致性。&lt;br&gt;
缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####④MQ事务消息，异步场景，通用性较强，拓展性较高。&lt;/p&gt;
&lt;p&gt;有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如Kafka不支持。&lt;br&gt;
以阿里的RabbitMQ中间件为例，其思路大致为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段Prepared消息，会拿到消息的地址。第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。&lt;br&gt;
也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了，RabbitMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RabbitMQ会根据发送端设置的第略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C91.jpg&#34; alt=&#34;image-20210501232113553&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点：实现了最终一致性，不需要依赖本地数据库事务。&lt;br&gt;
缺点：实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。&lt;/p&gt;
&lt;h4 id=&#34;5总结&#34;&gt;⑤总结&lt;/h4&gt;
&lt;p&gt;通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。阿里RocketMQ去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如LCN等，大家可以多去尝试。&lt;/p&gt;
&lt;h3 id=&#34;具体实现&#34;&gt;具体实现&lt;/h3&gt;
&lt;p&gt;分布式事务的完整架构图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C92.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C93.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;####①系统与系统之间的分布式事问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C94.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;####②系统间调用过程中事务回滚问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.xuexiangban .rabbitmq.service;2.
import com.xuexiangban.rabbitmq.dao.orderDataBaseService;
import com.xuexiangban.rabbitmq.pojo.Order;
import org.springframework.beans.factory .annotation.Autowired;
import org.springframework.http.client.SimpleclientHttpRequestFactory;
import org.springframework.stereotype. Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

public class OrderService {
    @Autowired
    private OrderDataBaseService orderDataBaseservice;
    //创建订单
    @Transactional(rollbackFor = Exception.class)//订单创建整个方法添加事务
    public void createOrder(Order orderInfo) throws Exception {
        // 1:订单信息--插入丁订单系统，订单数据库事务orderDataBaseService.saveOrder(orderInfo);
        //2∶通通Http接口发途订单信息到运单系统
        String result = dispatchHttpApi(orderInfo.getorderId());
            if( !&amp;quot;success&amp;quot;.equals(result)) {
            throw new Exception(&amp;quot;订单创建失败,原因是运单接口调用失败!&amp;quot;);
        }
    }
    /**
    * 模拟http请求接口发途，运单系统，将订单号传过去 springcloud
    */
    private String dispatchHttpApi(String orderId){
        SimpleclientHttpRehyuestFactory factory - new SimpleClientHttpRequestFactory();
                //链接超时&amp;gt;3秒
        factory .setConnectTimeout ( 300e) ;
        //处理超时&amp;gt;2秒
         factory .setReadTimeout ( 2000) ;
                //发送http请求
        String url = &amp;quot;http: / /localhost:9000/dispatch/order?orderId=&amp;quot;+orderId;
                RestTemplate restTemplate = new RestTemplate(factory);//异常
        String result = restTemplate.getForobject(url，string.class);
                return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####③基于MQ的分布式事务整体设计思路&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;E:%5Cnote%5C5-%E4%B8%AD%E9%97%B4%E4%BB%B6%5CRabbitMQ%5Cimage%5C95.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;####④基于MQ的分布式事务消息的可靠生产问题-定时重发&lt;/p&gt;
&lt;p&gt;如果这个时候MQ服务器出现了异常和故障，那么消息是无法获取到回执信息。怎么解决呢?&lt;/p&gt;
&lt;p&gt;####⑤基于MQ的分布式事务消息的可靠消费&lt;/p&gt;
&lt;p&gt;####⑥基于MQ的分布式事务消息的消息重发&lt;/p&gt;
&lt;p&gt;解决消息重试的集中方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制重发的次数&lt;/li&gt;
&lt;li&gt;try+catch+手动ack&lt;/li&gt;
&lt;li&gt;try+catch+手动ack +死信队列处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####⑦基于MQ的分布式事务消息的死信队列消息转移+人工处理&lt;/p&gt;
&lt;p&gt;如果死信队列报错就进行人工处理&lt;/p&gt;
&lt;p&gt;####⑧基于MQ的分布式事务消息的死信队列消息重试注意事项&lt;/p&gt;
&lt;p&gt;####⑨基于MQ的分布式事务消息的定式重发&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;####①基于MQ的分布式事务解决方案优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通用性强&lt;/li&gt;
&lt;li&gt;拓展方便&lt;/li&gt;
&lt;li&gt;耦合度低,方案也比较成熟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####②基于MQ的分布式事务解决方案缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于消息中间件,只适合异步场景&lt;/li&gt;
&lt;li&gt;消息会延迟处理，需要业务上能够容忍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####③建议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽量去避免分布式事务&lt;/li&gt;
&lt;li&gt;尽量将非核心业务做成异步&lt;/li&gt;
&lt;/ol&gt;
">RabbitMq</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/redis/"" data-c="
          &lt;h2 id=&#34;介绍一下-redis&#34;&gt;介绍⼀下 Redis&lt;/h2&gt;
&lt;p&gt;简单来说 &lt;strong&gt;Redis 就是⼀个使⽤ C 语⾔开发的数据库&lt;/strong&gt;，不过与传统数据库不同的是 &lt;strong&gt;Redis 的数据&lt;/strong&gt;是存在内存中的 ，也就是它是内存数据库，所以读写速度⾮常快，因此 Redis 被⼴泛应⽤于缓存⽅向。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;Redis 除了做缓存之外，Redis 也经常⽤来做分布式锁，甚⾄是消息队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis 提供了多种数据类型来⽀持不同的业务场景。Redis 还⽀持事务 、持久化、Lua 脚本、多种集群⽅案。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;分布式缓存常的技术选型方案有哪些&#34;&gt;分布式缓存常⻅的技术选型⽅案有哪些？&lt;/h2&gt;
&lt;p&gt;分布式缓存的话，使⽤的比较多的主要是 Memcached 和 Redis。不过，现在基本没有看过还有项⽬使⽤ Memcached 来做缓存，都是直接⽤ Redis。&lt;/p&gt;
&lt;p&gt;Memcached 是分布式缓存最开始兴起的那会，比较常⽤的。后来，随着 Redis 的发展，⼤家慢慢都转⽽使⽤更加强⼤的 Redis 了。&lt;/p&gt;
&lt;p&gt;分布式缓存主要解决的是单机缓存的容量受服务器限制并且⽆法保存通⽤的信息。因为，本地缓存只在当前服务⾥有效，⽐如你部署了两个相同的服务，他们两者之间的缓存数据是⽆法共同的。&lt;/p&gt;
&lt;h2 id=&#34;说一下-redis-和-memcached-的区别和共同点&#34;&gt;说⼀下 Redis 和 Memcached 的区别和共同点&lt;/h2&gt;
&lt;p&gt;现在公司⼀般都是⽤ Redis 来实现缓存，⽽且 Redis ⾃身也越来越强⼤了！不过，了解 Redis 和&lt;br&gt;
Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！&lt;br&gt;
&lt;strong&gt;共同点 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都是基于内存的数据库，⼀般都⽤来当做缓存使⽤。&lt;/li&gt;
&lt;li&gt;都有过期策略。&lt;/li&gt;
&lt;li&gt;两者的性能都⾮常⾼。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;区别 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis ⽀持更丰富的数据类型（&lt;strong&gt;⽀持更复杂的应⽤场景&lt;/strong&gt;）。Redis 不仅仅⽀持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只⽀持最简单的 k/v 数据类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis ⽀持数据的持久化&lt;/strong&gt;，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进⾏使⽤,⽽ Memecache 把数据全部存在内存之中。&lt;/li&gt;
&lt;li&gt;Redis &lt;strong&gt;有灾难恢复机制&lt;/strong&gt;。 因为可以把缓存中的数据持久化到磁盘上。&lt;/li&gt;
&lt;li&gt;Redis 在服务器内存使⽤完之后，可以将不⽤的数据放到磁盘上。但是，Memcached 在服务器内存使⽤完之后，就会直接报异常。&lt;/li&gt;
&lt;li&gt;Memcached 没有原⽣的集群模式，需要依靠客户端来实现往集群中分⽚写⼊数据；但是Redis ⽬前是&lt;strong&gt;原⽣⽀持 cluster 模式&lt;/strong&gt;的.&lt;/li&gt;
&lt;li&gt;Memcached 是&lt;strong&gt;多线程，⾮阻塞 IO 复⽤的⽹络模型&lt;/strong&gt;；Redis 使⽤&lt;strong&gt;单线程的多路 IO 复⽤模型&lt;/strong&gt;。 （Redis 6.0 引⼊了多线程 IO ）&lt;/li&gt;
&lt;li&gt;Redis &lt;strong&gt;⽀持发布订阅模型、Lua 脚本、事务&lt;/strong&gt;等功能，⽽ Memcached 不⽀持。并且，Redis⽀持更多的编程语⾔。&lt;/li&gt;
&lt;li&gt;Memcached过期数据的删除策略只⽤了惰性删除，⽽ Redis 同时使⽤了&lt;strong&gt;惰性删除与定期删除&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;更推荐Redis作为分布式的缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存数据的处理流程是怎样的&#34;&gt;缓存数据的处理流程是怎样的？&lt;/h2&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果⽤户请求的数据在缓存中就直接返回。&lt;/li&gt;
&lt;li&gt;缓存中不存在的话就看数据库中是否存在。&lt;/li&gt;
&lt;li&gt;数据库中存在的话就更新缓存中的数据。&lt;/li&gt;
&lt;li&gt;数据库中不存在的话就返回空数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111116721.png&#34; alt=&#34;image-20230203111116721&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;为什么要用-redis为什么要用缓存&#34;&gt;为什么要⽤ Redis/为什么要⽤缓存？&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111135947.png&#34; alt=&#34;image-20230203111135947&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;针对高性能和高并发出发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⾼性能 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如⽤户第⼀次访问数据库中的某些数据的话，这个过程是⽐᫾慢，毕竟是从硬盘中读取的。但是，如果说，⽤户访问的数据属于⾼频数据并且不会经常改变的话，那么我们就可以很放⼼地将该⽤户访问的数据存在缓存中。&lt;strong&gt;这样有什么好处&lt;/strong&gt;呢？ 那就是保证⽤户下⼀次再访问这些数据的时候就可以直接从缓存中获取了。&lt;/p&gt;
&lt;p&gt;操作缓存就是&lt;strong&gt;直接操作内存，所以速度相当快&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，要保持数据库和缓存中的数据的⼀致性。 如果数据库中的对应数据改变的之后，&lt;strong&gt;同步改变缓存中相应的数据即可&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⾼并发：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⼀般像 MySQL 这类的数据库的 QPS ⼤概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后很容易达到 10w+，甚⾄最⾼能达到 30w+（就单机 redis 的情况，redis 集群的话会更⾼）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS（Query Per Second）：服务器每秒可以执⾏的查询次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，直接操作缓存能够承受的数据库请求数量是远远⼤于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据库进⽽我们也就提⾼的系统整体的&lt;/p&gt;
&lt;h2 id=&#34;io模型&#34;&gt;IO模型&lt;/h2&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/115912936&lt;/p&gt;
&lt;h2 id=&#34;io多路复用机制&#34;&gt;IO多路复用机制&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/sehanlingfeng/article/details/78920423&lt;/p&gt;
&lt;h2 id=&#34;bionioaio-有什么区别&#34;&gt;&lt;strong&gt;BIO,NIO,AIO 有什么区别?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BIO (Blocking I/O): 同步阻塞 I/O 模式&lt;/strong&gt;，&lt;strong&gt;数据的读取写⼊必须阻塞在⼀个线程内等待其完成&lt;/strong&gt;。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是比较不错的，可以让每⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。线程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当⾯对⼗万甚⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼效的 I/O 处理模型来应对更⾼的并发量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO (Non-blocking/New I/O): NIO 是⼀种同步⾮阻塞的 I/O 模型&lt;/strong&gt;，在 Java 1.4 中引⼊了NIO 框架，对应 java.nio 包，提供了 &lt;strong&gt;Channel&lt;/strong&gt; , &lt;strong&gt;Selector&lt;/strong&gt;，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持&lt;strong&gt;⾯向缓冲&lt;/strong&gt;的，基于通道的 I/O 操作⽅法。&lt;/p&gt;
&lt;p&gt;NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模式。阻塞模式使⽤就像传统中的⽀持⼀样，比较简单，但是性能和可靠性都不好；⾮阻塞模式正好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更好的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AIO (Asynchronous I/O): AIO 也就是 NIO 2&lt;/strong&gt;。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是&lt;strong&gt;异步⾮阻塞的 IO 模型&lt;/strong&gt;。异步 IO 是&lt;strong&gt;基于事件和回调机制实现&lt;/strong&gt;的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。&lt;br&gt;
AIO 是异步 IO 的缩写，&lt;strong&gt;虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏为还是同步的&lt;/strong&gt;。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程⾃⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO与BIO区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通讯方式：NIO 通过&lt;strong&gt;Channel（通道）&lt;/strong&gt; 进行读写，通道是&lt;strong&gt;双向&lt;/strong&gt;的，可读也可写。而BIO使用的&lt;strong&gt;流读写是单向&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;BIO流是阻塞的，NIO流是不阻塞的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BIO 面向流(Stream oriented)&lt;/strong&gt;，&lt;strong&gt;而 NIO 面向缓冲区(Buffer oriented)&lt;/strong&gt;。
&lt;ol&gt;
&lt;li&gt;在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。&lt;strong&gt;虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区&lt;/strong&gt;，而 NIO 却是&lt;strong&gt;直接读到 Buffer 中进行操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。&lt;strong&gt;任何时候访问NIO中的数据，都是通过缓冲区进行操作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO 带来了什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;避免多线程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞I/O，I/O读写不再阻塞，而是返回0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;单线程处理多任务&lt;/li&gt;
&lt;li&gt;基于block的传输，通常比基于流的传输更高效&lt;/li&gt;
&lt;li&gt;更高级的IO函数，zero-copy&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件驱动模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO多路复用大大提高了Java网络应用的可伸缩性和实用性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-常数据结构以及使用场景分析&#34;&gt;Redis 常⻅数据结构以及使⽤场景分析&lt;/h2&gt;
&lt;h3 id=&#34;string&#34;&gt;&lt;strong&gt;String&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	1.&lt;strong&gt;介绍&lt;/strong&gt; ：string 数据结构是简单的 key-value 类型。虽然 Redis 是⽤ C 语⾔写的，但是 Redis并没有使⽤ C 的字符串表示，⽽是⾃⼰构建了⼀种 简单动态字符串（simple dynamicstring，SDS）。相⽐于 C 的原⽣字符串，Redis 的 SDS 不光可以保存⽂本数据还可以保存&lt;br&gt;
⼆进制数据，并且获取字符串⻓度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的SDS API 是安全的，不会造成缓冲区溢出。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;常⽤命令&lt;/strong&gt;: set,get,strlen,exists,dect,incr,setex 等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应⽤场景&lt;/strong&gt; ：⼀般常⽤在需要&lt;strong&gt;计数的场景&lt;/strong&gt;，⽐如⽤户的访问次数、热点⽂章的点赞转发数量等，共享用户session。&lt;br&gt;
等。&lt;/li&gt;
&lt;li&gt;.redis 的 string 类型存储的限制为&lt;strong&gt;512M&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;list&#34;&gt;list&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ：list 即是 链表。链表是⼀种⾮常常⻅的数据结构，特点是易于数据元素的插⼊和删除并且且可以灵活调整链表⻓度，但是链表的随机访问困难。许多⾼级编程语⾔都内置了链表的实现⽐如 Java 中的 &lt;strong&gt;LinkedList&lt;/strong&gt;，但是 C 语⾔并没有实现链表，所以 Redis 实现了⾃⼰的链表数据结构。Redis 的 list 的实现为⼀个 &lt;strong&gt;双向链表&lt;/strong&gt;，即可以⽀持&lt;strong&gt;反向查找和遍历&lt;/strong&gt;，更⽅便操作，不过带来了部分额外的内存开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常⽤命令&lt;/strong&gt;: rpush,lpop,lpush,rpop,lrange.llen 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应⽤场景&lt;/strong&gt;: &lt;strong&gt;发布与订阅或者说消息队列、慢查询&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hash&#34;&gt;hash&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，&lt;strong&gt;hash 是⼀个 string 类型的 field 和 value 的映射表，特别适合⽤于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。&lt;/strong&gt; ⽐如我们可以 hash 数据结构来存储&lt;strong&gt;⽤户信息，商品信息&lt;/strong&gt;等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常⽤命令&lt;/strong&gt;： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应⽤场景:&lt;/strong&gt; 系统中对象数据的存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;set&#34;&gt;set&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是⼀种⽆序集合，集合中的元素没有先后顺序。当你需要存储⼀个列表数据，⼜不希望出现重复数据时，set 是⼀个很好的选择，并且 set 提供了判断某个成员是否在⼀个 set 集合内的重要接⼝，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。&lt;/li&gt;
&lt;li&gt;⽐如：你可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。Redis 可以⾮常⽅便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常⽤命令&lt;/strong&gt;： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。&lt;br&gt;
3. &lt;strong&gt;应⽤场景:&lt;/strong&gt; 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景 例如：在微博应⽤中，可以将⼀个⽤户所有的关注⼈存在⼀个集合中，将其所有粉丝存在⼀个集合。Redis可以⾮常⽅便的实现如&lt;strong&gt;共同关注、共同粉丝、共同喜好&lt;/strong&gt;等功能。这个过程也就是求交集的过程，&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sorted-set&#34;&gt;sorted set&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt;： 和 set 相⽐，sorted set 增加了⼀个权重参数 score，使得集合中的元素能够按 score进⾏有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap和 TreeSet 的结合体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常⽤命令&lt;/strong&gt;： zadd,zcard,zscore,zrange,zrevrange,zrem 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应⽤场景：&lt;/strong&gt; 需要对数据根据某个权重进⾏排序的场景，比如微博热搜，做带权重的队列⽐如在直播系统中，实时排⾏信息包含直播间&lt;strong&gt;在线⽤户列表，各种礼物排⾏榜，弹幕消息&lt;/strong&gt;（可以理解为按消息维度的消息排⾏榜）等信息 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis线程&#34;&gt;Redis线程&lt;/h2&gt;
&lt;h3 id=&#34;redis单线程原理&#34;&gt;Redis单线程原理&lt;/h3&gt;
&lt;p&gt;首先必须明确，Redis单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。原理上，其采用了利用epoll的多路复用特性，因此可以采用单线程处理其网络请求。&lt;/p&gt;
&lt;h3 id=&#34;redis-单线程模型详解&#34;&gt;Redis 单线程模型详解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Redis 基于 Reactor 模式来设计开发了⾃⼰的⼀套⾼效的事件处理模型&lt;/strong&gt; （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是⾼性能 IO 的基⽯），这套事件处理模型对应的是 Redis中的&lt;strong&gt;⽂件事件处理器&lt;/strong&gt;（file event handler）。由于⽂件事件处理器（file event handler）是单线程⽅式运⾏的，所以我们⼀般都说 Redis 是单线程模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既然是单线程，那怎么监听⼤量的客户端连接呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 通过&lt;strong&gt;IO 多路复⽤程序&lt;/strong&gt; 来监听来⾃客户端的⼤量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发⽣。&lt;/p&gt;
&lt;p&gt;这样的好处⾮常明显： &lt;strong&gt;I/O 多路复⽤技术的使⽤让 Redis 不需要额外创建多余的线程来监听客户端的⼤量连接，降低了资源的消耗&lt;/strong&gt;（和 NIO 中的 Selector 组件很像）。&lt;/p&gt;
&lt;p&gt;另外， Redis 服务器是⼀个事件驱动程序，服务器需要处理两类事件： 1. ⽂件事件; 2. 时间事件。&lt;/p&gt;
&lt;p&gt;时间事件不需要多花时间了解，我们接触最多的还是 ⽂件事件（&lt;strong&gt;客户端进⾏读取写⼊等操作，涉及⼀系列⽹络通信&lt;/strong&gt;）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Redis 基于 Reactor 模式开发了⾃⼰的⽹络事件处理器：这个处理器被称为⽂件事件处理器（file event handler）。⽂件事件处理器使⽤ I/O 多路复⽤（multiplexing）程序来同时监听多个套接字，并根据 套接字⽬前执⾏的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执⾏连接应答（accept）、读取（read）、写⼊（write）、关 闭（close）等操作时，与操作相对应的⽂件事件就会产⽣，这时⽂件事件处理器就会调⽤套接字之前关联好的事件处理器来处理这些事件。虽然⽂件事件处理器以单线程⽅式运⾏，但通过使⽤ I/O 多路复⽤程序来监听多个套接字，⽂件事件处理器既实现了⾼性能的⽹络通信模型，⼜可以很好地与 Redis 服务器中其他同样以单线程⽅式运⾏的模块进⾏对接，这保持了 Redis 内部单线程设计的简单性。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，⽂件事件处理器（file event handler）主要是包含 4 个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多个 socket（客户端连接）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IO 多路复⽤程序（⽀持多个客户端连接的关键）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽂件事件分派器（将 socket 关联到相应的事件处理器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111214293.png&#34; alt=&#34;image-20230203111214293&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis-没有使用多线程为什么不使用多线程&#34;&gt;Redis 没有使⽤多线程？为什么不使⽤多线程&lt;/h3&gt;
&lt;p&gt;虽然说 Redis 是单线程模型，但是， 实际上，Redis 在 4.0 之后的版本中就已经加⼊了对多线程的支持&lt;/p&gt;
&lt;p&gt;不过，Redis 4.0 增加的多线程主要是针对⼀些⼤键值对的删除操作的命令，使⽤这些命令就会使⽤主处理之外的其他线程来“异步处理”。&lt;br&gt;
⼤体上来说，Redis 6.0 之前主要还是**单线程处理。**那，Redis6.0 之前 为什么不使⽤多线程？&lt;br&gt;
主要原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单线程编程容易并且更&lt;strong&gt;容易维护&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Redis的性能瓶颈不在 &lt;strong&gt;CPU&lt;/strong&gt; ，主要在&lt;strong&gt;内存和⽹络&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;多线程就会存在&lt;strong&gt;死锁、线程上下⽂切换&lt;/strong&gt;等问题，甚⾄&lt;strong&gt;会影响性能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redis60-之后为何引入了多线程&#34;&gt;Redis6.0 之后为何引⼊了多线程？&lt;/h3&gt;
&lt;p&gt;Redis6.0 引⼊多线程主要是为了提⾼⽹络 IO 读写性能，因为这个算是 Redis 中的⼀个性能瓶颈（Redis 的瓶颈主要受限于内存和⽹络）。&lt;/p&gt;
&lt;p&gt;虽然，Redis6.0 引⼊了多线程，但是 Redis 的&lt;strong&gt;多线程只是在⽹络数据的读写&lt;/strong&gt;这类耗时操作上使⽤了， &lt;strong&gt;执⾏命令仍然是单线程顺序执⾏&lt;/strong&gt;。因此，你也不需要担⼼线程安全问题。&lt;/p&gt;
&lt;p&gt;Redis6.0 的&lt;strong&gt;多线程默认是禁⽤的&lt;/strong&gt;，只使⽤主线程。如需开启需要修改 &lt;strong&gt;redis&lt;/strong&gt; 配置⽂件 &lt;strong&gt;redis.conf&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111239352.png&#34; alt=&#34;image-20230203111239352&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;开启多线程后还需要设置线程数否则是不⽣效的。同样需要修改 redis 配置⽂件 &lt;strong&gt;redis.conf :&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111247809.png&#34; alt=&#34;image-20230203111247809&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;参考连接：https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw&lt;/p&gt;
&lt;p&gt;​				   https://draveness.me/whys-the-design-redis-single-thread/&lt;/p&gt;
&lt;h2 id=&#34;redis多线程&#34;&gt;Redis多线程&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/lizhengze1117/article/details/108032406&lt;/p&gt;
&lt;h2 id=&#34;什么情况下使用redis&#34;&gt;什么情况下使用redis&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/qq_35190492/article/details/103105780&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对热点数据进行缓存&lt;/li&gt;
&lt;li&gt;对于特定限时数据的存放&lt;/li&gt;
&lt;li&gt;针对带热点权值数据的&lt;a href=&#34;https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&#34;&gt;排序&lt;/a&gt;list&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么要给redis缓存数据设置过期时间&#34;&gt;为什么要给Redis缓存数据设置过期时间&lt;/h2&gt;
&lt;p&gt;因为内存是有限的，如果缓存中的所有数据都是⼀直保存的话，分分钟直接**Out of memory。**Redis ⾃带了给缓存数据设置过期时间的功能，⽐如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111259581.png&#34; alt=&#34;image-20230203111259581&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意：Redis中除了字符串类型有⾃⼰独有设置过期时间的命令 &lt;strong&gt;setex&lt;/strong&gt; 外，其他⽅法都需要依靠&lt;strong&gt;expire&lt;/strong&gt; 命令来设置过期时间 。另外， persist 命令可以移除⼀个键的过期时间&lt;br&gt;
&lt;strong&gt;过期时间除了有助于缓解内存的消耗，还有什么其他⽤么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证码有效时间 token有效时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多时候，我们的业务场景就是需要某个数据只在某⼀时间段内存在，⽐如我们的短信验证码可能只在1分钟内有效，⽤户登录的 token 可能只在 1 天内有效。如果使⽤传统的数据库来处理的话，⼀般都是⾃⼰判断过期，这样更麻烦并且&lt;strong&gt;性能&lt;/strong&gt;要差很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免数据库和缓存的不一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置缓存过期时间当缓存当中的值失效了之后就会到数据库当中去更新数据&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;redis是如何判断数据是否过期&#34;&gt;Redis是如何判断数据是否过期&lt;/h2&gt;
&lt;p&gt;Redis 通过⼀个叫做&lt;strong&gt;过期字典&lt;/strong&gt;（可以看作是hash表）来保存数据过期的时间。过期字典的键指向&lt;br&gt;
Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所&lt;br&gt;
指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111310626.png&#34; alt=&#34;image-20230203111310626&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;过期字典&lt;/strong&gt;是存储在redisDb这个结构⾥的：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111320481.png&#34; alt=&#34;image-20230203111320481&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;过期的数据的删除策略&#34;&gt;过期的数据的删除策略&lt;/h2&gt;
&lt;p&gt;如果假设你设置了⼀批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进⾏删除的呢？&lt;br&gt;
常⽤的过期数据的删除策略就两个（重要！⾃⼰造缓存轮⼦的时候需要格外考虑的东⻄）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt; ：只会在取出key的时候才对数据进⾏过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt; ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期key操作。并且，Redis 底层会通过限制删除操作执⾏的时⻓和频率来减少删除操作对CPU时间的影响。&lt;br&gt;
定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采⽤的是 定期删除+惰性/懒汉式删除 。&lt;br&gt;
但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致⼤量过期 key 堆积在内存⾥，然后就Out of memory了。&lt;/p&gt;
&lt;p&gt;怎么解决这个问题呢？答案就是： &lt;strong&gt;Redis 内存淘汰机制。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis-内存淘汰机制&#34;&gt;Redis 内存淘汰机制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;相关问题&lt;/strong&gt;：MySQL ⾥有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis 提供 6 种数据淘汰策略：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选&lt;strong&gt;最近最少使⽤&lt;/strong&gt;的数据淘汰&lt;/li&gt;
&lt;li&gt;volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选&lt;strong&gt;将要过期&lt;/strong&gt;的数据淘汰&lt;/li&gt;
&lt;li&gt;volatile-random：从已设置过期时间的数据集（server.db[i].expires）中&lt;strong&gt;任意选择数据淘汰&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;allkeys-lru（least recently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除&lt;br&gt;
最近最少使⽤的 key（这个是最常⽤的）&lt;/li&gt;
&lt;li&gt;allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/li&gt;
&lt;li&gt;no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。这个应该没⼈使⽤吧！&lt;br&gt;
4.0 版本后增加以下两种：&lt;/li&gt;
&lt;li&gt;volatile-lfu（least frequently used）：&lt;strong&gt;从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使⽤的数据淘汰&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;allkeys-lfu（least frequently used）：&lt;strong&gt;当内存不⾜以容纳新写⼊数据时，在键空间中，移除最不经常使⽤的 key&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis-持久化机制&#34;&gt;Redis 持久化机制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多时候我们需要持久化数据也就是将内存中的数据写⼊到硬盘⾥⾯，⼤部分原因是为了之后重⽤数据（⽐如重启机器、机器故障之后恢复数据），或者是为了防⽌系统故障⽽将数据备份到个远程位置。Redis 不同于 Memcached 的很重要⼀点就是，Redis ⽀持持久化，⽽且⽀持两种不同的持久化操作。Redis 的⼀种持久化⽅式叫快照（snapshotting，&lt;strong&gt;RDB&lt;/strong&gt;），另⼀种⽅式是只追加⽂件append-only file, （&lt;strong&gt;AOF&lt;/strong&gt;）。这两种⽅法各有千秋，下⾯我会详细这两种持久化⽅法是什么，么⽤，如何选择适合⾃⼰的持久化⽅法。&lt;br&gt;
&lt;strong&gt;快照（snapshotting）持久化（RDB)&lt;/strong&gt;&lt;br&gt;
Redis 可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本（&lt;strong&gt;Redis 主从结构，主要⽤来提⾼ Redis 性能&lt;/strong&gt;），还可以将快照留在原地以便重启服务器的时候使⽤。&lt;/p&gt;
&lt;p&gt;快照持久化RDB是 **Redis 默认采⽤的持久化⽅式，**在 Redis.conf 配置⽂件中默认有此下配置：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111331829.png&#34; alt=&#34;image-20230203111331829&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;AOF（append-only file）持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与快照持久化相⽐，AOF 持久化 的&lt;strong&gt;实时性&lt;/strong&gt;更好，因此已成为主流的持久化⽅案。默认情况下Redis 没有开启 AOF（append only file）⽅式的持久化，可以通过 appendonly 参数开启：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111338949.png&#34; alt=&#34;image-20230203111338949&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;开启 AOF 持久化后每执⾏⼀条会更改 Redis 中的数据的命令，Redis 就会将该命令写⼊硬盘中的 AOF ⽂件。AOF ⽂件的保存位置和 RDB ⽂件的位置相同，都是通过 dir 参数设置的，默认的&lt;br&gt;
⽂件名是 **appendonly.aof。**在 Redis 的配置⽂件中存在三种不同的 AOF 持久化⽅式，它们分别是：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111346448.png&#34; alt=&#34;image-20230203111346448&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为了兼顾数据和写⼊性能，⽤户可以考虑 &lt;strong&gt;appendfsync everyse&lt;/strong&gt;c 选项 ，让 Redis 每秒同步⼀次AOF ⽂件，Redis 性能⼏乎没受到任何影响。⽽且这样即使出现系统崩溃，⽤户最多只会丢失⼀秒之内产⽣的数据。当硬盘忙于执⾏写⼊操作的时候，Redis 还会优雅的放慢⾃⼰的速度以便适应硬盘的最⼤写⼊速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充内容：AOF 重写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AOF 重写可以产⽣⼀个新的 AOF ⽂件，这个新的 AOF ⽂件和原有的 AOF ⽂件所保存的数据库状态⼀样，但体积更⼩。&lt;/p&gt;
&lt;p&gt;AOF 重写是⼀个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序⽆须对现有AOF ⽂件进⾏任何读⼊、分析或者写⼊操作。&lt;/p&gt;
&lt;p&gt;在执⾏ BGREWRITEAOF 命令时，Redis 服务器会维护⼀个 AOF 重写缓冲区，该缓冲区会在⼦进程创建新 AOF ⽂件期间，记录服务器执⾏的所有写命令。当⼦进程完成创建新 AOF ⽂件的⼯作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF ⽂件的末尾，使得新旧两个 AOF ⽂件所保存的数据库状态⼀致。最后，服务器⽤新的 AOF ⽂件替换旧的 AOF ⽂件，以此来完成AOF ⽂件重写操作&lt;/p&gt;
&lt;h3 id=&#34;rdb&#34;&gt;RDB&lt;/h3&gt;
&lt;p&gt;RDB即将当前数据生成快照，并保存于硬盘中。可以通过手动命令，也可以设置自动触发。&lt;/p&gt;
&lt;h3 id=&#34;简述redis的aof&#34;&gt;简述Redis的AOF&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;AOF通过日志&lt;/strong&gt;，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF。&lt;/p&gt;
&lt;h3 id=&#34;简述aof的持久化策略&#34;&gt;简述AOF的持久化策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上。&lt;/li&gt;
&lt;li&gt;everysec。每秒将命令写入到磁盘日志文件上。&lt;/li&gt;
&lt;li&gt;no。不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;简述aof的重写&#34;&gt;简述AOF的重写&lt;/h3&gt;
&lt;p&gt;随着&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;不断进行操作，AOF对应的文件也越来越大。&lt;a href=&#34;&#34;&gt;redis&lt;/a&gt;提供了&lt;strong&gt;bgrewriteaof函数&lt;/strong&gt;，针对目前数据库中数据，在不读取原有AOF文件的基础上，重写了一个新的AOF文件，减少文件大小。&lt;/p&gt;
&lt;h3 id=&#34;rdb与aof优缺点比较&#34;&gt;RDB与AOF优缺点比较&lt;/h3&gt;
&lt;p&gt;AOF占用的文件体积比RDB大。一般来说利用AOF备份对系统的消耗比RDB低。对于备份时出现系统故障，RDB数据可能会全丢，但AOF只会损失一部分。RDB恢复速度比AOF低。&lt;/p&gt;
&lt;h3 id=&#34;redis自动触发rdb机制&#34;&gt;Redis自动触发RDB机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;配置文件&lt;/strong&gt;，设置&lt;strong&gt;一定时间后自动执行RDB&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如采用&lt;strong&gt;主从复制过程&lt;/strong&gt;，会&lt;strong&gt;自动执行RDB&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Redis执行shutdown时，在未开启AOF后会执行RDB&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis-事务&#34;&gt;Redis 事务&lt;/h2&gt;
&lt;p&gt;Redis 可以通过 &lt;strong&gt;MULTI，EXEC，DISCARD 和 WATCH&lt;/strong&gt; 等命令来实现事务(transaction)功能。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111358081.png&#34; alt=&#34;image-20230203111358081&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使⽤ &lt;strong&gt;MULTI&lt;/strong&gt;命令后可以输⼊多个命令。Redis不会⽴即执⾏这些命令，⽽是将它们放到队列，当调⽤了&lt;strong&gt;EXEC&lt;/strong&gt;命令将执⾏所有命令。&lt;/p&gt;
&lt;p&gt;但是Redis 的事务和我们平时理解的关系型数据库的事务不同于我们知道事务具有四大特性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis 是不⽀持 roll back 的因⽽不满⾜原⼦性的（⽽且不满⾜持久性）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis官⽹也解释了⾃⼰为啥不⽀持回滚。简单来说就是Redis开发者们觉得没必要⽀持回滚，这样更简单便捷并且性能更好。&lt;strong&gt;Redis开发者觉得即使命令执⾏错误也应该在开发过程中就被发现⽽不是⽣产过程中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以将Redis中的事务就理解为 ：&lt;strong&gt;Redis事务提供了⼀种将多个命令请求打包的功能 ，将这些任务放到队列里面就不会出现被打断的现象 并且任务会按照顺序执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;多数事务失败是由语法错误或者数据结构类型错误导致的，语法错误说明在命令入队前就进行检测的，而类型错误是在执行时检测的，Redis为提升性能而采用这种简单的事务，这是不同于关系型数据库的，特别要注意区分&lt;/p&gt;
&lt;h2 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h2&gt;
&lt;h3 id=&#34;什么是缓存穿透&#34;&gt;什么是缓存穿透&lt;/h3&gt;
&lt;p&gt;缓存穿透说简单点就是⼤量请求的 key 根本&lt;strong&gt;不存在于缓存中&lt;/strong&gt;，导致请求直接到了数据库上，根本没有经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请求落到数据库。&lt;/p&gt;
&lt;h3 id=&#34;缓冲穿透情况的处理流程&#34;&gt;缓冲穿透情况的处理流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;D:%5Cnote%5C%E9%9D%A2%E8%AF%95%5C%E9%9D%A2%E8%AF%95.assets%5Cimage-20230203111412798.png&#34; alt=&#34;image-20230203111412798&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;解决缓存穿透的方法&#34;&gt;解决缓存穿透的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对参数进行校验。错误的参数直接过滤&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存无效key&lt;/strong&gt;，&lt;strong&gt;并设置过期时间&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;缺点：会导致大量的无效缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;：把所有可能存在的请求的值都存放在布隆过滤器中,当用户请求过来,先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话,直接返回请求参数错误信息给客户端,存在的话才会走下面的流程。
&lt;ul&gt;
&lt;li&gt;缺点：可能会导致误判&lt;/li&gt;
&lt;li&gt;布隆过滤器通过哈希函数计算key的哈系值然后获取相应的位置。并把位置的值置为1。由于会存在哈希冲突，所以布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h2&gt;
&lt;h3 id=&#34;什么是缓存雪崩&#34;&gt;什么是缓存雪崩&lt;/h3&gt;
&lt;p&gt;缓存在同⼀时间⼤⾯积的失效，后⾯的请求都直接落到了数据库上，造成数据库短时间内承受⼤量请求。 这就好⽐雪崩⼀样，摧枯拉朽之势数据库的压⼒可想⽽知，可能直接就被这么多请求弄宕机了。&lt;/p&gt;
&lt;p&gt;举个例⼦：系统的缓存模块出了问题⽐如宕机导致不可⽤。造成系统的所有访问，都要⾛数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有⼀种缓存雪崩的场景&lt;/strong&gt;是：有⼀些被⼤量访问数据（热点缓存）在某⼀时刻⼤⾯积失效，导致对应的请求直接落到了数据库上。 这样的情况，有下⾯⼏种解决办法：举个例⼦ ：秒杀开始 12 个⼩时之前，我们统⼀存放了⼀批商品到 Redis 中，设置的缓存过期时间也是 12 个⼩时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩⼀样可怕。&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;加锁：如果缓存失效的话，则对操作进行加锁，然后获取数据。&lt;/li&gt;
&lt;li&gt;Redis集群：使用redis集群并设置不同的失效时间比如随机设置缓存的失效时间。&lt;/li&gt;
&lt;li&gt;随机指数退避算法：如果发现缓存失效，则随机一个很短的时间，并sleep，再次查询，如果失败再执行更新。&lt;/li&gt;
&lt;li&gt;双缓存：我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点：
&lt;ul&gt;
&lt;li&gt;从缓存A读数据，有则直接返回&lt;/li&gt;
&lt;li&gt;A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。&lt;/li&gt;
&lt;li&gt;更新线程同时更新缓存A和缓存B。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。&lt;/li&gt;
&lt;li&gt;解决方案：
&lt;ul&gt;
&lt;li&gt;热点数据设置永不过期&lt;/li&gt;
&lt;li&gt;加锁：如果缓存失效的话，则对操作进行加锁，然后获取数据。&lt;/li&gt;
&lt;li&gt;Redis集群：使用redis集群并设置不同的失效时间比如随机设置缓存的失效时间。&lt;/li&gt;
&lt;li&gt;随机指数退避算法：如果发现缓存失效，则随机一个很短的时间，并sleep，再次查询，如果失败再执行更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何保证缓存和数据库数据的一致性&#34;&gt;如何保证缓存和数据库数据的⼀致性&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/v123411739/article/details/124237900&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/lans_g/article/details/124652284&lt;/p&gt;
&lt;h2 id=&#34;redis集群策略&#34;&gt;Redis集群策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主数据库可以进行读写操作&lt;/strong&gt;，当读写操作导致数据变化时会自动将数据同步给从数据库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slave从数据库一般都是只读&lt;/strong&gt;的，并且接收主数据库同步过来的数据&lt;/li&gt;
&lt;li&gt;一个master可以拥有多个slave，但是一个slave只能对应一个master&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控主从数据库是否正常运行&lt;/li&gt;
&lt;li&gt;master出现故障时，自动将slave转化为master&lt;/li&gt;
&lt;li&gt;多哨兵配置的时候，哨兵之间也会自动监控&lt;/li&gt;
&lt;li&gt;多个哨兵可以监控同一个redis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集群模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis的集群部署可以将数据划分为多个子集存在不同的节点上，每个节点负责自己整个数据的一部分。&lt;/li&gt;
&lt;li&gt;Redis Cluster采用哈希分区规则中的虚拟槽分区。虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，整数定义为槽（slot）。Redis的槽的范围是（0 - 16383，2^14-1）。槽是集群内数据管理和迁移的基本单位。所有的键根据哈希函数映射到哈希槽，每个节点负责维护一部分的槽和其映射的键值数据。&lt;/li&gt;
&lt;li&gt;计算规则为：key = CRC16 % 16384&lt;/li&gt;
&lt;li&gt;哈希槽让在集群中添加和移除节点非常容易。例如，如果我想添加一个新节点 D ，我需要从节点 A 、B、C 移动一些哈希槽到节点 D。同样地，如果我想从集群中移除节点 A ，我只需要移动 A 的哈希槽到 B 和 C。当节点 A 变成空的以后，我就可以从集群中彻底删除它。因为从一个节点向另一个节点移动哈希槽并不需要停止操作，所以添加和移除节点，或者改变节点持有的哈希槽百分比，都不需要任何停机时间（downtime）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主从同步&#34;&gt;主从同步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全量同步：
&lt;ul&gt;
&lt;li&gt;流程：
&lt;ul&gt;
&lt;li&gt;从服务器连接主服务器，发送SYNC命令&lt;/li&gt;
&lt;li&gt;主服务器收到SYNC命令，开始执行BGSAVE命令，生成RDB文件，并使用缓冲区记录备份过程中执行的所有命令。&lt;/li&gt;
&lt;li&gt;主服务器BGSAVE完成后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令。&lt;/li&gt;
&lt;li&gt;从服务器收到快照文件后丢弃所有旧数据，载入收到的快照&lt;/li&gt;
&lt;li&gt;主服务器快照发送完毕后向从服务器发送写命令，将BGSAVE期间收到的命令发送给从服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增量同步：
&lt;ul&gt;
&lt;li&gt;主服务器执行一个写命令，并且向从服务器发送相同的写命令，从服务器收到后就会执行收到的写命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis高并发和快速的原因&#34;&gt;Redis高并发和快速的原因&lt;/h2&gt;
&lt;p&gt;参考https://www.cnblogs.com/angelyan/p/10450885.html&lt;/p&gt;
&lt;p&gt;1.redis是基于&lt;strong&gt;内存&lt;/strong&gt;的，内存的读写速度非常快；&lt;/p&gt;
&lt;p&gt;2.redis是&lt;strong&gt;单线程&lt;/strong&gt;的，省去了很多上下文切换线程的时间；&lt;/p&gt;
&lt;p&gt;3.redis使用&lt;strong&gt;多路复用技术，可以处理并发的连接&lt;/strong&gt;。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。&lt;/p&gt;
&lt;h2 id=&#34;什么情况下使用redis-2&#34;&gt;什么情况下使用&lt;a href=&#34;https://www.nowcoder.com/jump/super-jump/word?word=redis&#34;&gt;redis&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;针对热点数据进行缓存&lt;/li&gt;
&lt;li&gt;对于特定限时数据的存放&lt;/li&gt;
&lt;li&gt;针对带热点权值数据的&lt;a href=&#34;https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F&#34;&gt;排序&lt;/a&gt;list&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是缓存与数据库双写一致问题&#34;&gt;什么是缓存与数据库双写一致问题？&lt;/h2&gt;
&lt;p&gt;如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要&lt;strong&gt;更新&lt;/strong&gt;时候呢？各种情况很可能就&lt;strong&gt;造成数据库和缓存的数据不一致&lt;/strong&gt;了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里不一致指的是：&lt;strong&gt;数据库的数据跟缓存的数据不一致&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib2l33BGMSoKYvGQ9LHw02ZOqNExlaAAtCUfWtuYW3qEPnv3wOs7Raz11wy7jlGhu9HJzplBaia72pw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34; loading=&#34;lazy&#34;&gt;数据库和缓存的数据不一致&lt;/p&gt;
&lt;p&gt;从理论上说，只要我们设置了&lt;strong&gt;键的过期时间&lt;/strong&gt;，我们就能保证缓存和数据库的数据&lt;strong&gt;最终是一致&lt;/strong&gt;的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。&lt;/p&gt;
&lt;p&gt;除了设置过期时间，我们还需要做更多的措施来&lt;strong&gt;尽量避免&lt;/strong&gt;数据库与缓存处于不一致的情况发生。&lt;/p&gt;
&lt;h2 id=&#34;redis怎么保证和mysql数据一致&#34;&gt;Redis怎么保证和Mysql数据一致&lt;/h2&gt;
&lt;p&gt;参考 https://www.cnblogs.com/lingqin/p/10279393.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.第一种方案：采用延时双删策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。&lt;/p&gt;
&lt;p&gt;伪代码如下&lt;/p&gt;
&lt;p&gt;public &lt;a href=&#34;https://mb.yidianzixun.com/channel/w/void&#34;&gt;void&lt;/a&gt; write(String key,&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/object&#34;&gt;Object&lt;/a&gt; data){ redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key); }&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.具体的步骤就是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）先删除缓存&lt;/p&gt;
&lt;p&gt;2）再写数据库&lt;/p&gt;
&lt;p&gt;3）休眠500毫秒&lt;/p&gt;
&lt;p&gt;4）再次删除缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，这个500毫秒怎么确定的，具体该休眠多久呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。&lt;/p&gt;
&lt;p&gt;当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.设置缓存过期时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.该方案的弊端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.技术整体思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[MySQL binlog](https://mb.yidianzixun.com/channel/w/mysql binlog)增量订阅消费+消息队列+增量数据更新到redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）读Redis&lt;/strong&gt;：热数据基本都在Redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）写MySQL&lt;/strong&gt;:增删改都是操作MySQL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）更新Redis数据&lt;/strong&gt;：MySQ的数据操作binlog，来更新到Redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Redis更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）数据操作主要分为两大块：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是全量(将全部数据一次写入到redis)&lt;/li&gt;
&lt;li&gt;一个是增量（实时更新）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里说的是增量,指的是mysql的update、insert、delate变更数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。&lt;/p&gt;
&lt;p&gt;其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。&lt;/p&gt;
&lt;p&gt;这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/mysql&#34;&gt;mysql&lt;/a&gt;的slave&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;数据库&lt;/a&gt;的备份请求，使得Redis的数据更新达到了相同的效果。&lt;/p&gt;
&lt;p&gt;当然，这里的消息推送工具你也可以采用别的第三方：&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/kafka&#34;&gt;kafka&lt;/a&gt;、&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/rabbitmq&#34;&gt;rabbitMQ&lt;/a&gt;等来实现推送更新&lt;a href=&#34;https://mb.yidianzixun.com/channel/w/redis&#34;&gt;Redis&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/5185e1f165b06e570dcffe57c993a6d3.png&#34; alt=&#34;image-20220508181331250&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;save命令&#34;&gt;save命令&lt;/h2&gt;
&lt;p&gt;save命令是&lt;a href=&#34;&#34;&gt;redis&lt;/a&gt;手动触发RDB过程的命令。使用该命令后**，服务器阻塞，直到RDB过程完成后终止。该过程占用内存较多**。&lt;/p&gt;
&lt;h2 id=&#34;bgsave命令&#34;&gt;bgsave命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bgsave命令不阻塞主进程&lt;/strong&gt;（严格意义上也不是完全不阻塞，详看下面过程），该命令fork一个子进程用于执行RDB过程。其具体过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断此时有没有子进程用于RDB，有的话直接返回。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;redis&lt;/a&gt;进行fork子进程过程，此时父进程处于阻塞状态。&lt;/li&gt;
&lt;li&gt;子进程创建RDB文件，完成后返回给父进程 ·&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何实现分布式锁&#34;&gt;如何实现分布式锁&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/javazhiyin/p/11737403.html&lt;/p&gt;
&lt;h2 id=&#34;redis常用命令&#34;&gt;Redis常用命令&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/u010191034/article/details/83383448&lt;/p&gt;
&lt;h2 id=&#34;redis设置过期时间&#34;&gt;Redis设置过期时间&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;EXPIRE&lt;/strong&gt; 接口定义：EXPIRE key &amp;quot;seconds&amp;quot;&lt;br&gt;
　　　　接口描述：设置一个key在当前时间&amp;quot;seconds&amp;quot;(秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PEXPIRE&lt;/strong&gt; 接口定义：PEXPIRE key &amp;quot;milliseconds&amp;quot;&lt;br&gt;
　　　　接口描述：设置一个key在当前时间&amp;quot;milliseconds&amp;quot;(毫秒)之后过期。返回1代表设置成功，返回0代表key不存在或者无法设置过期时间。&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;h2 id=&#34;redis的使用注意点总结&#34;&gt;redis的使用注意点总结&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/WR0309/article/details/122819361&lt;/p&gt;
&lt;h3 id=&#34;如何使用redis更节省内存&#34;&gt;如何使用redis更节省内存&lt;/h3&gt;
&lt;p&gt;redis之所以快是因为它是一款内存数据库，但是一台机器内存都是有限且比较珍贵的资源，使用redis的时候需要合理的规划对应的内存优化策略。&lt;/p&gt;
&lt;p&gt;1、控制key的长度，当key的量级很大的时候，合理的控制key的长度可以节省很大的空间。&lt;/p&gt;
&lt;p&gt;2、避免存储bigkey，除了控制key的长度，value的大小也要关注，string的大小控制在10kb以下，list、hash、set、zset也要控制。&lt;/p&gt;
&lt;p&gt;3、合理的选择数据类型&lt;/p&gt;
&lt;p&gt;String、Set 在存储 int 数据时，会采用整数编码存储。Hash、ZSet 在元素数量比较少时（可配置），会采用压缩列表（ziplist）存储，在存储比较多的数据时，才会转换为哈希表和跳表。&lt;/p&gt;
&lt;p&gt;String、Set：尽可能存储 int 类型数据&lt;br&gt;
Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存&lt;br&gt;
4、把redis尽可能的当成缓存使用&lt;/p&gt;
&lt;p&gt;5、实例设置maxmemory+淘汰策略&lt;/p&gt;
&lt;p&gt;虽然使用redis的时候会设置key的过期时间，但是如果业务写入量比较大的话，那么短期内redis的内存依旧会快速增加。需要提前预估业务数据量，然后给实例设置maxmemory控制实例的内存上限，然后需要设置内存过期策略。&lt;/p&gt;
&lt;p&gt;volatile-lru / allkeys-lru：优先保留最近访问过的数据&lt;br&gt;
volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）&lt;br&gt;
volatile-ttl ：优先淘汰即将过期的数据&lt;br&gt;
volatile-random / allkeys-random：随机淘汰数据&lt;br&gt;
6、数据压缩后写入redis&lt;/p&gt;
&lt;h3 id=&#34;如何持续的发挥redis的高性能&#34;&gt;如何持续的发挥redis的高性能&lt;/h3&gt;
&lt;p&gt;1、避免存储bigkey&lt;/p&gt;
&lt;p&gt;redis是单线程的，当写入一个bigkey的时候，redis会用更多的时间消耗在内存分配上，同样删除的时候也会比较耗时，另外就是客户端在读取bigkey的时候，在网络数据传输上比较耗时。&lt;/p&gt;
&lt;p&gt;2、开启lazy-free机制&lt;/p&gt;
&lt;p&gt;如果无法避免的使用bigkey的时候，可以开启lazy-free机制，当删除bigkey的时候，释放内存的操作会交给后台线程执行，这样可以最大程度上避免对主线程的影响。&lt;/p&gt;
&lt;p&gt;3、不适用复杂度过高的命令&lt;/p&gt;
&lt;p&gt;4、执行O（N）级别的命令的时候，要关注以下N的大小&lt;/p&gt;
&lt;p&gt;对于容器类型（List/Hash/Set/ZSet），在元素数量未知的情况下，一定不要无脑执行 LRANGE key 0 -1 / HGETALL / SMEMBERS / ZRANGE key 0 -1&lt;/p&gt;
&lt;p&gt;在查询数据时，你要遵循以下原则：&lt;/p&gt;
&lt;p&gt;先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）&lt;br&gt;
元素数量较少，可一次性查询全量数据&lt;br&gt;
元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）&lt;br&gt;
5、关注del的时间复杂度&lt;/p&gt;
&lt;p&gt;当你删除的是一个 String 类型 key 时，时间复杂度确实是 O(1)。&lt;/p&gt;
&lt;p&gt;但当你要删除的 key 是 List/Hash/Set/ZSet 类型，它的复杂度其实为 O(N)，N 代表元素个数。&lt;/p&gt;
&lt;p&gt;也就是说，删除一个 key，其元素数量越多，执行 DEL 也就越慢！&lt;/p&gt;
&lt;p&gt;List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成&lt;br&gt;
Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素&lt;br&gt;
6、批量的命令代替单个命令&lt;/p&gt;
&lt;p&gt;String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET&lt;br&gt;
其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行&lt;br&gt;
7、避免集中过期key&lt;/p&gt;
&lt;p&gt;如果业务中有大量的key集中过期，这个会阻塞主线程，可以在设置过期时间的时候增加一个随机时间，将过期时间打散。&lt;/p&gt;
&lt;p&gt;8、使用长链接操作redis，合理配置连接池&lt;/p&gt;
&lt;p&gt;尽量避免短链接，因为每次都是tcp，三次握手和四次挥手，这个过程会增加操作消耗。&lt;/p&gt;
&lt;p&gt;9、只使用db0&lt;/p&gt;
&lt;p&gt;在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力&lt;br&gt;
使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能&lt;br&gt;
Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高&lt;br&gt;
10、使用读写分离+分片集群&lt;/p&gt;
&lt;p&gt;如果读业务很大，可以采用部署多个从库的方式，实现读写分离，让从库分担读压力，提升性能。&lt;/p&gt;
&lt;p&gt;如果写业务的请求很大，单个redis的实例无法支持大的流量，可以使用分片集群，分担写压力。&lt;/p&gt;
&lt;p&gt;11、不开启AOF或AOF配置成每秒刷盘&lt;/p&gt;
&lt;p&gt;对于丢失数据不敏感的业务，不建议开启AOF，如果确实需要开启，可以配置成 appendfsync everysec，将持久化放在后台线程中。&lt;/p&gt;
&lt;p&gt;12、使用物理机部署redis&lt;/p&gt;
&lt;p&gt;redis使用rdb持久化的时候，采用子进程的方式，虚拟机支持fork比较耗时。&lt;/p&gt;
&lt;p&gt;13、关闭操作系统内存大页机制&lt;/p&gt;
&lt;h3 id=&#34;如何保证redis的高可用&#34;&gt;如何保证redis的高可用&lt;/h3&gt;
&lt;p&gt;redis可靠性也是不难，难点是持续的稳定。&lt;/p&gt;
&lt;p&gt;1、按照业务线进行部署实例&lt;/p&gt;
&lt;p&gt;不同的业务采用不同的redis的实例，有问题的时候互不干扰。&lt;/p&gt;
&lt;p&gt;2、部署主从集群&lt;/p&gt;
&lt;p&gt;主库和从库也最好放在不同的机器上。&lt;/p&gt;
&lt;p&gt;3、合理的设置主从复制参数&lt;/p&gt;
&lt;p&gt;设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险&lt;br&gt;
设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断&lt;br&gt;
4、部署哨兵集群，实现故障自动转移&lt;/p&gt;
&lt;p&gt;只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。&lt;/p&gt;
&lt;p&gt;而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间。&lt;/p&gt;
&lt;p&gt;日常运维redis需要注意什么&lt;br&gt;
1、禁止使用 KEYS/FLUSHALL/FLUSHDB 命令，会阻塞主线程，影响线上业务&lt;/p&gt;
&lt;p&gt;SCAN 替换 KEYS&lt;br&gt;
4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行&lt;br&gt;
2、扫描线上实例时，设置休眠时间&lt;/p&gt;
&lt;p&gt;不管你是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，我建议你在扫描时一定记得设置休眠时间。&lt;/p&gt;
&lt;p&gt;防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动。&lt;/p&gt;
&lt;p&gt;3、慎用monitor命令&lt;/p&gt;
&lt;p&gt;4、从库必现设置成slave-read-only，避免从库写入导致数据不一致。&lt;/p&gt;
&lt;p&gt;5、合理配置 timeout 和 tcp-keepalive 参数，&lt;/p&gt;
&lt;p&gt;如果因为网络原因，导致你的大量客户端连接与 Redis 意外中断，恰好你的 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。&lt;/p&gt;
&lt;p&gt;造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。&lt;/p&gt;
&lt;p&gt;当客户端与服务端发生网络问题，服务端不会立即释放client fd。&lt;/p&gt;
&lt;p&gt;不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉&lt;br&gt;
Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd&lt;br&gt;
6、调整maxmemory时，注意主从库的调整顺序&lt;/p&gt;
&lt;p&gt;Redis 5.0 以下版本存在这样一个问题：从库内存如果超过了 maxmemory，也会触发数据淘汰。&lt;/p&gt;
&lt;p&gt;在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。&lt;/p&gt;
&lt;p&gt;要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：&lt;/p&gt;
&lt;p&gt;调大 maxmemory：先修改从库，再修改主库&lt;br&gt;
调小 maxmemory：先修改主库，再修改从库&lt;br&gt;
直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题。&lt;/p&gt;
&lt;h3 id=&#34;redis安全问题&#34;&gt;redis安全问题&lt;/h3&gt;
&lt;p&gt;不要把 Redis 部署在公网可访问的服务器上&lt;br&gt;
部署时不使用默认端口 6379&lt;br&gt;
以普通用户启动 Redis 进程，禁止 root 用户启动&lt;br&gt;
限制 Redis 配置文件的目录访问权限&lt;br&gt;
推荐开启密码认证&lt;br&gt;
禁用/重命名危险命令（KEYS/FLUSHALL/FLUSHDB/CONFIG/EVAL）&lt;/p&gt;
">Redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/springboot/"" data-c="
          &lt;h2 id=&#34;springboot启动流程&#34;&gt;springboot启动流程&lt;/h2&gt;
&lt;p&gt;SpringBoot启动的时候，会构造一个SpringApplication的实例，然后调用这个实例的run方法，在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：&lt;/p&gt;
&lt;p&gt;(1)把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数.&lt;br&gt;
(2)判断是否是web程序，并设置到webEnvironment的boolean属性中.&lt;br&gt;
(3)创建并初始化ApplicationInitializer，设置到initializers属性中 。&lt;br&gt;
(4)创建并初始化ApplicationListener，设置到listeners属性中 。&lt;br&gt;
(5)初始化主类mainApplicatioClass。&lt;/p&gt;
&lt;h2 id=&#34;springboot的自动装配原理&#34;&gt;SpringBoot的自动装配原理&lt;/h2&gt;
&lt;p&gt;Spring Boot关于自动配置的源码在spring-boot-autoconfigure-x.x.x.x.jar中&lt;/p&gt;
&lt;p&gt;Spring Boot的启动类上有一个@&lt;strong&gt;SpringBootApplication&lt;/strong&gt;注解，这个注解是Spring Boot项目必不可少的注解。那么自动配置原理一定和这个注解有着千丝万缕的联系！&lt;/p&gt;
&lt;p&gt;其关键点是注解@EnableAutoConfiguration当中的导入import的&lt;strong&gt;AutoConfigurationImportSelector&lt;/strong&gt;中的selectImports方法 通过&lt;strong&gt;SpringFactoriesLoader.loadFactoryNames()&lt;strong&gt;扫描所有具有&lt;/strong&gt;META-INF/spring.factories&lt;/strong&gt;的jar包&lt;/p&gt;
&lt;p&gt;在spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。&lt;/p&gt;
&lt;p&gt;这个spring.factories文件也是一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔&lt;/p&gt;
&lt;p&gt;类似于下图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqf9l.png&#34; alt=&#34;dqf9l.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这个@EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了Spring Boot的启动类上。在SpringApplication.run(...)的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u014745069/article/details/83820511&lt;/p&gt;
&lt;h2 id=&#34;简单介绍一下-spring有啥缺点&#34;&gt;简单介绍⼀下 Spring?有啥缺点?&lt;/h2&gt;
&lt;p&gt;缺点是集成度较高，使用过程中不太容易了解底层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ioc和aop配置复杂&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;说出使用-spring-boot-的主要优点&#34;&gt;说出使⽤ Spring Boot 的主要优点&lt;/h2&gt;
&lt;p&gt;(1)简化配置，不需要编写太多的xml配置文件；&lt;/p&gt;
&lt;p&gt;(2)基于Spring构建，使开发者快速入门，门槛很低；&lt;/p&gt;
&lt;p&gt;(3)SpringBoot可以创建独立运行的应用而不需要依赖于容器；&lt;/p&gt;
&lt;p&gt;(4)内置tomcat服务器，不需要打包成war包，可以直接放到tomcat中运行；&lt;/p&gt;
&lt;p&gt;(5)提供maven极简配置，以及可视化的相关监控功能，比如性能监控，应用的健康程度等；&lt;/p&gt;
&lt;p&gt;(6)为微服务SpringCloud奠定了基础，使得微服务的构建变得简单；&lt;/p&gt;
&lt;p&gt;(7)Spring可以整合很多各式各样的框架，并能很好的集成；&lt;/p&gt;
&lt;p&gt;(8)活跃的社区与论坛，以及丰富的开发文档；&lt;/p&gt;
&lt;h2 id=&#34;什么是-spring-boot-starters&#34;&gt;什么是 Spring Boot Starters?&lt;/h2&gt;
&lt;p&gt;starter是SpringBoot中的一个新发明，它有效的降低了项目开发过程的复杂程度，对于简化开发操作有着非常好的效果。&lt;/p&gt;
&lt;p&gt;参考连接：https://stackoverflow.com/questions/28273543/what-are-spring-boot-starter-jars/28273660#28273660&lt;/p&gt;
&lt;h2 id=&#34;spring-boot-支持哪些内嵌-servlet-容器&#34;&gt;Spring Boot ⽀持哪些内嵌 Servlet 容器？&lt;/h2&gt;
&lt;p&gt;Spring Boot支持Tomcat、Jetty和Undertow三种Servlet容器嵌入到Web应用程序中，开发者使用starter即可方便嵌入，默认情况下，嵌入服务器的访问端口为8080。&lt;/p&gt;
&lt;h2 id=&#34;如何在-spring-boot-应用程序中使用-jetty-而不是-tomcat&#34;&gt;如何在 Spring Boot 应⽤程序中使⽤ Jetty ⽽不是 Tomcat?&lt;/h2&gt;
&lt;p&gt;就是在pom.xml文件中，在引用的spring-boot-starter-web排除Tomcat的依赖包，然后再引入Jetty容器的依赖包，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;          &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;              &amp;lt;exclusions&amp;gt;                  &amp;lt;exclusion&amp;gt;                      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                      &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;                  &amp;lt;/exclusion&amp;gt;              &amp;lt;/exclusions&amp;gt;          &amp;lt;/dependency&amp;gt;            &amp;lt;!-- Jetty适合长连接应用，就是聊天类的长连接 --&amp;gt;          &amp;lt;!-- 使用Jetty，需要在spring-boot-starter-web排除spring-boot-starter-tomcat，因为SpringBoot默认使用tomcat --&amp;gt;          &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-jetty&amp;lt;/artifactId&amp;gt;          &amp;lt;/dependency&amp;gt;          &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;              &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;          &amp;lt;/dependency&amp;gt;  &amp;lt;/dependencies&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;把容器修改为undertow&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;          &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;              &amp;lt;exclusions&amp;gt;                  &amp;lt;exclusion&amp;gt;                      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                      &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;                  &amp;lt;/exclusion&amp;gt;              &amp;lt;/exclusions&amp;gt;          &amp;lt;/dependency&amp;gt;                    &amp;lt;!-- undertow不支持jsp --&amp;gt;          &amp;lt;!-- 使用undertow，需要在spring-boot-starter-web排除spring-boot-starter-tomcat，因为SpringBoot默认使用tomcat --&amp;gt;          &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-undertow&amp;lt;/artifactId&amp;gt;          &amp;lt;/dependency&amp;gt;                    &amp;lt;dependency&amp;gt;              &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;              &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;              &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;          &amp;lt;/dependency&amp;gt;  &amp;lt;/dependencies&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/fanshuyao/p/8668059.html&lt;/p&gt;
&lt;h2 id=&#34;介绍一下springbootapplication-注解&#34;&gt;介绍⼀下@SpringBootApplication 注解&lt;/h2&gt;
&lt;p&gt;@SpringBootApplication注解包含三个注解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@ComponentScan扫描当前包和子包中的组件，自动注册到ioc中&lt;/li&gt;
&lt;li&gt;@SpringBootConfiguration，它其实也是一个configuration，说明启动类也是一个配置类&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration，这个注解是实现自动配置的最主要的注解。这个注解里包含**@AutoConfigurationPackage自动配置包**还有@import一个AutoConfigurationImportSelector.class。这个类中通过loadFactoryNames读取meta-inf中的spring。factories文件中自动装配的类。而这些类是pom文件中导入了start之后才能生效。这些类都是XXXautoconfiguration，中还绑定了有属性的xxx.properties，这些properties有一些默认的属性。我们也可以在配置文件yml或者properties中修改这些属性。&lt;br&gt;
SpringApplication.run一共做了两件事&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建SpringApplication对象；在对象初始化时保存事件监听器，容器初始化类以及判断是否为web应用，保存包含main方法的主配置类。&lt;/li&gt;
&lt;li&gt;调用run方法；准备spring的上下文，完成容器的初始化，创建，加载等。会在不同的时机触发监听器的不同事件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-boot-的自动配置是如何实现的&#34;&gt;Spring Boot 的⾃动配置是如何实现的?&lt;/h2&gt;
&lt;p&gt;参考：https://blog.csdn.net/u014534808/article/details/105961992/&lt;/p&gt;
&lt;h2 id=&#34;开发-restful-web-服务常用的注解有哪些&#34;&gt;开发 RESTful Web 服务常⽤的注解有哪些？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;@GetMapping，处理 Get 请求&lt;/li&gt;
&lt;li&gt;@PostMapping，处理 Post 请求&lt;/li&gt;
&lt;li&gt;@PutMapping，⽤用于更新资源&lt;/li&gt;
&lt;li&gt;@DeleteMapping，处理删除请求&lt;/li&gt;
&lt;li&gt;@PatchMapping，用于更新部分资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spirng-boot-常用的两种配置文件&#34;&gt;Spirng Boot 常⽤的两种配置⽂件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;properties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yaml&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是-yamlyaml-配置的优势在哪里&#34;&gt;什么是 YAML？YAML 配置的优势在哪⾥ ?&lt;/h2&gt;
&lt;p&gt;YAML是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆。可以看出YAML具有分层配置数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置有序，在一些特殊的场景下，配置有序很关键&lt;/li&gt;
&lt;li&gt;支持数组，数组中的元素可以是基本数据类型也可以是对象 简洁 相比 properties&lt;/li&gt;
&lt;li&gt;相比properties配置文件，YAML还有一个缺点，就是不支持@PropertySource注解导入自定义的YAML配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring-boot-常用的读取配置文件的方法有哪些&#34;&gt;Spring Boot 常⽤的读取配置⽂件的⽅法有哪些？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;获取环境变量&lt;/strong&gt;来获取配置参数&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;注解获取配置&lt;/strong&gt;文件信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/github_35169934/article/details/78233421?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;amp;dist_request_id=&amp;amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring-boot-加载配置文件的优先级了解么&#34;&gt;Spring Boot 加载配置⽂件的优先级了解么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;file:/config/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;file:/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;classpath:/config/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;classpath:/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用的-bean-映射工具有哪些&#34;&gt;常⽤的 Bean 映射⼯具有哪些？&lt;/h2&gt;
&lt;p&gt;BeanUtils---先用 jdk 的 java.beans.Introspector类的getBeanInfo()方法获取对象的属性信息及属性get/set方法，接着使用反射（Method的invoke(Object obj, Object… args)）方法进行赋值&lt;/p&gt;
&lt;p&gt;BeanCopier---直接使用ASM的MethodVisitor直接编写各属性的get/set方法&lt;/p&gt;
&lt;p&gt;mybatis&lt;/p&gt;
&lt;h2 id=&#34;spring-boot-如何监控系统实际运行状况&#34;&gt;Spring Boot 如何监控系统实际运⾏状况？&lt;/h2&gt;
&lt;p&gt;组件 Spring Boot Actuator 负责监控应⽤的各项静态和动态的变量&lt;/p&gt;
&lt;h2 id=&#34;spring-boot-如何做请求参数校验&#34;&gt;Spring Boot 如何做请求参数校验？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-starter-validation&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何使用-spring-boot-实现全局异常处理&#34;&gt;如何使⽤ Spring Boot 实现全局异常处理？&lt;/h2&gt;
&lt;p&gt;使⽤ &lt;strong&gt;@ControllerAdvice&lt;/strong&gt; 定义统⼀的异常处理类，⽽不是在每个Controller中逐个定义&lt;/p&gt;
&lt;p&gt;@ExceptionHandler ⽤来定义函数针对的异常类型&lt;/p&gt;
&lt;h2 id=&#34;spring-boot-中如何实现定时任务&#34;&gt;Spring Boot 中如何实现定时任务 ?&lt;/h2&gt;
&lt;p&gt;一种是使用 Spring 自带的定时任务处理器 @Scheduled 注解，另一种就是使用第三方框架 Quartz&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lenve/p/10728897.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;分布式系统session一致性问题&#34;&gt;分布式系统session一致性问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;session同步法&lt;/strong&gt;：多台web-server相互同步数据&lt;/li&gt;
&lt;li&gt;**客户端存储法：**一个用户只存储自己的数据&lt;/li&gt;
&lt;li&gt;**反向代理hash一致性：**四层hash和七层hash都可以做，保证一个用户的请求落在一台web-server上&lt;/li&gt;
&lt;li&gt;**后端统一存储：**web-server重启和扩容，session也不会丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/study-everyday/p/7853145.html&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
">SpringBoot</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/spring/"" data-c="
          &lt;h2 id=&#34;maven中package和install的区别&#34;&gt;Maven中Package和Install的区别&lt;/h2&gt;
&lt;p&gt;​	Package是打包，打成Jar或War&lt;/p&gt;
&lt;p&gt;​	Install表示将Jar或War安装到本地仓库中&lt;/p&gt;
&lt;h2 id=&#34;什么是spring框架&#34;&gt;什么是spring框架&lt;/h2&gt;
&lt;p&gt;Spring 是⼀种轻量级开发框架，旨在提⾼开发⼈员的开发效率以及系统的可维护性。Spring 官⽹：https://spring.io/。&lt;/p&gt;
&lt;p&gt;我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。&lt;/p&gt;
&lt;p&gt;这些模块是：核⼼容器、数据访问/集成,、Web、AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如：Core Container 中的 Core 组件是Spring 所有组件的核⼼，Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础，AOP组件⽤来实现⾯向切⾯编程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring 官⽹列出的 Spring 的 6 个特征:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核⼼技术 ：依赖注⼊(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试 ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。&lt;/li&gt;
&lt;li&gt;数据访问 ：事务，DAO⽀持，JDBC，ORM，编组XML。&lt;/li&gt;
&lt;li&gt;Web⽀持 : Spring MVC和Spring WebFlux Web框架&lt;/li&gt;
&lt;li&gt;集成 ：远程处理，JMS，JCA，JMX，电⼦邮件，任务，调度，缓存。&lt;/li&gt;
&lt;li&gt;语⾔ ：Kotlin，Groovy，动态语⾔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;列举一些重要的spring模块&#34;&gt;列举⼀些重要的Spring模块？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依&lt;br&gt;
赖注⼊功能。&lt;/li&gt;
&lt;li&gt;Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。&lt;/li&gt;
&lt;li&gt;Spring AOP ：提供了⾯向切⾯的编程实现。&lt;/li&gt;
&lt;li&gt;Spring JDBC : Java数据库连接。&lt;/li&gt;
&lt;li&gt;Spring JMS ：Java消息服务。&lt;/li&gt;
&lt;li&gt;Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。&lt;/li&gt;
&lt;li&gt;Spring Web : 为创建Web应⽤程序提供⽀持。&lt;/li&gt;
&lt;li&gt;Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;restcontroller-vs-controller&#34;&gt;@RestController vs @Controller&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Controller 返回⼀个⻚⾯&lt;/strong&gt;&lt;br&gt;
单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐᫾传统的Spring MVC 的应⽤，对应于前后端不分离的情况&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@RestController 返回JSON 或 XML 形式数据&lt;/strong&gt;&lt;br&gt;
但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Controller +@ResponseBody 返回JSON 或 XML 形式数据&lt;/strong&gt;&lt;br&gt;
如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4）之后新加的注解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@ResponseBody 注解&lt;/strong&gt;的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况比较多。&lt;/p&gt;
&lt;h2 id=&#34;常用注解&#34;&gt;常用注解&lt;/h2&gt;
&lt;h2 id=&#34;spring依赖注入的方式&#34;&gt;Spring依赖注入的方式&lt;/h2&gt;
&lt;p&gt;非注解方式注入：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set方法注入&lt;/li&gt;
&lt;li&gt;构造器注入&lt;/li&gt;
&lt;li&gt;静态工厂的方法注入&lt;/li&gt;
&lt;li&gt;实例工厂的方法注入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注解方式注入：&lt;/p&gt;
&lt;p&gt;1.@Autowired是自动注入，自动从spring的上下文找到合适的bean来注入 @Autowired(required=true)表示必须找到匹配的Bean，否则将报异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Autowired默认按类型匹配注入Bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Spring中，@Autowired注入的类型可以是接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，在Service层中注入Dao，如下示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private UserDao userDao;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.@Resource要求提供一个Bean名称的属性，如果属性为空，自动采用标注处的变量名和方法名作为Bean的名称 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Resource默认按名称匹配注入Bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，在Controller层中注入Service，名称为Service的实现类，如下示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Resource(name = &amp;quot;userServiceImpl&amp;quot;)
 private UserService userService;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外要注意，@Resource是java自带的注解，不是Spring中的注解。@Resource注解完整的包路径为import  javax.annotation.Resource;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;@Qualifier 指定注入bean的名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，在Controller层中注入Service，名称为Service的实现类，如下示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @Autowired
 @Qualifier(&amp;quot;userServiceImp&amp;quot;)
 private UserSerevice userService;
4.@Service，@Controller，@Repository分别标记类是Service层，Controller层，Dao层的类，spring扫描注解配置时，会标记这些类要生成bean。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Repository用于标注数据访问组件，即DAO组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Service，@Controller 这些注解要放在接口的实现类上，而不是接口上面。&lt;/strong&gt;&lt;br&gt;
5.@Component是一种泛指，标记类是组件，spring扫描注解配置时，会标记这些类要生成bean。&lt;/p&gt;
&lt;p&gt;6.@&lt;strong&gt;Scope&lt;/strong&gt;用于指定Bean的作用范围&lt;/p&gt;
&lt;p&gt;7.@Autowired和@Resource是用来修饰字段，构造函数，或者设置方法，并做注入的。&lt;/p&gt;
&lt;p&gt;而@Service，@Controller，@Repository，@Component则是用来修饰类，标记这些类要生成bean。&lt;/p&gt;
&lt;h2 id=&#34;spring-ioc-aop&#34;&gt;Spring IOC &amp;amp; AOP&lt;/h2&gt;
&lt;p&gt;IOC参考：&lt;/p&gt;
&lt;p&gt;AOP参考：https://www.cnblogs.com/joy99/p/10941543.html&lt;/p&gt;
&lt;h3 id=&#34;谈谈自己对于-spring-ioc-和-aop-的理解&#34;&gt;谈谈⾃⼰对于 Spring IoC 和 AOP 的理解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IoC&lt;/strong&gt;&lt;br&gt;
IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP(Aspect-Oriented Programming:⾯向切⾯编程)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;
&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切面（aspect） ： 类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;/li&gt;
&lt;li&gt;横切关注点： 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。&lt;/li&gt;
&lt;li&gt;连接点（joinpoint） ： 被拦截到的点，具体要拦截的东西，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。&lt;/li&gt;
&lt;li&gt;切入点（pointcut） ： 对连接点进行拦截的定义&lt;/li&gt;
&lt;li&gt;通知（advice） ： 所谓通知指的就是指拦截到连接点之后要执行的代码， 通知分为前置、后置、异常、最终、环绕通知五类。&lt;/li&gt;
&lt;li&gt;目标对象： 代理的目标对象&lt;/li&gt;
&lt;li&gt;织入（weave） ： 将切面应用到目标对象并导致代理对象创建的过程&lt;/li&gt;
&lt;li&gt;引入（introduction） ： 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spring-aop-和-aspectj-aop-有什么区别&#34;&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强&lt;/strong&gt;。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：Spring中的AspectJ不是真正的使用了AspectJ，只是使用了AspectJ的指示器作为标识创建代理的方式而已，实际上实现AOP还是通过Cglib或JDK来实现的&lt;/p&gt;
&lt;p&gt;两者区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Spring AOP&lt;/th&gt;
&lt;th&gt;AspectJ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在纯 Java 中实现&lt;/td&gt;
&lt;td&gt;使用 Java 编程语言的扩展实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不需要单独的编译过程&lt;/td&gt;
&lt;td&gt;除非设置 LTW，否则需要 AspectJ 编译器 (ajc)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只能使用运行时织入&lt;/td&gt;
&lt;td&gt;运行时织入不可用。支持编译时、编译后和加载时织入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;功能不强-仅支持方法级编织&lt;/td&gt;
&lt;td&gt;更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等......。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只能在由 Spring 容器管理的 bean 上实现&lt;/td&gt;
&lt;td&gt;可以在所有域对象上实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仅支持方法执行切入点&lt;/td&gt;
&lt;td&gt;支持所有切入点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;代理是由目标对象创建的, 并且切面应用在这些代理上&lt;/td&gt;
&lt;td&gt;在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;比 AspectJ 慢多了&lt;/td&gt;
&lt;td&gt;更好的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;易于学习和应用&lt;/td&gt;
&lt;td&gt;相对于 Spring AOP 来说更复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;spring-aop-实现原理&#34;&gt;Spring AOP 实现原理&lt;/h3&gt;
&lt;p&gt;AOP技术利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。&lt;/p&gt;
&lt;p&gt;实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；&lt;/p&gt;
&lt;p&gt;二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。&lt;/p&gt;
&lt;h3 id=&#34;aop使用场景&#34;&gt;AOP使用场景&lt;/h3&gt;
&lt;p&gt;日志记录、监控优化&lt;br&gt;
2） 权限控制&lt;br&gt;
3） 事务管理&lt;br&gt;
4） 缓存&lt;br&gt;
5） 持久化&lt;/p&gt;
&lt;h3 id=&#34;spring的ioc是单例模式的么&#34;&gt;Spring的IOC是单例模式的么？&lt;/h3&gt;
&lt;p&gt;IOC默认使用单例模式创建Bean，默认在spring容器启动时会自动创建对象。&lt;/p&gt;
&lt;p&gt;但是也可以通过注解的方式实现多例模式，使用@Scope(value=&amp;quot;prototype&amp;quot;)&lt;/p&gt;
&lt;p&gt;使用多例模式，在容器启动时不会创建bean，而在使用bean时才会去创建。&lt;/p&gt;
&lt;h3 id=&#34;aop代理可以是jdk动态代理或者cglib代理&#34;&gt;AOP代理可以是JDK动态代理或者CGLIB代理。&lt;/h3&gt;
&lt;p&gt;参考：https://blog.csdn.net/moreevan/article/details/11977115/&lt;/p&gt;
&lt;h3 id=&#34;cglib和jdk动态代理区别有哪些&#34;&gt;cglib和jdk动态代理区别有哪些&lt;/h3&gt;
&lt;p&gt;1、Jdk动态代理：利用拦截器（必须实现InvocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理&lt;/p&gt;
&lt;p&gt;2、 Cglib动态代理：利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理&lt;/p&gt;
&lt;p&gt;什么时候用cglib什么时候用jdk动态代理？&lt;/p&gt;
&lt;p&gt;1、目标对象生成了接口 默认用JDK动态代理&lt;/p&gt;
&lt;p&gt;2、如果目标对象使用了接口，可以强制使用cglib&lt;/p&gt;
&lt;p&gt;3、如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换&lt;/p&gt;
&lt;p&gt;JDK动态代理和cglib字节码生成的区别？&lt;/p&gt;
&lt;p&gt;1、JDK动态代理只能对实现了接口的类生成代理，而不能针对类&lt;/p&gt;
&lt;p&gt;2、Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法的增强，但是因为采用的是继承，所以该类或方法最好不要生成final，对于final类或方法，是无法继承的&lt;/p&gt;
&lt;p&gt;Cglib比JDK快？&lt;/p&gt;
&lt;p&gt;1、cglib底层是ASM字节码生成框架，但是字节码技术生成代理类，在JDL1.6之前比使用java反射的效率要高&lt;/p&gt;
&lt;p&gt;2、在jdk6之后逐步对JDK动态代理进行了优化，在调用次数比较少时效率高于cglib代理效率&lt;/p&gt;
&lt;p&gt;3、只有在大量调用的时候cglib的效率高，但是在1.8的时候JDK的效率已高于cglib&lt;/p&gt;
&lt;p&gt;4、Cglib不能对声明final的方法进行代理，因为cglib是动态生成代理对象，final关键字修饰的类不可变只能被引用不能被修改&lt;/p&gt;
&lt;h2 id=&#34;spring-bean&#34;&gt;Spring bean&lt;/h2&gt;
&lt;h3 id=&#34;spring-中的-bean-的作用域有哪些&#34;&gt;Spring 中的 bean 的作⽤域有哪些?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的。&lt;/li&gt;
&lt;li&gt;prototype : 每次请求都会创建⼀个新的 bean 实例。&lt;/li&gt;
&lt;li&gt;request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。&lt;/li&gt;
&lt;li&gt;session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。&lt;/li&gt;
&lt;li&gt;global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义，Spring5已经没有了。Portlet是能够⽣成语义代码(例如：HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spring-中的单例-bean-的线程安全问题了解吗&#34;&gt;Spring 中的单例 bean 的线程安全问题了解吗？&lt;/h3&gt;
&lt;p&gt;⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。&lt;br&gt;
&lt;strong&gt;常⻅的有两种解决办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;component-和-bean-的区别是什么&#34;&gt;@Component 和 @Bean 的区别是什么？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;作⽤对象不同: @&lt;strong&gt;Component 注解作⽤于类&lt;/strong&gt;，⽽ @&lt;strong&gt;Bean 注解作⽤于⽅法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;@Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还给我。&lt;/li&gt;
&lt;li&gt;@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;将一个类声明为spring的-bean-的注解有哪些&#34;&gt;将⼀个类声明为Spring的 bean 的注解有哪些?&lt;/h3&gt;
&lt;p&gt;我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。&lt;/li&gt;
&lt;li&gt;@Repository : 对应&lt;strong&gt;持久层&lt;/strong&gt;即 &lt;strong&gt;Dao&lt;/strong&gt; 层，主要⽤于数据库相关操作。&lt;/li&gt;
&lt;li&gt;@Service : 对应&lt;strong&gt;服务层&lt;/strong&gt;，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。&lt;/li&gt;
&lt;li&gt;@Controller : 对应 &lt;strong&gt;Spring MVC 控制层&lt;/strong&gt;，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring-中的-bean-生命周期&#34;&gt;Spring 中的 bean ⽣命周期&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqSOI.png&#34; alt=&#34;dqSOI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq0ND.png&#34; alt=&#34;dq0ND.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bean 容器找到配置⽂件中 Spring Bean 的定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传&lt;br&gt;
ClassLoader 对象的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执&lt;br&gt;
⾏ postProcessBeforeInitialization() ⽅法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执&lt;br&gt;
⾏ postProcessAfterInitialization() ⽅法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指&lt;br&gt;
定的⽅法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring Bean的生命周期分为&lt;code&gt;四个阶段&lt;/code&gt;和&lt;code&gt;多个扩展点&lt;/code&gt;。扩展点又可以分为&lt;code&gt;影响多个Bean&lt;/code&gt;和&lt;code&gt;影响单个Bean&lt;/code&gt;。整理如下：&lt;br&gt;
四个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化 Instantiation&lt;/li&gt;
&lt;li&gt;属性赋值 Populate&lt;/li&gt;
&lt;li&gt;初始化 Initialization&lt;/li&gt;
&lt;li&gt;销毁 Destruction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个扩展点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;影响多个Bean
&lt;ul&gt;
&lt;li&gt;BeanPostProcessor&lt;/li&gt;
&lt;li&gt;InstantiationAwareBeanPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;影响单个Bean
&lt;ul&gt;
&lt;li&gt;Aware
&lt;ul&gt;
&lt;li&gt;Aware Group1
&lt;ul&gt;
&lt;li&gt;BeanNameAware&lt;/li&gt;
&lt;li&gt;BeanClassLoaderAware&lt;/li&gt;
&lt;li&gt;BeanFactoryAware&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aware Group2
&lt;ul&gt;
&lt;li&gt;EnvironmentAware&lt;/li&gt;
&lt;li&gt;EmbeddedValueResolverAware&lt;/li&gt;
&lt;li&gt;ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生命周期
&lt;ul&gt;
&lt;li&gt;InitializingBean&lt;/li&gt;
&lt;li&gt;DisposableBean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例化 Instantiation&lt;/li&gt;
&lt;li&gt;属性赋值 Populate&lt;/li&gt;
&lt;li&gt;初始化 Initialization&lt;/li&gt;
&lt;li&gt;销毁 Destruction&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;实例化 -&amp;gt; 属性赋值 -&amp;gt; 初始化 -&amp;gt; 销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;createBeanInstance() -&amp;gt; 实例化&lt;/li&gt;
&lt;li&gt;populateBean() -&amp;gt; 属性赋值&lt;/li&gt;
&lt;li&gt;initializeBean() -&amp;gt; 初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;InstantiationAwareBeanPostProcessor作用于&lt;strong&gt;实例化&lt;/strong&gt;阶段的前后，BeanPostProcessor作用于&lt;strong&gt;初始化&lt;/strong&gt;阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqcEF.png&#34; alt=&#34;dqcEF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;InstantiationAwareBeanPostProcessor&lt;strong&gt;实际上继 承了&lt;/strong&gt;BeanPostProcessor接口&lt;/p&gt;
&lt;p&gt;InstantiationAwareBeanPostProcessor方法分析&lt;/p&gt;
&lt;p&gt;在InstantiationAwareBeanPostProcessor当中 postProcess&lt;strong&gt;Before&lt;/strong&gt;Instantiation方法	在&lt;strong&gt;doCreateBean之前&lt;/strong&gt;调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是&lt;strong&gt;Aop&lt;/strong&gt;等功能实现的关键点。&lt;/p&gt;
&lt;p&gt;之后执行&lt;strong&gt;populateBean&lt;/strong&gt; 也就是赋值阶段 continueWithPropertyPopulation 初始的boolean值为true&lt;/p&gt;
&lt;p&gt;postProcessAfterInstantiation方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为boolean，返回false时可以阻断属性赋值阶段 也就是说当实例化阶段之后还没完成的情况下是不能继续执行属性赋值&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;spring aop替换对象的时候并不在postProcessBefore&lt;strong&gt;Instantiation&lt;/strong&gt;替换对象，而是在 postProcess&lt;strong&gt;AfterInitialization&lt;/strong&gt;处理的&lt;/p&gt;
&lt;p&gt;一般情况下是在postProcessAfterInitialization替换代理类，自定义了TargetSource的情况下在postProcessBeforeInstantiation替换代理类。具体逻辑在AbstractAutoProxyCreator类中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aware接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如&lt;code&gt;BeanNameAware&lt;/code&gt;可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在&lt;strong&gt;初始化阶段之前调用&lt;/strong&gt;的！&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;initializeBean&lt;/strong&gt;方法中有一个&lt;strong&gt;invokeAwareMethods&lt;/strong&gt;方法 这个方法是在初始化bean的阶段之前完成的&lt;/p&gt;
&lt;p&gt;但是不是所有的Aware接口都使用同样的方式调用。Bean××Aware都是在代码中直接调用的，而ApplicationContext相关的Aware都是通过BeanPostProcessor#postProcessBeforeInitialization()实现的。&lt;/p&gt;
&lt;p&gt;之后BeanPostProcessor的调用机制就开始体现出来了 通过&lt;strong&gt;invokeInitMethod&lt;/strong&gt;方法的实现在 applyBeanPostProcessors&lt;strong&gt;BeforeInitialization&lt;/strong&gt; 和 applyBeanPostProcessors&lt;strong&gt;AfterInitialization&lt;/strong&gt; 之间进行完成&lt;/p&gt;
&lt;p&gt;参考连接：&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/1dec08d290c1&lt;/p&gt;
&lt;h2 id=&#34;applicationcontext和beanfactory的区别&#34;&gt;ApplicationContext和BeanFactory的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BeanFactory：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApplicationContext：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;国际化（MessageSource）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问资源，如URL和文件（ResourceLoader）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息发送、响应机制（ApplicationEventPublisher）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOP（拦截器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;两者装载bean的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BeanFactory：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApplicationContext：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们该用BeanFactory还是ApplicationContent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;延迟实例化的优点：（&lt;strong&gt;BeanFactory&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势；&lt;/p&gt;
&lt;p&gt;不延迟实例化的优点： （&lt;strong&gt;ApplicationContext&lt;/strong&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的Bean在启动的时候都加载，系统运行的速度快；&lt;/li&gt;
&lt;li&gt;在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题&lt;/li&gt;
&lt;li&gt;建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;https://blog.csdn.net/pythias_/article/details/82752881&lt;/p&gt;
&lt;h2 id=&#34;spring如何解决循环依赖问题&#34;&gt;spring如何解决循环依赖问题&lt;/h2&gt;
&lt;p&gt;简言之，两个池子：一个成品池子，一个半成品池子。能解决循环依赖的前提是：spring开启了allowCircularReferences，那么一个正在被创建的bean才会被放在半成品池子里。在注入bean，向容器获取bean的时候，优先向成品池子要，要不到，再去向半成品池子要。&lt;/p&gt;
&lt;p&gt;出现循环依赖一定是你的业务设计有问题。高层业务和底层业务的划分不够清晰，一般，业务的依赖方向一定是无环的，有环的业务，在后续的维护和拓展一定非常鸡肋&lt;/p&gt;
&lt;p&gt;参考连接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;https://blog.csdn.net/qq_41630866/article/details/104332517&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/chaitoudaren/article/details/105060882&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/likun557/article/details/113977261&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1497692&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://note.mxecy.cn/docs/%E5%9B%BE%E7%89%87/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E9%9D%A2%E8%AF%95%E7%89%88%EF%BC%89/Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://note.mxecy.cn/docs/%E5%9B%BE%E7%89%87/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E9%9D%A2%E8%AF%95%E7%89%88%EF%BC%89/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring使用了三级缓存 + 提前暴露对象的方式来解决循环依赖的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spring解决循环依赖的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出现循环依赖的Bean必须是单例的。&lt;/li&gt;
&lt;li&gt;依赖注入的方式不能全是构造器注入的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关的重要属性：位于&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;类中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring内部维护了三个Map，所谓的三重缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; singletonObjects
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;：单例池容器，用于缓存单例Bean的地方。一级缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里的bean是已经创建完成的，该bean经历过实例化-&amp;gt;属性填充-&amp;gt;初始化以及各类的后置处理。因此，一旦需要获取bean时，我们第一时间就会寻找一级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; earlySingletonObjects
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;：早期的单例Bean。二级缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里跟一级缓存的区别在于，该缓存所获取到的bean是提前曝光出来的，是还没创建完成的。也就是说获取到的bean只能确保已经进行了实例化，但是属性填充跟初始化肯定还没有做完，因此该bean还没创建完成，仅仅能作为指针提前曝光，被其他bean所引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;：创建中单例Bean的原始工厂。三级缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，spring会将实例化后的bean提前曝光，也就是把该bean转换成beanFactory并加入到三级缓存。在需要引用提前曝光对象时再通过singletonFactory.getObject()获取。&lt;/li&gt;
&lt;li&gt;当其他的bean从三级缓存中获取了Bean后，&lt;strong&gt;当前的Bean就会从三级缓存中放入到二级缓存&lt;/strong&gt;。并且从三级缓存中取出的时候会调用&lt;code&gt;SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation&lt;/code&gt;：保存了当前正在创建的单例对象的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Map&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; dependentBeanMap&lt;/code&gt;：保存了一个bean对其他的bean的依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一级缓存（singletonObjects）是用来缓存创建好的单例Bean的&lt;/li&gt;
&lt;li&gt;第二级缓存（earlySingletonObjects）是用来发现在当前Bean被暴露的时间里，有没有被其他Bean引用，如果被其他Bean引用，其他Bean又是引用的一个错误版本，就抛出一个异常。&lt;/li&gt;
&lt;li&gt;第三级缓存（singletonFactories），这个才是SP真正用来解决循环依赖的，并且可以延迟代理的时机。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// AbstractAutowireCapableBeanFactory#doCreateBean
/*忽略部分代码*/
// 创建实例包装
if (instanceWrapper == null) {
    instanceWrapper = createBeanInstance(beanName, mbd, args);
}
// 从实例包装后获取Bean
Object bean = instanceWrapper.getWrappedInstance();
/*忽略部分代码*/
if (earlySingletonExposure) {
    /*忽略部分代码*/
    // 如果允许暴露，则将其加入二级缓存。在调用被取出来的时候会调用SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference方法，默认实现只有AbstractAutoProxyCreator，创建代理。因此，如果在被暴露的过程中，有其他Bean调用getSingleton(当前对象)，则当前对象会被代理（如果有的话），然后放入二级缓存。
    addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
}
/*忽略部分代码*/
Object exposedObject = bean;
try {
    // 填充属性
    populateBean(beanName, mbd, instanceWrapper);
    // 实例化Bean，请注意这里，实例化Bean的时候可能会导致exposedObject的改变！！！
    exposedObject = initializeBean(beanName, exposedObject, mbd);
}
catch (Throwable ex) {
    /*忽略部分代码*/
}

if (earlySingletonExposure) {
    // 直接从二级缓存或一级缓存中获取Bean，注意，这里如果不为null，只有一种可能，在暴露出去的时间里，在其他Bean的初始化过程中调用了getSingleton(当前Bean)。
    Object earlySingletonReference = getSingleton(beanName, false);
    if (earlySingletonReference != null) {
        // 判断exposedObject在经过initializeBean后是否和原来的Bean是一个对象。
        if (exposedObject == bean) {
            // 如果bean没有在initializeBean改变，那么将当前Bean替换为代理后（如果有代理过的话）的Bean。
            exposedObject = earlySingletonReference;
        }
        else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
            /*忽略部分代码*/
            // 注意：到了这里，说明了一种情况，当前暴露出去的Bean（可能被代理过后）被其他Bean引用了，但是在实例化Bean的时候，Bean和暴露出去的Bean已经不是一个Bean的，即其他Bean引用的Bean是一个错误的Bean。因此如果有其他的Bean实际引用了当前Bean，则应该抛出一个异常。为什么是实际引用呢？因为这里可能其他Bean只是实现了Aware之类的接口，并在里面调用了getSingleton(当前Bean)，并没有实际引用。
        }
    }
}Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何解决循环依赖的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过提前曝光解决循环依赖，当AB循环依赖的时候，先将A的半成品曝光出去，让B先完成初始化，然后在使得初始化完成后的B注入到A中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要三级缓存：（&lt;strong&gt;以下为自己理解，不一定准确，事实上，添加三级缓存的地方的注释也标注了三级缓存是用来解决潜在的循环依赖的。&lt;/strong&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;很多博文说三级缓存是为了解决AOP的循环依赖，但事实上不是这样的，即使没有三级缓存，Spring也可以通过提前暴露代理对象的方法来解决AOP的循环依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以三级缓存的作用主要是：延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于代理过的对象，如果在被暴露出去的时候被其他的Bean所引用了，就会在从三级缓存中移除的时候创建代理；如果没有被引用的话，则在初始化Bean的时候创建代理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三级缓存作用：（三级缓存并非非要不可）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt;对Bean进行扩展。&lt;/li&gt;
&lt;li&gt;尽量可能的延迟AOP的初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://note.mxecy.cn/docs/%E5%9B%BE%E7%89%87/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E9%9D%A2%E8%AF%95%E7%89%88%EF%BC%89/%E5%9C%A8InstantiationBean%E4%B8%AD%E6%94%B9%E5%8F%98%E4%BA%86Bean.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// AbstractAutowireCapableBeanFactory#doCreateBean
// 忽略部分代码
if (earlySingletonExposure) {
    if (logger.isTraceEnabled()) {
        logger.trace(&amp;quot;Eagerly caching bean &#39;&amp;quot; + beanName +
                     &amp;quot;&#39; to allow for resolving potential circular references&amp;quot;);
    }
    // 添加三级缓存
    addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
}
// 忽略部分代码

// AbstractAutowireCapableBeanFactory#getEarlyBeanReference
protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
    Object exposedObject = bean;
    if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
        for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
            // 这里实现了getEarlyBeanReference的只有一个AbstractAutoProxyCreator.java
            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);
        }
    }
    return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-mvc&#34;&gt;Spring MVC&lt;/h2&gt;
&lt;h3 id=&#34;说说自己对于-spring-mvc-了解&#34;&gt;说说⾃⼰对于 Spring MVC 了解?&lt;/h3&gt;
&lt;p&gt;谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model1 时代 : 很多学 Java 后端⽐᫾晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；&lt;/li&gt;
&lt;li&gt;Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是⽤来展。Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐᫾笨重。随着 Spring 轻量级开发框架的流⾏，Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。MVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台⻚⾯)。&lt;/p&gt;
&lt;p&gt;SpringMVC ⼯作原理了解吗?&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqdu6.png&#34; alt=&#34;dqdu6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;流&lt;strong&gt;程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端（浏览器）发送请求，直接请求到 &lt;strong&gt;DispatcherServlet&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;DispatcherServlet 根据请求信息调⽤ &lt;strong&gt;HandlerMapping&lt;/strong&gt; ，解析请求对应的 &lt;strong&gt;Handler&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;解析到对应的 &lt;strong&gt;Handler&lt;/strong&gt; （也就是我们平常说的 &lt;strong&gt;Controller&lt;/strong&gt; 控制器）后，开始&lt;strong&gt;HandlerAdapter&lt;/strong&gt; 适配器处理。&lt;/li&gt;
&lt;li&gt;HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。&lt;/li&gt;
&lt;li&gt;处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt; 会根据逻辑 View 查找实际的 View 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DispaterServlet&lt;/strong&gt; 把返回的 Model 传给 View （视图渲染）。&lt;/li&gt;
&lt;li&gt;把 View 返回给请求者（浏览器）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spring-springmvc和springboot区别&#34;&gt;Spring SpringMVC和SpringBoot区别&lt;/h2&gt;
&lt;h3 id=&#34;一-概念&#34;&gt;一、概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Spring&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、SpringMVC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。SpringMVC是一种web层mvc框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等。SpringMVC是一个MVC的开源框架，SpringMVC=struts2+spring，springMVC就相当于是Struts2加上Spring的整合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、SpringBoot&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题—&amp;gt;习惯大于约定。&lt;/p&gt;
&lt;h3 id=&#34;二区别与总结&#34;&gt;二区别与总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.简单理解为：Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200920140600599.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1MjcwNjY3,size_1,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;2、关系大概就是这样：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring mvc &amp;lt; spring &amp;lt; springboot&lt;/p&gt;
&lt;h2 id=&#34;spring-框架中用到了哪些设计模式&#34;&gt;Spring 框架中⽤到了哪些设计模式&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;工厂设计模式&lt;/strong&gt;：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;代理设计模式&lt;/strong&gt;：Spring AOP功能的实现。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;单例设计模式&lt;/strong&gt;：Spring中的bean默认都是单例的。&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;模板方法模式&lt;/strong&gt;：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;包装器设计模式&lt;/strong&gt;：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;观察者模式&lt;/strong&gt;：Spring&lt;strong&gt;事件驱动模型&lt;/strong&gt;就是观察者模式很经典的一个应用。&lt;/p&gt;
&lt;p&gt;7.&lt;strong&gt;适配器模式&lt;/strong&gt;：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/fei1234456/article/details/106693892&lt;/p&gt;
&lt;h2 id=&#34;spring-事务&#34;&gt;Spring 事务&lt;/h2&gt;
&lt;h3 id=&#34;spring-管理事务的方式有几种&#34;&gt;Spring 管理事务的⽅式有⼏种？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编程式事务&lt;/strong&gt;，在代码中硬编码。(不推荐使⽤)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明式事务&lt;/strong&gt;，在配置⽂件中配置（推荐使⽤）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;声明式事务&lt;/strong&gt;⼜分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于&lt;strong&gt;XML&lt;/strong&gt;的声明式事务&lt;/li&gt;
&lt;li&gt;基于&lt;strong&gt;注解&lt;/strong&gt;的声明式事务 &lt;strong&gt;Transactional&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;spring-事务中的隔离级别有哪几种&#34;&gt;Spring 事务中的隔离级别有哪⼏种?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TransactionDefinition.I &lt;strong&gt;SOLATION_DEFAUL&lt;/strong&gt;T: 使⽤后端数据库默认的隔离级别，Mysql默认采⽤的 &lt;strong&gt;REPEATABLE_READ&lt;/strong&gt;隔离级别 Oracle 默认采⽤的 READ_COMMITTED隔离级别.&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spring-事务中哪几种事务传播行为&#34;&gt;Spring 事务中哪⼏种事务传播⾏为?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;⽀持当前事务的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不⽀持当前事务的情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其他情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transactionalrollbackfor-exceptionclass注解了解吗&#34;&gt;@Transactional(rollbackFor = Exception.class)注解了解吗？&lt;/h3&gt;
&lt;p&gt;我们知道：Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。&lt;/p&gt;
&lt;p&gt;当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。&lt;/p&gt;
&lt;p&gt;在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 &lt;strong&gt;RuntimeException 的时候才会回滚&lt;/strong&gt;,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也&lt;/p&gt;
&lt;h3 id=&#34;springboot和spring-mvc的区别是什么&#34;&gt;springboot和spring MVC的区别是什么&lt;/h3&gt;
&lt;p&gt;Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。&lt;/p&gt;
&lt;p&gt;所以，用最简练的语言概括就是：&lt;/p&gt;
&lt;p&gt;Spring 是一个“引擎”；&lt;/p&gt;
&lt;p&gt;Spring MVC 是基于Spring的一个 MVC 框架；&lt;/p&gt;
&lt;p&gt;Spring Boot 是基于Spring4的条件注册的一套快速开发整合&lt;/p&gt;
&lt;h2 id=&#34;jpa&#34;&gt;JPA&lt;/h2&gt;
&lt;h2 id=&#34;如何使用jpa在数据库中非持久化一个字段&#34;&gt;如何使⽤JPA在数据库中⾮持久化⼀个字段？&lt;/h2&gt;
&lt;p&gt;假如我们有有下⾯⼀个类：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqVFP.png&#34; alt=&#34;dqVFP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果我们想让 secrect 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采⽤下⾯⼏种⽅法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqYRb.png&#34; alt=&#34;dqYRb.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;spring线程安全问题&#34;&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43030522/article/details/107614334&#34;&gt;spring线程安全问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;spring 的 bean 的scope&lt;br&gt;
spring容器中管理的bean有五种作用域：&lt;br&gt;
1、&lt;strong&gt;singleton&lt;/strong&gt;：单例、也是默认的&lt;br&gt;
2、&lt;strong&gt;prototype&lt;/strong&gt;：原型，即每次需要该bean都会创建一个新的bean&lt;br&gt;
3、request：请求级别，即每次请求创建一个bean，适用于WebApplicationContext&lt;br&gt;
4、session：session会话级别，同一个session共享一个bean&lt;br&gt;
5、application：应用程序级别，同一个程序共享一个bean&lt;/p&gt;
&lt;p&gt;从单例与原型Bean,去说线程安全&lt;br&gt;
对于原型模式的Bean,每次都会创建一个新对象，也就是线程之间并不存在Bean共享，不会有线程安全的问题。&lt;br&gt;
对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。&lt;br&gt;
如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。&lt;br&gt;
&lt;strong&gt;比如spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;对于有状态的bean，spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法。&lt;/strong&gt;&lt;br&gt;
比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。&lt;br&gt;
使用ThreadLocal的好处是使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。这是一种以空间换时间的方式。&lt;/p&gt;
&lt;h2 id=&#34;spring中-单例模式和原型模式的区别&#34;&gt;spring中 单例模式和原型模式的区别&lt;/h2&gt;
&lt;p&gt;简单说来，单例就是用的一个对象。 原型就是拷贝的这个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例模式和原型模式多次调用hashcode相同么&lt;/strong&gt;&lt;br&gt;
单例模式多次调用hashcode是相同的。&lt;/p&gt;
&lt;p&gt;原型模式多次调用hashcode是不同的。&lt;/p&gt;
&lt;p&gt;如何在spring中验证原型模式hashcode不同&lt;br&gt;
在2个类中，分别注入一个原型模式的对象，打印hashcode就可以看出来。&lt;/p&gt;
&lt;p&gt;注： 一个类中是看不出来的，因为一个类中注入的时候只调用一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有个需求，当每次调用这个对象的时候，生成一个新日期，用bean的形式好么&lt;/strong&gt;&lt;br&gt;
这个要区分下情况。&lt;br&gt;
如果this.date=new Date(); 写在构造器里是不好用的，因为bean只加载一次。 这个new Date()只在spring创建对象的时候执行一次。 所以一直不变。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;br&gt;
可以把this.date=new Date(); 写在一个方法里，然后再返回该bean对象，方法每次调用都会执行一遍逻辑，所以date会变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型模式&lt;/strong&gt;&lt;br&gt;
存在一个对象，每次新建对象都是拷贝这个对象的属性值&lt;br&gt;
分为浅复制与深复制&lt;br&gt;
区别在于对象里面的引用类型对象属性是否是同一个&lt;/p&gt;
&lt;h2 id=&#34;jwt原理&#34;&gt;JWT原理&lt;/h2&gt;
&lt;p&gt;参考https://blog.csdn.net/lh_hebine/article/details/99695927&lt;/p&gt;
&lt;p&gt;JWT是为了在网络应用环境之间传递声明而执行的一种基于JSON 的开放标准&lt;/p&gt;
&lt;p&gt;JWT组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	声明类型&lt;/p&gt;
&lt;p&gt;​	加密算法&lt;/p&gt;
&lt;p&gt;再进行base加密得到第一部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;载荷&lt;/strong&gt; 用于存放有效的信息 不存放敏感的信息&lt;/p&gt;
&lt;p&gt;​	标准中注册的声明&lt;/p&gt;
&lt;p&gt;​	公共的声明&lt;/p&gt;
&lt;p&gt;​	私有的声明&lt;/p&gt;
&lt;p&gt;再进行base加密得到第二部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;签证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;header base加密后&lt;/p&gt;
&lt;p&gt;payload base加密后&lt;/p&gt;
&lt;p&gt;secret&lt;/p&gt;
&lt;p&gt;通过前两者的加密后字符串 再通过头部声明的加密算法进行加密组成第三部分&lt;/p&gt;
&lt;h2 id=&#34;jwt认证流程&#34;&gt;JWT认证流程&lt;/h2&gt;
&lt;p&gt;在前后端分离的项目中：前端将用户的登录信息发送给服务器；服务器接受请求后为用户生成独一无二的认证信息--token，传给客户端浏览器；客户端将token保存在cookie或者storage中；在之后访问客户端都携带这个token请求服务器；服务器验证token的值，如果验证成功则给客户端返回数据。服务器并不保存token。&lt;/p&gt;
&lt;h2 id=&#34;maven是怎样解决依赖冲突的&#34;&gt;maven是怎样解决依赖冲突的&lt;/h2&gt;
&lt;p&gt;用Maven Helper插件，在插件安装好之后，我们打开pom.xml文件，在底部会多出一个Dependency Analyzer选项&lt;/p&gt;
&lt;p&gt;点击 Dependency Analyzer，通过点击conflicts发现冲突，通过如下的方式在解决冲突；&lt;/p&gt;
&lt;h2 id=&#34;maven自动解决依赖冲突的规则是什么&#34;&gt;maven自动解决依赖冲突的规则是什么？&lt;/h2&gt;
&lt;h3 id=&#34;第一原则路径最近者优先&#34;&gt;第一原则：路径最近者优先&lt;/h3&gt;
&lt;p&gt;项目A有如下的依赖关系：&lt;/p&gt;
&lt;p&gt;A-&amp;gt;B-&amp;gt;C-&amp;gt;X(1.0)&lt;/p&gt;
&lt;p&gt;A-&amp;gt;D-&amp;gt;X(2.0)&lt;/p&gt;
&lt;p&gt;则该例子中，X的版本是2.0&lt;/p&gt;
&lt;h3 id=&#34;第二原则路径相等先声明者优先&#34;&gt;第二原则：路径相等，先声明者优先&lt;/h3&gt;
&lt;p&gt;项目A有如下的依赖关系：&lt;/p&gt;
&lt;p&gt;A-&amp;gt;B-&amp;gt;Y(1.0)&lt;/p&gt;
&lt;p&gt;A-&amp;gt;C-&amp;gt;Y(2.0)&lt;/p&gt;
&lt;p&gt;若pom文件中B的依赖坐标先于C进行声明，则最终Y的版本为1.0&lt;/p&gt;
">Spring</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/mybatis/"" data-c="
          &lt;h2 id=&#34;和的区别是什么&#34;&gt;#{}和${}的区别是什么？&lt;/h2&gt;
&lt;p&gt;1）#{}是预编译处理，$ {}是字符串替换。&lt;/p&gt;
&lt;p&gt;2）MyBatis在处理#{}时，会将SQL中的#{}替换为?号，使用&lt;strong&gt;PreparedStatement&lt;/strong&gt;的set方法来赋值；MyBatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。&lt;/p&gt;
&lt;p&gt;3）使用 #{} 可以有效的防止SQL注入，提高系统安全性。&lt;/p&gt;
&lt;p&gt;项目实战中使用,请阅读我博客中Java项目实战分类中的--&lt;a href=&#34;https://www.cnblogs.com/liaowenhui/p/12217400.html&#34;&gt;MySQL中in(&#39;5,6,7&#39;)只取第一个id为5对应的数据的思考&lt;/a&gt;一文，谢谢。&lt;/p&gt;
&lt;p&gt;要理解记忆这个题目,我觉得要抓住两点：&lt;/p&gt;
&lt;p&gt;（1）$ 符号一般用来当作占位符，常使用Linux脚本的同学应该对此有更深的体会吧。既然是占位符，当然就是被用来替换的。知道了这点就能很容易区分$和#，从而不容易记错了。&lt;/p&gt;
&lt;p&gt;（2）预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。在某些特殊场合下只能用${}，不能用#{}。例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。&lt;/p&gt;
&lt;h2 id=&#34;xml-映射文件中除了常的-selectinsertupdaedelete-标签之外还有哪些标签&#34;&gt;Xml 映射⽂件中，除了常⻅的 select|insert|updae|delete 标签之外，还有哪些标签？&lt;/h2&gt;
&lt;p&gt;答：还有很多其他的标签， &lt;resultMap&gt; 、 &lt;parameterMap&gt; 、 &lt;sql&gt; 、 &lt;include&gt; 、 &lt;selectKey&gt; ，加上动态 sql 的 9个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为 sql ⽚段标签，通过&lt;br&gt;
&lt;include&gt; 标签引⼊ sql ⽚段， &lt;selectKey&gt; 为不⽀持⾃增的主键⽣成策略标&lt;/p&gt;
&lt;h2 id=&#34;最佳实践中通常一个-xml-映射文件都会写一个-dao-接口与之对应请问这个-dao-接口的工作原理是什么dao-接口里的方法参数不同时方法能重载吗&#34;&gt;最佳实践中，通常⼀个 Xml 映射⽂件，都会写⼀个 Dao 接⼝与之对应，请问，这个 Dao 接⼝的⼯作原理是什么？Dao 接⼝⾥的⽅法，参数不同时，⽅法能重载吗？&lt;/h2&gt;
&lt;p&gt;Dao 接⼝，是⼈们常说的 Mapper 接⼝，接⼝的全限名，就是映射⽂件中的 namespace的值，接⼝的⽅法名，就是映射⽂件中 MappedStatement 的 id 值，接⼝⽅法内的参数，就是传递给 sql 的参数。 Mapper 接⼝是没有实现类的，当调⽤接⼝⽅法时，接⼝全限名+⽅法名拼接字符串作为 key 值，可唯⼀定位⼀个 MappedStatement ，举com.mybatis3.mappers.StudentDao.findStudentById ，可以唯⼀找到 namespace为 com.mybatis3.mappers.StudentDao 下⾯ id = findStudentById 的 MappedStatement 。在 Mybatis&lt;br&gt;
中，每⼀个 &lt;select&gt; 、 &lt;insert&gt; 、 &lt;update&gt; 、 &lt;delete&gt; 标签，都会被解析为⼀个 MappedStatement 对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dao 接⼝⾥的⽅法，是不能重载的，因为是全限名+⽅法名的保存和寻找策略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dao 接⼝的⼯作原理是 JDK 动态代理&lt;/strong&gt;，Mybatis 运⾏时会使⽤ JDK 动态代理为 Dao 接⼝⽣成代理 proxy 对象，代理对象 proxy 会拦截接⼝⽅法，转⽽执⾏ MappedStatement 所代表的 sql，然后将 sql 执⾏结果返回。&lt;/p&gt;
&lt;h2 id=&#34;mybatis工作流程&#34;&gt;Mybatis工作流程&lt;/h2&gt;
&lt;p&gt;1.通过SqlSessionFactoryBuilder创建SqlSessionFactory对象&lt;/p&gt;
&lt;p&gt;2.通过SqlSessionFactory创建SqlSession对象&lt;/p&gt;
&lt;p&gt;3.通过SqlSession拿到Mapper代理对象&lt;/p&gt;
&lt;p&gt;4.通过MapperProxy调用Mapper中增删改查的方法&lt;/p&gt;
&lt;p&gt;[参考](&lt;/p&gt;
">Mybatis</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/mysql/"" data-c="
          &lt;h2 id=&#34;关系型数据库和非关系型数据库的区别&#34;&gt;关系型数据库和非关系型数据库的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据存储结构&lt;/strong&gt;：&lt;br&gt;
首先关系型数据库一般都有固定的表结构，并且需要通过DDL语句来修改表结构，不是很容易进行扩展，而非关系型数据库的存储机制就有很多了，比如基于文档的，K-V键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方便扩展，因此如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择&lt;/p&gt;
&lt;p&gt;关系型数据库存储结构比较固定,不容易拓展&lt;/p&gt;
&lt;p&gt;非关系型数据库结构不固定，容易拓展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;&lt;br&gt;
传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等，而一些非关系型数据库则原生就支持数据的水平扩展(比如mongodb的sharding机制)，并且这可能也是很多NoSQL的一大卖点，其实象Mysql这种关系型数据库的水平扩展也并不是难，即使NoSQL水平扩展容易但对于向跨分片进行joins这种场景都没有什么太好的解决办法，不管是关系型还是非关系型数据库，解决水平扩展或者跨分片Joins这种场景，在应用层和数据库层中间加一层中间件来做数据处理也许是个好的办法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;&lt;br&gt;
关系型数据库一般强调的是数据最终一致性，而不没有像ACID一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么非关系型数据库并不一个很好的选择，非关系型数据库可能更多的偏向于OLAP场景，而关系型数据库更多偏向于OLTP场景&lt;/p&gt;
&lt;p&gt;关系型数据库强调数据的一致性&lt;/p&gt;
&lt;p&gt;非关系数据库不是很强调&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三大范式&#34;&gt;三大范式&lt;/h2&gt;
&lt;p&gt;第一范式是最基本的范式。如果数据库表中的所有&lt;strong&gt;字段值都是不可分解的原子值&lt;/strong&gt;，就说明该数据库表满足了第一范式。&lt;/p&gt;
&lt;p&gt;数据库第二范式：&lt;strong&gt;关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码&lt;/strong&gt;。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，姓名依赖于学号，而专业名称依赖于专业编号，不满足数据库第二范式&lt;/p&gt;
&lt;p&gt;数据库第三范式：&lt;strong&gt;关系模型满足第二范式&lt;/strong&gt;，所有非主属性对任何候选关键字都不存在传递依赖。即&lt;strong&gt;每个属性都跟主键有直接关系而不是间接关系&lt;/strong&gt;。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。&lt;/p&gt;
&lt;p&gt;第一范式：数据具&lt;strong&gt;有原子&lt;/strong&gt;性，不可再分。&lt;/p&gt;
&lt;p&gt;第二范式：不允许出现部分依赖，即不允许出现复合主键。&lt;/p&gt;
&lt;p&gt;第三范式：不存在传递依赖，即不允许出现某个字段依赖非主键。&lt;/p&gt;
&lt;h2 id=&#34;mysql的架构&#34;&gt;MySQL的架构&lt;/h2&gt;
&lt;p&gt;MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：负责和&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;，响应&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;请求，建立连接，返回数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑层&lt;/strong&gt;：包括SQK接口，解析器，优化器，Cache与buffer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库引擎层&lt;/strong&gt;：有常见的MyISAM,InnoDB等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;：负责文件存储，日志等等。&lt;/p&gt;
&lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;
&lt;h3 id=&#34;一些常用命令&#34;&gt;⼀些常⽤命令&lt;/h3&gt;
&lt;p&gt;查看MySQL提供的所有存储引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;show engines&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看MySQL当前默认的存储引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;show variables like &#39;%storage_engine&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看表的存储引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;show table status like &amp;quot;tablename&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;myisam和innodb区别&#34;&gt;MyISAM和InnoDB区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，⽽且提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和⾏级锁，⽽且最⼤的缺陷就是崩溃后⽆法安全恢复。不过，5.5版本之后，MySQL引⼊了&lt;strong&gt;InnoDB&lt;/strong&gt;（事务性数据库引擎），MySQL5.5版本后默认的存储引擎为&lt;strong&gt;InnoDB&lt;/strong&gt;。⼤多数时候我们使⽤的都是 &lt;strong&gt;InnoDB&lt;/strong&gt; 存储引擎，但是在某些情况下使⽤ MyISAM 也是合适的⽐如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两者对比&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;是&lt;strong&gt;否⽀持⾏级锁&lt;/strong&gt; : MyISAM 只有表级锁(table-level locking)，⽽InnoDB ⽀持⾏级锁(rowlevel locking)和表级锁,默认为⾏级锁。&lt;/p&gt;
&lt;p&gt;InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否⽀持事务和崩溃后的安全恢复&lt;/strong&gt;： MyISAM 强调的是性能，每次查询具有原⼦性,其执⾏速度⽐InnoDB类型更快，但是不提供事务⽀持。但是InnoDB 提供事务⽀持事务，外部键等⾼级数据库功能。 具有事务(commit)、回滚(rollback)和&lt;strong&gt;崩溃修复能⼒&lt;/strong&gt;(crashrecoverycapabilities)的事务安全(transaction-safe (ACID compliant))型表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否⽀持外键&lt;/strong&gt;： MyISAM不⽀持，⽽InnoDB⽀持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否⽀持MVCC&lt;/strong&gt; ：仅 InnoDB ⽀持。应对⾼并发事务, MVCC⽐单纯的加锁更⾼效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作;MVCC可以使⽤ 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统⼀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&lt;strong&gt;nnoDB是聚集索引&lt;/strong&gt;，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是&lt;strong&gt;辅助索引需要两次查询&lt;/strong&gt;，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。&lt;/p&gt;
&lt;p&gt;MyISAM是非聚集索引，也是使用B+Tree作为索引结构，&lt;strong&gt;索引和数据文件是分离&lt;/strong&gt;的，索引保存的是数据文件的&lt;strong&gt;指针&lt;/strong&gt;。主键索引和辅助索引是独立的。&lt;/p&gt;
&lt;p&gt;也就是说：InnoDB的B+树&lt;strong&gt;主键索引的叶子节点就是数据文件&lt;/strong&gt;，&lt;strong&gt;辅助索引的叶子节点是主键的值&lt;/strong&gt;；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdn.net/20180923094753224?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://img-blog.csdn.net/20180923094753230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	6.&lt;strong&gt;Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	7.&lt;strong&gt;MyISAM表格可以被压缩后进行查询操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	8.&lt;strong&gt;InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	9.&lt;strong&gt;Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Innodb：frm是表定义文件，ibd是数据文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Myisam：frm是表定义文件，myd是数据文件，myi是索引文件&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何在两者之间选择&#34;&gt;如何在两者之间选择&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；&lt;/li&gt;
&lt;li&gt;如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。&lt;/li&gt;
&lt;li&gt;系统奔溃后，MyISAM恢复起来更困难，能否接受；&lt;/li&gt;
&lt;li&gt;MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;innodb为什么推荐使用自增id作为主键&#34;&gt;InnoDB为什么推荐使用自增ID作为主键？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;innodb引擎的4大特性&#34;&gt;&lt;strong&gt;innodb引擎的4大特性&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入缓冲（insert buffer)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二次写(double write)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自适应哈希索引(ahi)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预读(read ahead)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;innodb如何保证事务的原子性-持久性和一致性&#34;&gt;InnoDB如何保证事务的原子性、持久性和一致性？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;undo log保障原子性&lt;/strong&gt;。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;redo log保证事务的持久性&lt;/strong&gt;，该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;undo log+redo log保障一致性&lt;/strong&gt;。事务中的执行需要redo log，如果执行失败，需要undo log 回滚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash索引和b树索引&#34;&gt;Hash索引和B+树索引&lt;/h3&gt;
&lt;p&gt;首先要知道Hash索引和B+树索引的底层实现原理:&lt;/p&gt;
&lt;p&gt;hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.&lt;/p&gt;
&lt;p&gt;B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.&lt;strong&gt;AAAA&lt;/strong&gt;和&lt;strong&gt;AAAAB&lt;/strong&gt;的索引没有相关性.&lt;/li&gt;
&lt;li&gt;hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.&lt;/li&gt;
&lt;li&gt;hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在&lt;strong&gt;大量重复&lt;/strong&gt;的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此,在大多数情况下,直接选择B+树索引可以获得&lt;strong&gt;稳定且较好&lt;/strong&gt;的查询速度.而不需要使用hash索引.&lt;/p&gt;
&lt;h3 id=&#34;为什么使用b树&#34;&gt;为什么使用B+树&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引&lt;/li&gt;
&lt;li&gt;很适合磁盘存储，能够充分利用&lt;strong&gt;局部性原理，磁盘预读&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;局部性原理&lt;/strong&gt;：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据预读&lt;/strong&gt;：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;很低的树高度，能够存储大量数据，同时能有效的减少IO操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引本身占用的内存很小&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;能够很好的支持&lt;strong&gt;单点查询，范围查询，有序性查询&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询效率稳定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;B+树存放数据数计算（https://blog.csdn.net/csdnlijingran/article/details/102309593）&lt;/li&gt;
&lt;li&gt;不用B树的原因是因为&lt;strong&gt;B树不支持范围查找&lt;/strong&gt;，B+树的范围查找只需要遍历叶子节点就行，而B树则需要中序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一颗b树能存多少数据&#34;&gt;一颗B+树能存多少数据&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/weixin_51867896/article/details/122799836&lt;/p&gt;
&lt;h2 id=&#34;字符集及校对规则&#34;&gt;字符集及校对规则&lt;/h2&gt;
&lt;p&gt;字符集指的是⼀种从⼆进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每⼀种字符集都会对应⼀系列的校对规则。&lt;/p&gt;
&lt;p&gt;MySQL采⽤的是类似继承的⽅式指定字符集的默认值，每个数据库以及每张数据表都有⾃⼰的默认值，他们逐层继承。⽐如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采⽤默认字符集）&lt;/p&gt;
&lt;h2 id=&#34;查询缓存的使用&#34;&gt;查询缓存的使⽤&lt;/h2&gt;
&lt;p&gt;执⾏查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实⽤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;my.cnf&lt;/strong&gt;加⼊以下配置，重启MySQL开启查询缓存&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;query_cache_size = 30M

query_cache_type=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MySQL执⾏以下命令也可以开启查询缓存&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqZTt.png&#34; alt=&#34;dqZTt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这⾥的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等⼀些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。&lt;/p&gt;
&lt;p&gt;此外，如果查询中包含任何⽤户⾃定义函数、存储函数、⽤户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。&lt;/p&gt;
&lt;p&gt;缓存建⽴之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发⽣变化，那么和这张表相关的所有缓存数据都将失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做⼀次缓存操作，失效后还要销毁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，开启缓存查询要谨慎，尤其对于写密集的应⽤来说更是如此。如果开启，要注意合理控制缓存空间⼤⼩，⼀般来说其⼤⼩设置为&lt;strong&gt;⼏⼗MB&lt;/strong&gt;比较合适。&lt;/p&gt;
&lt;p&gt;此外，还可以通过&lt;strong&gt;sql_cache和sql_no_cache&lt;/strong&gt;来控制某个查询语句是否需要缓存&lt;/p&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;h3 id=&#34;什么是事务&#34;&gt;什么是事务?&lt;/h3&gt;
&lt;p&gt;事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。&lt;/p&gt;
&lt;h3 id=&#34;事物的四大特性acid&#34;&gt;事物的四⼤特性(ACID)&lt;/h3&gt;
&lt;p&gt;1**.原⼦性（Atomicity**）： 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么	全部完成，要么完全不起作⽤；&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;⼀致性（Consistency）&lt;/strong&gt;： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性（Durability&lt;/strong&gt;）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;并发事务带来哪些问题&#34;&gt;并发事务带来哪些问题?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;脏读(Dirty read&lt;/strong&gt;): 当一个事务正在访问数据并且对数据进行了修改,而这种修改还没有提 交到数据库中,这时另外一个事务也访问了这个数据,然后使用了这个数据。因为这个数据 是还没有提交的数据,那么另外一个事务读到的这个数据是“脏数据”,依据“脏数据”所做的 操作可能是不正确的。&lt;strong&gt;一改一读&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丢失修改(Lost to modify)&lt;/strong&gt;: 指在一个事务读取一个数据时,另外一个事务也访问了该数 据,那么在第一个事务中修改了这个数据后,第二个事务也修改了这个数据。这样第一个事 务内的修改结果就被丢失,因此称为丢失修改。 例如:事务1读取某表中的数据A=20,事 务2也读取A=20,事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19,事务1的修改被丢失。&lt;strong&gt;两个改&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读(Unrepeatable read):&lt;/strong&gt; 指在一个事务内多次读同一数据。在这个事务还没有结 束时,另一个事务也访问该数据。那么,在第一个事务中的两次读数据之间,由于第二个事 务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到 的数据是不一样的情况,因此称为不可重复读。&lt;strong&gt;一改一读&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读(Phantom read)&lt;/strong&gt;: 幻读与不可重复读类似。它发 生在一个事务(T1)读取了几行数 据,接着另一个并发事务(T2)插入了一些数据时。在随后的查询中,第一个事务(T1) 就会发现多了一些原本不存在的记录,就好像发生了幻觉一样,所以称为幻读。&lt;strong&gt;一改一读&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不可重复读的重点&lt;/strong&gt;是修改比如多次读取一条记录发现其中某些列的值被修改,幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读的问题存在&lt;/strong&gt;是因为新增或者更新操作，这时如果进&lt;strong&gt;行范围查询的时候&lt;/strong&gt;（加锁查询），会出现不一致的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务隔离级别有哪些mysql的默认隔离级别是&#34;&gt;事务隔离级别有哪些?MySQL的默认隔离级别是?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;READ-UNCOMMITTED(&lt;strong&gt;读取未提交&lt;/strong&gt;)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个事务还没提交，它做的变更就能被别的事务看到&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;READ-COMMITTED(&lt;strong&gt;读取已提交&lt;/strong&gt;)： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个事务提交后，它做的变更才能被别的事务看到&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REPEATABLE-READ(&lt;strong&gt;可重复读&lt;/strong&gt;)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SERIALIZABLE(&lt;strong&gt;可串⾏化&lt;/strong&gt;)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqvvx.png&#34; alt=&#34;dqvvx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL InnoDB 存储引擎的&lt;strong&gt;默认&lt;/strong&gt;⽀持的隔离级别是 &lt;strong&gt;REPEATABLE-READ（可重读&lt;/strong&gt;）.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SELECT @@tx_isolation&lt;/strong&gt;查看支持的默认的隔离级别&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqmOp.png&#34; alt=&#34;dqmOp.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这⾥需要注意的是：与 SQL 标准不同的地⽅在于 InnoDB 存储引擎在 &lt;strong&gt;REPEATABLE-READ（可重读）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务隔离级别下使⽤的是&lt;strong&gt;Next-Key Lock 锁算法，因此可以避免幻读的产⽣&lt;/strong&gt;，这与其他数据库系统(如 SQL Server)是不同的。&lt;/p&gt;
&lt;p&gt;所以说InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了SQL标准的 SERIALIZABLE(可串⾏化) 隔离级别。&lt;/p&gt;
&lt;p&gt;因为隔离级别越低，事务请求的锁越少，所以⼤部分数据库系统的隔离级别都READCOMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使⽤ REPEAaTABLE-READ（可重读） 并不会有任何性能损失。&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎在 &lt;strong&gt;分布式事务&lt;/strong&gt; 的情况下⼀般会⽤到 &lt;strong&gt;SERIALIZABLE(可串⾏化)&lt;/strong&gt; 隔离级别。&lt;/p&gt;
&lt;h3 id=&#34;可重复读的实现原理&#34;&gt;可重复读的实现原理&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Repeatable Read&lt;/em&gt;（可重复读）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录（读已经提交的，其实是读早于本事务开始且已经提交的），&lt;strong&gt;但是不能看到其他事务对已有记录的更新（即晚于本事务开始的）&lt;/strong&gt;，并且，该事务不要求与其他事务是“可串行化”的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的来说就是当前事务在堆当前的某条数据在其他事务的影响下重读的结果是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用MVCC（多版本并发控制）。&lt;strong&gt;InnoDB为每行记录添加了一个版本号（系统版本号&lt;/strong&gt;），每当修改数据时，版本号加一。&lt;br&gt;
在读取事务开始时，系统会给事务一个当前版本号，&lt;strong&gt;事务会读取版本号&amp;lt;=当前版本号的数&lt;/strong&gt;据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。&lt;/p&gt;
&lt;p&gt;InnoDB 的可重复读的实现，利用了实现 MVCC 技术的快照技术。这是 MVCC 和基于封锁技术这两个并非控制技术的结合之处。&lt;/p&gt;
&lt;p&gt;在&lt;em&gt;RR&lt;/em&gt;隔离级别下为事务设置了一个“一致性读视图（即快照）”，之后读取数据，就是根据这个快照来获取，这样，就不能看到他晚于本事务的事务对已有记录的更新（更新生成新版本，必然不在旧的快照所限定的范围内）。&lt;/p&gt;
&lt;p&gt;根据隔离级别判断是不是要使用一个新的快照，如果是可重复读，则不使用新快照，沿用老的快照，这样就能保证所有的读操作看到的是同一个数据状态；同时也确保了读已提交隔离级别下一个事务块内的不同语句的读操作看到的不是同一个数据状态。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;参考 https://blog.csdn.net/huanghanqian/article/details/79517480&lt;/p&gt;
&lt;h2 id=&#34;mysql锁&#34;&gt;Mysql锁&lt;/h2&gt;
&lt;p&gt;按锁粒度分类：&lt;br&gt;
1. ⾏锁：锁某⾏数据，锁粒度最⼩，并发度⾼&lt;br&gt;
2. 表锁：锁整张表，锁粒度最⼤，并发度低&lt;br&gt;
3. &lt;strong&gt;间隙锁&lt;/strong&gt;：锁的是⼀个区间&lt;/p&gt;
&lt;p&gt;还可以分为：&lt;br&gt;
1. 共享锁：也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写&lt;br&gt;
2. 排它锁：也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写&lt;/p&gt;
&lt;p&gt;还可以分为：&lt;br&gt;
1. 乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的&lt;br&gt;
2. 悲观锁：上⾯所的⾏锁、表锁等都是悲观锁&lt;/p&gt;
&lt;p&gt;在事务的隔离级别实现中，就需要利⽤锁来解决幻读&lt;/p&gt;
&lt;h3 id=&#34;锁机制与innodb锁算法&#34;&gt;锁机制与InnoDB锁算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MyISAM和InnoDB存储引擎使⽤的锁：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM采⽤表级锁(table-level locking)。&lt;/li&gt;
&lt;li&gt;InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;表级锁和⾏级锁对⽐：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表级锁： MySQL中锁定 &lt;strong&gt;粒度最⼤&lt;/strong&gt; 的⼀种锁，对当前操作的整张表加锁，实现简单，资源消&lt;br&gt;
耗也比较少，加锁快，不会出现死锁。其锁定粒度最⼤，触发锁冲突的概率最⾼，并发度最&lt;br&gt;
低，MyISAM和 InnoDB引擎都⽀持表级锁。&lt;/li&gt;
&lt;li&gt;⾏级锁： MySQL中锁定 &lt;strong&gt;粒度最⼩&lt;/strong&gt; 的⼀种锁，只针对当前操作的⾏进⾏加锁。 ⾏级锁能⼤&lt;br&gt;
⼤减少数据库操作的冲突。其加锁粒度最⼩，并发度⾼，但加锁的开销也最⼤，加锁慢，会&lt;br&gt;
出现死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InnoDB存储引擎的锁的算法有三种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Record lock：&lt;strong&gt;单个⾏记录上的锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Gap lock：&lt;strong&gt;间隙锁，锁定⼀个范围，不包括记录本身 目的是为了防止同一个事物的两次当前读，出现幻读的情况&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Next-key lock：&lt;strong&gt;record+gap 锁定⼀个范围，包含记录本身&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;相关知识点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;innodb对于⾏的查询使⽤next-key lock&lt;/li&gt;
&lt;li&gt;Next-locking keying为了解决Phantom Problem幻读问题&lt;/li&gt;
&lt;li&gt;当查询的索引含有唯⼀属性时，将next-key lock降级为record key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gap锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内，⽽这会导致幻读问题的产⽣&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;有两种⽅式显式关闭gap锁：（除了外键约束和唯⼀性检查外，其余情况仅使⽤recordlock）  不推荐
&lt;ol&gt;
&lt;li&gt;将事务隔离级别设置为RC(可重复读)&lt;/li&gt;
&lt;li&gt;将参数innodb_locks_unsafe_for_binlog设置为1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;间隙锁死锁&#34;&gt;间隙锁死锁&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/java_beautiful/article/details/125572280&lt;/p&gt;
&lt;h3 id=&#34;mysql中的按粒度的锁分类&#34;&gt;MySQL中的按粒度的锁分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next-key Lock： 行锁+gap锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何解决数据库死锁&#34;&gt;如何解决数据库死锁&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;预先检测到死锁的循环依赖，并立即返回一个错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当查询的时间达到锁等待超时的设定后放弃锁请求&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解释一下什么是池化设计思想-什么是数据库连接池-为什么需要数据库连接池&#34;&gt;解释⼀下什么是池化设计思想 什么是数据库连接池 为什么需要数据库连接池&lt;/h2&gt;
&lt;p&gt;池化设计应该不是⼀个新名词。我们常⻅的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。&lt;/p&gt;
&lt;p&gt;这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好⽐你去⻝堂打饭，打饭的⼤妈会先把饭盛好⼏份放那⾥，你来了就直接拿着饭盒加菜即可，不⽤再临时⼜盛饭⼜打菜，效率就⾼了。&lt;/p&gt;
&lt;p&gt;除了初始化资源，池化设计还包括如下这些特征：池⼦的初始值、池⼦的活跃值、池⼦的最⼤值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库连接本质就是⼀个 socket 的连接&lt;/strong&gt;。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的 所以占⽤了⼀些内存。我们可以把数据库连接池是看做是&lt;strong&gt;维护的数据库连接的缓存&lt;/strong&gt;，以便将来需要对数据库的请求时可以重⽤这些连接。为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的⽹站应⽤程序的请求，既昂贵⼜浪费资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在连接池中，创建连接后，将其放置在池&lt;/strong&gt;中，&lt;strong&gt;并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中&lt;/strong&gt;。 连接池还减少了⽤户必须等待建⽴与数据库的连接的时间。&lt;/p&gt;
&lt;h2 id=&#34;分库分表之后id-主键如何处理&#34;&gt;分库分表之后,id 主键如何处理&lt;/h2&gt;
&lt;p&gt;因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要⼀个全局唯⼀的id 来⽀持。&lt;br&gt;
&lt;strong&gt;⽣成全局 id 有下⾯这⼏种⽅式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UUID&lt;/strong&gt;：不适合作为主键，因为太⻓了，并且⽆序不可读，查询效率低。比较适合⽤于⽣成唯⼀的名字的标示⽐如⽂件的名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据库⾃增 id&lt;/strong&gt; : 两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利⽤ redis ⽣成 id&lt;/strong&gt; : 性能比较好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Twitter的snowflake算法&lt;/strong&gt; ：Github 地址：https://github.com/twitter-archive/snowflake。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;美团的Leaf分布式ID⽣成系统&lt;/strong&gt; ：Leaf 是美团开源的分布式ID⽣成器，能保证全局唯⼀性、趋势递增、单调递增、信息安全，⾥⾯也提到了⼏种分布式⽅案的对⽐，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;美团技术团队的⼀篇⽂章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一条sql语句执行得很慢的原因有哪些&#34;&gt;⼀条SQL语句执⾏得很慢的原因有哪些&lt;/h2&gt;
&lt;p&gt;参考连接：https://www.cnblogs.com/kubidemanong/p/10734045.html&lt;/p&gt;
&lt;p&gt;1、大多数情况下很正常，&lt;strong&gt;偶尔很慢&lt;/strong&gt;，则有如下原因&lt;/p&gt;
&lt;p&gt;(1)、&lt;strong&gt;数据库在刷新脏页&lt;/strong&gt;，例如 redo log 写满了需要同步到磁盘。&lt;/p&gt;
&lt;p&gt;(2)、&lt;strong&gt;执行的时候&lt;/strong&gt;，&lt;strong&gt;遇到锁&lt;/strong&gt;，如表锁、行锁。&lt;/p&gt;
&lt;p&gt;2、这条 SQL 语句一直执行的很慢，则有如下原因。&lt;/p&gt;
&lt;p&gt;(1)、&lt;strong&gt;没有用上索引&lt;/strong&gt;：例如该字段没有索引导致走全表扫描；由于对字段进行运算（select * from t where c - 1 = 1000;）、函数操作（pow(c,2) = 1000;）导致无法用索引。&lt;/p&gt;
&lt;p&gt;(2)、&lt;strong&gt;数据库选错了索引&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;
&lt;h3 id=&#34;mysql有哪些常见索引类型&#34;&gt;Mysql有哪些常见索引类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据结构角度&lt;/p&gt;
&lt;p&gt;B-Tree索引&lt;/p&gt;
&lt;p&gt;哈希索引&lt;/p&gt;
&lt;p&gt;R-Tree索引&lt;/p&gt;
&lt;p&gt;全文索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物理存储角度&lt;/p&gt;
&lt;p&gt;主键索引（聚簇索引）：叶子节点存的是整行的数据&lt;/p&gt;
&lt;p&gt;非主键索引（二级索引）：叶子节点存的主键的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢&#34;&gt;&lt;strong&gt;在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用不等于查询,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不匹配最左前缀原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列参与了数学运算或者函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在字符串like时左边是通配符.类似于&#39;%aaa&#39;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当mysql分析&lt;strong&gt;全表扫描比使用索引快的时候不使用索引&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引&lt;/p&gt;
&lt;p&gt;参考https://blog.csdn.net/c1776167012/article/details/120788728&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述hash索引&#34;&gt;简述Hash索引&lt;/h3&gt;
&lt;p&gt;哈希索引对于&lt;strong&gt;每一行数据计算一个哈希码&lt;/strong&gt;，&lt;strong&gt;并将所有的哈希码存储在索引中&lt;/strong&gt;，同时在哈希表中保存指向每个数据行的指针。只有 Memory 引擎显式支持哈希索引。&lt;/p&gt;
&lt;p&gt;Hash索引&lt;strong&gt;不支持范围查询&lt;/strong&gt;，无法用于&lt;a href=&#34;&#34;&gt;排序&lt;/a&gt;，也不支持部分索引列匹配查找。&lt;/p&gt;
&lt;h3 id=&#34;简述自适应hash索引&#34;&gt;简述自适应Hash索引&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;简述聚集索引和稀疏索引&#34;&gt;简述聚集索引和稀疏索引&lt;/h3&gt;
&lt;p&gt;聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。&lt;/p&gt;
&lt;p&gt;稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们&lt;strong&gt;首先按索引记录进行操作&lt;/strong&gt;，并按顺序搜索，直到找到所需的数据为止。&lt;/p&gt;
&lt;h3 id=&#34;简述辅助索引与回表查询&#34;&gt;简述辅助索引与回表查询&lt;/h3&gt;
&lt;p&gt;辅助索引是非聚集索引，叶子节点不包含记录的全部数据，&lt;strong&gt;包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为&lt;strong&gt;回表查询&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;简述联合索引和最左匹配原则&#34;&gt;简述联合索引和最左匹配原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;联合索引是指对表上的多个列的关键词进行索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到遇到范围查询（&amp;lt;,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。&lt;/p&gt;
&lt;p&gt;参考：https://blog.csdn.net/sinat_41917109/article/details/88944290&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqpNU.png&#34; alt=&#34;dqpNU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;简述覆盖索引&#34;&gt;简述覆盖索引&lt;/h3&gt;
&lt;p&gt;**覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，**不需要回表查询，即索引本身存了对应的值。&lt;/p&gt;
&lt;h3 id=&#34;基于主键索引的查询和非主键索引的查询有什么区别&#34;&gt;基于主键索引的查询和非主键索引的查询有什么区别？&lt;/h3&gt;
&lt;p&gt;对于select * from 主键=XX，基于主键的普通查询仅查找主键这棵树&lt;/p&gt;
&lt;p&gt;对于select * from 非主键=XX，基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表）&lt;strong&gt;，因为非主键索引叶子节点仅存主键值，无整行全部信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;非主键索引的查询一定会回表吗&#34;&gt;非主键索引的查询一定会回表吗？&lt;/h3&gt;
&lt;p&gt;不一定，当查询语句的要求字段全部命中索引，不用回表查询。&lt;strong&gt;如select 主键 from 非主键=XX，此时非主键索引叶子节点即可拿到主键信息，不用回表。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么数据库不用红黑树-用b树&#34;&gt;为什么数据库不用红黑树 用B+树&lt;/h2&gt;
&lt;p&gt;红黑树的出度为 2，而 B Tree 的出度一般都非常大**。红黑树的树高 h 很明显比 B Tree 大非常多，IO次数很多，导致会比较慢，因此检索的次数也就更多**。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度&lt;/strong&gt;，IO次数较少，检索效率会更高。&lt;/p&gt;
&lt;h3 id=&#34;创建的索引有没有被使用到或者说怎么才可以知道这条语句运行很慢的原因&#34;&gt;&lt;strong&gt;创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MySQL提供了&lt;strong&gt;explain&lt;/strong&gt;命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. &lt;strong&gt;可以通过其中和索引有关的信息来分析是否命中了索引&lt;/strong&gt;,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.&lt;/p&gt;
&lt;h3 id=&#34;主键索引和唯一索引的区别&#34;&gt;主键索引和唯一索引的区别&lt;/h3&gt;
&lt;p&gt;1.主键为一种约束，唯一索引为一种索引，本质上就不同；&lt;/p&gt;
&lt;p&gt;2.主键创建后一定包含唯一性索引，而唯一索引不一定就是主键；&lt;/p&gt;
&lt;p&gt;3.主键不允许空值，唯一索引可以为空；&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;主键可以被其他表引用，而唯一索引不可以&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;5.一个表最多只能创建一个主键，而可以创建多个唯一索引；&lt;/p&gt;
&lt;p&gt;6.主键和索引都是键，&lt;strong&gt;主键是逻辑键&lt;/strong&gt;，索引为物理键，即主键不实际存在。&lt;/p&gt;
&lt;h2 id=&#34;简述mysql使用explain-的关键字段&#34;&gt;简述MySQL使用EXPLAIN 的关键字段&lt;/h2&gt;
&lt;p&gt;explain关键字用于分析sql语句的执行情况，可以通过他进行sql语句的性能分析。&lt;/p&gt;
&lt;p&gt;type：表示连接类型，从好到差的类型&lt;a href=&#34;&#34;&gt;排序&lt;/a&gt;为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system：系统表，数据已经加载到内存里。&lt;/li&gt;
&lt;li&gt;const：常量连接，通过索引一次就找到。&lt;/li&gt;
&lt;li&gt;eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。&lt;/li&gt;
&lt;li&gt;ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。&lt;/li&gt;
&lt;li&gt;range：范围扫描，在索引上扫码特定范围内的值。&lt;/li&gt;
&lt;li&gt;index：索引树扫描，扫描索引上的全部数据。&lt;/li&gt;
&lt;li&gt;all：全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;key：显示MySQL实际决定使用的键。&lt;/p&gt;
&lt;p&gt;key_len：显示MySQL决定使用的键长度，长度越短越好&lt;/p&gt;
&lt;p&gt;Extra：额外信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using filesort：MySQL使用外部的索引&lt;a href=&#34;&#34;&gt;排序&lt;/a&gt;，很慢需要优化。&lt;/li&gt;
&lt;li&gt;Using temporary：使用了临时表保存中间结果，很慢需要优化。&lt;/li&gt;
&lt;li&gt;Using index：使用了覆盖索引。&lt;/li&gt;
&lt;li&gt;Using where：使用了where。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql插入数据的流程&#34;&gt;MySQL插入数据的流程&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/zhaoliang831214/article/details/82711350&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/weixin_40581617/article/details/80623276&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;会话状态转换为update&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;激活事物状态由 not_active 变为 active&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找定位数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进行乐观插入&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mysql语句执行流程&#34;&gt;Mysql语句执行流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接器：&lt;/strong&gt; 身份认证和权限相关(登录 MySQL 的时候)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查询缓存:&lt;/strong&gt; 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析器&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一步，词法分析&lt;/strong&gt;，一条 SQL 语句有多个字符串组成，首先要&lt;strong&gt;提取关键字&lt;/strong&gt;，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二步，语法分析&lt;/strong&gt;，主要就是&lt;strong&gt;判断你输入的 sql 是否正确&lt;/strong&gt;，是否符合 MySQL 的语法。完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优化器&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;按照 MySQL 认为最优的方案去执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://zhuanlan.zhihu.com/p/192707721&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 会帮我去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IO 成本&lt;/strong&gt;: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 成本&lt;/strong&gt;：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行器:&lt;/strong&gt; 执行语句，然后从存储引擎返回数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://note.mxecy.cn/docs/%E5%9B%BE%E7%89%87/MySql/Mysql%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;首先通过连接器进行&lt;strong&gt;身份认证和权限相关&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果是执行查询语句的时候，&lt;strong&gt;会先查询缓存&lt;/strong&gt;，但MySQL 8.0 版本后该步骤移除。&lt;/li&gt;
&lt;li&gt;没有命中缓存的话，&lt;strong&gt;SQL 语句就会经过解析器，分析语句，包括语法检查等等&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;优化器&lt;/strong&gt;，将用户的SQL语句按照 MySQL 认为最优的方案去执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行语句&lt;/strong&gt;，并从存储引擎返回数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简述mysql优化流程&#34;&gt;简述MySQL优化流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;慢日志&lt;/strong&gt;定位执行较慢的SQL语句  HOW VARIABLES LIKE &#39;%query%&#39;   查询慢日志相关信息&lt;/li&gt;
&lt;li&gt;利用&lt;strong&gt;explain对这些关键字段进行分析&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据分析结果进行优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sql执行顺序&#34;&gt;SQL执行顺序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 语法顺序
select distinct 
        &amp;lt;select_list&amp;gt;
from
    &amp;lt;left_table&amp;gt;&amp;lt;join_type&amp;gt;
join &amp;lt;right_table&amp;gt; on &amp;lt;join_condition&amp;gt;
where
    &amp;lt;where_condition&amp;gt;
group by
    &amp;lt;group_by_list&amp;gt;
having
    &amp;lt;having_condition&amp;gt;
order by
    &amp;lt;order_by_condition&amp;gt;
limit &amp;lt;limit number&amp;gt;


-- 执行顺序
1、from &amp;lt;left_table&amp;gt;&amp;lt;join_type&amp;gt;
2、on &amp;lt;join_condition&amp;gt;
3、&amp;lt;join_type&amp;gt; join &amp;lt;right_table&amp;gt;
4、where &amp;lt;where_condition&amp;gt;
5、group by &amp;lt;group_by_list&amp;gt;
6、having &amp;lt;having_condition&amp;gt;
7、select
8、distinct &amp;lt;select_list&amp;gt;
9、order by &amp;lt;order_by_condition&amp;gt;
10、limit &amp;lt;limit_number&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本优化&#34;&gt;基本优化&lt;/h2&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247485117&amp;amp;idx=1&amp;amp;sn=92361755b7c3de488b415ec4c5f46d73&amp;amp;chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&amp;amp;token=79317275&amp;amp;lang=zh_CN%23rd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类型选择：选择能够满足业务需求的最小数据类型。同时对于数值类型，如果没有负数，则使用&lt;code&gt;unsigned&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只查询一条记录，如是否存在，需要加上&lt;code&gt;limit&lt;/code&gt;阻断后续的查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止使用 SELECT * 必须使用 SELECT &amp;lt;字段列表&amp;gt; 查询统计所有 count（*）会统计值为NULL的行，而count（列名）不会统计值为NULL的行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主键外键约束在&lt;strong&gt;应用层解决&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O&lt;strong&gt;R改写成IN&lt;/strong&gt;：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量避免在WHERE子句中使用!=或&amp;lt; &amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描 &amp;lt;&amp;gt;等价于!=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单表数据保持在500w以内，如果大了就进行分表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;禁止数据库中存储图片，图片等二进制数据&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;尽可能把所有列定义为 NOT NULL&lt;/strong&gt;：&lt;strong&gt;索引 NULL 列需要额外的空间来保存&lt;/strong&gt;，所以要占用更多的空间进行比较和计算时要对 NULL 值做特别的处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;财务相关数据使用decimal类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单表索引不要超过5个&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;禁止给表的每一列建立单独的索引&lt;/strong&gt;。使用联合索引代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立联合索引&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将区分度高的放在最左侧。（区分度=列中不同值的数量/列的总行数）&lt;/li&gt;
&lt;li&gt;尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）&lt;/li&gt;
&lt;li&gt;使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免使用子查询，可以把子查询优化为 join 操作&lt;/strong&gt;：通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用 JOIN 关联太多的表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WHERE 从句中禁止对列进行函数转换和计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大批量操作可能会造成严重的主从延迟&lt;/strong&gt;：主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;binlog 日志为 row 格式时会产生大量的日志&lt;/strong&gt;：大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免产生大事务操作&lt;/strong&gt;：大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将or条件改写成&lt;code&gt;union all&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将&lt;code&gt;xx is not null&lt;/code&gt;改写成&lt;code&gt;ifnull((xx,0) &amp;gt; 0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;少用内联子查询（select后有子查询），因为Sql返回多少行，内联子查询就要执行多少次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于成本的优化器CBO对子查询的处理能力比较弱，可以使用inner join&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;limit&#34;&gt;Limit&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原因：Limit分页时，如&lt;code&gt;limit offset, size&lt;/code&gt;会扫描前&lt;code&gt;offset + size&lt;/code&gt;行，然后去掉前面的&lt;code&gt;offset&lt;/code&gt;行，返回最后的&lt;code&gt;size&lt;/code&gt;行。当&lt;code&gt;offset&lt;/code&gt;过大的时候，或者有&lt;code&gt;where&lt;/code&gt;条件的时候会走全表查询。效率极低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用&lt;strong&gt;覆盖索引&lt;/strong&gt;进行优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM tableName
WHERE id &amp;gt;= (SELECT id FROM tableName ORDER BY id LIMIT 500000 , 1)
LIMIT 2;
-- 其中，id为主键，在子查询中，只查询了id，因此可以利用覆盖索引查询出第500000的id的位置（不用回表查询）。然后通过id走索引会表查询出数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;like&#34;&gt;Like&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原因：&lt;strong&gt;因为B+树的最左前缀匹配。导致全模糊查询以及左模糊查询无法生效。会触发全表查询。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;利用覆盖索引优化&lt;/strong&gt;（同上，在要模糊的字段上加索引，减少回表查询）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;explain select * from tableName where id in (select id FROM tableName where name like &amp;quot;%searchKey%&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;干掉左边的模糊匹配：&lt;a href=&#34;https://jeffkemponoracle.com/2008/01/like-with-wildcard-at-start-can-use-an-index/&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用全文索引（建立全文索引 + ES分词）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM tableName WHERE MATCH(`name`) AGAINST(&#39;searchKey&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;大表优化&#34;&gt;大表优化&lt;/h3&gt;
&lt;p&gt;当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;限制数据范围&lt;/strong&gt;：务必禁止不带任何限制数据范围条件的查询语句。比如:我们当用户在查询订单历史的时候,我们可以控制在一个月的范围内;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;：经典的数据库拆分方案,主库负责写,从库负责读;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垂直分区&lt;/strong&gt;：&lt;strong&gt;简单来说垂直拆分是指数据表列的拆分,把一张列比较多的表拆分为多张表&lt;/strong&gt;。例如,用户表中既有用户的登录信息又有用户的基本信息,可以将用户表拆分成两个单独的表,甚至放到单独的库做分库。（&lt;strong&gt;数据库范式&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqJLY.png&#34; alt=&#34;dqJLY.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;strong&gt;垂直拆分的优点&lt;/strong&gt;： 可以使得列数据变⼩，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;垂直拆分的缺点：&lt;/strong&gt; 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应⽤层进⾏Join来解决。此外，垂直分区会让事务变得更加复杂；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保持数据表结构不变,通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中,达到了分布式的目的。 水平拆分可以支撑非常大的数据量。（&lt;strong&gt;分表&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⽔平分区 ：保持数据表结构不变，通过某种策略存储数据分⽚。这样每⼀⽚数据分散到不同的表或者库中，达到了分布式的⽬的。 ⽔平拆分可以⽀撑⾮常⼤的数据量。⽔平拆分是指数据表⾏的拆分，表的⾏数超过200万⾏时，就会变慢，这时可以把⼀张的表的数&lt;br&gt;
据拆成多张表来存放。举个例⼦：我们可以将⽤户信息表拆分成多个⽤户信息表，这样就可以避免单⼀表数据量过⼤对性能造成影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqPuv.png&#34; alt=&#34;dqPuv.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⽔平拆分可以⽀持⾮常⼤的数据量。需要注意的⼀点是：分表仅仅是解决了单⼀表数据过⼤的问题，但由于表的数据还是在同⼀台机器上，其实对于提升MySQL并发能⼒没有什么意义，所以&lt;br&gt;
&lt;strong&gt;⽔平拆分最好分库 。&lt;/strong&gt;&lt;br&gt;
⽔平拆分能够 &lt;strong&gt;⽀持⾮常⼤的数据量存储，应⽤端改造也少，但 分⽚事务难以解决&lt;/strong&gt; ，跨节点Join性能差，逻辑复杂。&lt;strong&gt;尽量不要对数据进⾏分⽚&lt;/strong&gt;，&lt;strong&gt;因为拆分会带来逻辑、部署、运维的各种复杂度&lt;/strong&gt; ，⼀般的数据表在优化得当的情况下⽀撑千万以下的数据量是没有太⼤问题的。如果实在要分⽚，尽量选择客户端分⽚架构，这样可以减少⼀次和中间件的⽹络I/O。&lt;br&gt;
&lt;strong&gt;下⾯补充⼀下数据库分⽚的两种常⻅⽅案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;客户端代理&lt;/strong&gt;： &lt;strong&gt;分⽚逻辑在应⽤端，封装在jar包中，通过修改或者封装JDBC层来实现&lt;/strong&gt;。 当&lt;br&gt;
当⽹的 &lt;strong&gt;Sharding-JDBC&lt;/strong&gt; 、阿⾥的TDDL是两种⽐᫾常⽤的实现。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;中间件代理&lt;/strong&gt;： &lt;strong&gt;在应⽤和数据中间加了⼀个代理层。分⽚逻辑统⼀维护在中间件服务中&lt;/strong&gt;。 我&lt;br&gt;
们现在谈的 Mycat 、360的Atlas、⽹易的DDB等等都是这种架构的实现。&lt;/p&gt;
&lt;h2 id=&#34;清理表碎片&#34;&gt;清理表碎片&lt;/h2&gt;
&lt;h3 id=&#34;mysql中删除&#34;&gt;Mysql中删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mysql可以通过&lt;strong&gt;drop&lt;/strong&gt;、&lt;strong&gt;truncate&lt;/strong&gt;、&lt;strong&gt;delete&lt;/strong&gt;删除数据
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;drop table table_name&lt;/code&gt;：不管是innoDB还是MyISAM都会立刻释放空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;truncate table table_name&lt;/code&gt;：不管是innoDB还是MyISAM都会立刻释放空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete from table_name&lt;/code&gt;：删除表的全部数据，对于MyISAM会立刻释放磁盘空间，对于InnoDB不会释放磁盘空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete from table_name where xxx&lt;/code&gt;：带条件的删除，不管是InnoDB还是MyISAM都不会释放磁盘空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt; 操作后，使用&lt;code&gt;optimize table table_name&lt;/code&gt;会立即释放磁盘空间，不管是InnoDB还是MyISAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于delete的数据虽然没有释放磁盘空间，但是下次插入数据时，仍然可以使用这部分空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql表碎片&#34;&gt;Mysql表碎片&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产生原因：删除的原因导致的
&lt;ul&gt;
&lt;li&gt;删除一行内容后，该段空间就会变为空白、被留空，在一段时间内的大量删除操作，会是的留空的空间比存储列表内容所使用的空间更大。&lt;/li&gt;
&lt;li&gt;执行插入操作时，MySql会尝试使用空白空间，但如果某个空白空间一直没有被大小合适的数据占用，就会产生碎片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当碎片多的时候，将会影响b+树查询性能&lt;/strong&gt;（如果是SSD的话则不会）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql读取&#34;&gt;Mysql读取&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mysql预读：Mysql的&lt;strong&gt;预读分为线性预读（单位为extend）&lt;strong&gt;和&lt;/strong&gt;随机预读（单位为页）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;线性预读（linear read-ahead）：线性预读的读取单位为extend，可以通过&lt;code&gt;innodb_read_ahead_threshold&lt;/code&gt;来指定大小，默认为56。如果一个extend中顺序读取的page大于等于该变量时，MySQL就会把下一个extend预读到buffer pool中（&lt;strong&gt;注意MySql buffer pool的变种LRU机制&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;随机预读（randomread-ahead）：随机预读方式则是表示当同一个extent中的一些page在buffer pool中发现时，Innodb会将该extent中的剩余page一并读到buffer pool中。
&lt;ul&gt;
&lt;li&gt;由于随机预读方式给innodb code带来了一些不必要的复杂性，同时在性能也存在不稳定性，在5.5中已经将这种预读方式废弃，默认是OFF。若要启用此功能，即将配置变量设置innodb_random_read_ahead为ON。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mvcc&#34;&gt;MVCC&lt;/h2&gt;
&lt;p&gt;参考https://www.jianshu.com/p/8845ddca3b23&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MVCC（Multi-Version Concurrency Control）多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，它在不同的数据库引擎中有不同的实现。MySQL中MVCC只能在Repeatable Read（读可重复读）、Read Committed（读可提交）这两个隔离级别下工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读提交总是读取数据的最新行&lt;/strong&gt;，而不是复合当前事务版本的数据行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列化会对所有的读取操作加锁&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在MVCC中，删除语句并不会导致要删除的记录真正被删除，而是在丢弃相应的undo log时，才会删除相应的行及索引记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库隐藏字段：
&lt;ul&gt;
&lt;li&gt;DB_TRX_ID：6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID&lt;/li&gt;
&lt;li&gt;DB_ROLL_PTR：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）&lt;/li&gt;
&lt;li&gt;DB_ROW_ID：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql-mvcc具体实现方式是哪一种&#34;&gt;MySQL MVCC具体实现方式是哪一种&lt;/h3&gt;
&lt;p&gt;参考:https://blog.csdn.net/SnailMann/article/details/94724197&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐式字段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;undo日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Read View(读视图)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;mvcc能解决什么问题好处是&#34;&gt;MVCC能解决什么问题，好处是？&lt;/h3&gt;
&lt;h4 id=&#34;数据库并发场景有三种分别为&#34;&gt;数据库并发场景有三种，分别为：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;读-读：不存在任何问题，也不需要并发控制&lt;/li&gt;
&lt;li&gt;读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读&lt;/li&gt;
&lt;li&gt;写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mvcc带来的好处是&#34;&gt;MVCC带来的好处是？&lt;/h4&gt;
&lt;p&gt;**多版本并发控制（MVCC）**是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，&lt;strong&gt;为每个修改保存一个版本，版本与事务时间戳关联&lt;/strong&gt;，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决&lt;strong&gt;更新丢失问题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小结一下咯&#34;&gt;小结一下咯&lt;/h4&gt;
&lt;p&gt;总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVCC + 悲观锁&lt;br&gt;
MVCC解决读写冲突，悲观锁解决写写冲突&lt;/li&gt;
&lt;li&gt;MVCC + 乐观锁&lt;br&gt;
MVCC解决读写冲突，乐观锁解决写写冲突&lt;br&gt;
这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;读提交和可重复读都基于mvcc实现有什么区别&#34;&gt;读提交和可重复读都基于MVCC实现，有什么区别？&lt;/h3&gt;
&lt;p&gt;在可重复读级别下，只会在&lt;strong&gt;事务开始前创建视图&lt;/strong&gt;，事务中后续的查询共用一个视图。&lt;/p&gt;
&lt;p&gt;而读提交级别下&lt;strong&gt;每个语句执行前都会创建新的视图&lt;/strong&gt;。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。&lt;/p&gt;
&lt;h2 id=&#34;简述mysql中的日志log&#34;&gt;简述MySQL中的日志log&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redo log&lt;/strong&gt;: 存储引擎级别的log（InnoDB有，MyISAM没有），该&lt;strong&gt;log关注于事务&lt;/strong&gt;的&lt;strong&gt;恢复&lt;/strong&gt;.在重启mysql服务的时候，根据redo log进行&lt;strong&gt;重做&lt;/strong&gt;，从而使事务有&lt;strong&gt;持久性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;undo&lt;/strong&gt; log：是存储引擎级别的log（InnoDB有，MyISAM没有）&lt;strong&gt;保证数据的原子性&lt;/strong&gt;，该log保存了事务发生之前的数据的一个版本，可以用于&lt;strong&gt;回滚&lt;/strong&gt;，&lt;strong&gt;是MVCC的重要实现方法之一&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bin log&lt;/strong&gt;：数据库级别的log，关注&lt;strong&gt;恢复数据库的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;mysql是如何保证主备一致的&#34;&gt;MySQL是如何保证主备一致的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MySQL通过bin log（二进制日志）实现主备一致&lt;/strong&gt;。bin log记录了&lt;strong&gt;所有修改了数据库或可能修改数据库的语句&lt;/strong&gt;，而不会记录select、show这种不会修改数据库的语句。&lt;/p&gt;
&lt;p&gt;在备份的过程中，&lt;strong&gt;主库A会有一个专门的线程将主库A的bin log发送给 备库B进行备份&lt;/strong&gt;。其中bin log有三种记录格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;statement&lt;/strong&gt;:记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。
&lt;ul&gt;
&lt;li&gt;优点是binlog日志量少，IO压力小，性能较高。&lt;/li&gt;
&lt;li&gt;缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;row&lt;/strong&gt;:记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数据，会把涉及的每行数据都记录到bin log。
&lt;ul&gt;
&lt;li&gt;优点是能够完全的还原或者复制日志被记录时的操作。&lt;/li&gt;
&lt;li&gt;缺点是日志量占用空间较大，IO压力大，性能消耗较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mixed&lt;/strong&gt;:混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式， 否则就用statement格式。但是在生产环境中，一般会使用row模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redo-log与bin-log的区别&#34;&gt;redo log与bin log的区别？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;redo log是&lt;strong&gt;InnoDB引擎特&lt;/strong&gt;有的，只记录该引擎中表的&lt;strong&gt;修改记录&lt;/strong&gt;。bin log是MySQL的&lt;strong&gt;Server层&lt;/strong&gt;实现的，会记录&lt;strong&gt;所有引擎&lt;/strong&gt;对数据库的修改。&lt;/li&gt;
&lt;li&gt;redo log是&lt;strong&gt;物理&lt;/strong&gt;日志，记录的是在具体某个数据页上做了什么修改；bin log是&lt;strong&gt;逻辑&lt;/strong&gt;日志，记录的是这个语句的原始逻辑。&lt;/li&gt;
&lt;li&gt;redo log是&lt;strong&gt;循环&lt;/strong&gt;写的，&lt;strong&gt;空间固定会用完&lt;/strong&gt;；bin log是可以追加写入的，bin log文件写到一定大小后会&lt;strong&gt;切换&lt;/strong&gt;到下一个，&lt;strong&gt;并不会覆盖以前的日志&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么时候redo-log会触发写磁盘&#34;&gt;什么时候redo log会触发写磁盘&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/wuzhenwei0419/article/details/105258902/&lt;/p&gt;
&lt;h2 id=&#34;crash-safe能力是什么&#34;&gt;crash-safe能力是什么&lt;/h2&gt;
&lt;p&gt;InnoDB通过redo log保证即使数据库发生异常重启，之前&lt;strong&gt;提交的记录&lt;/strong&gt;都不会丢失，这个能力称为crash-safe。&lt;/p&gt;
&lt;h2 id=&#34;wal技术是什么&#34;&gt;WAL技术是什么&lt;/h2&gt;
&lt;p&gt;WAL的全称是Write-Ahead Logging，它的关键点就是**先写日志，再写磁盘。**事务在提交写入磁盘前，会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I/O访问，涉及磁盘随机I/O访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。&lt;/p&gt;
&lt;h2 id=&#34;两阶段提交是什么&#34;&gt;两阶段提交是什么&lt;/h2&gt;
&lt;p&gt;为了&lt;strong&gt;保证binl og和redo log两份日志的逻辑一致&lt;/strong&gt;，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录redo log中，此时redo log处于&lt;strong&gt;prepare&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;存储引擎告知&lt;strong&gt;执行器执行完毕&lt;/strong&gt;，执行器生成这个操作对应的bin log，并把binlog写入磁盘。&lt;/li&gt;
&lt;li&gt;执行器调用引擎的&lt;strong&gt;提交事务接口&lt;/strong&gt;，引擎把刚刚写入的redo log改成提交&lt;strong&gt;commit&lt;/strong&gt;状态，更新完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;只靠bin-log可以支持数据库崩溃恢复吗&#34;&gt;只靠bin log可以支持数据库崩溃恢复吗&lt;/h2&gt;
&lt;p&gt;不可以。 历史原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB接入了MySQL后，发现既然bin log没有崩溃恢复的能力，那引入InnoDB原有的redo log来保证崩溃恢复能力。 实现原因：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bin log没有记录数据页修改的详细信息，不具备恢复数据页的能力&lt;/strong&gt;。binlog记录着数据行的增删改，但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时，其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中。&lt;/li&gt;
&lt;li&gt;操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘,fsync才是将数据持久化到磁盘的操作。通过参数设置sync_binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交的事务以及binlog日志由于没有持久化而丢失。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简述mysql主从复制&#34;&gt;简述MySQL主从复制&lt;/h2&gt;
&lt;p&gt;MySQL提供主从复制功能，可以方便的&lt;strong&gt;实现数据的多处自动备份&lt;/strong&gt;，不仅能增加数据库的安全性，还能进行&lt;strong&gt;读写分离&lt;/strong&gt;，提升&lt;strong&gt;数据库负载性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主从复制流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在事务完成之前，主库在&lt;strong&gt;bin log&lt;/strong&gt;上记录这些改变，&lt;strong&gt;完成bin log写入过程后，主库通知存储引擎提交事物&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从库将主库的bin log复制到对应的中继日志，即开辟一个I/O工作线程，I/O线程在主库上打开一个普通的连接，然后开始bin log dump process，将这些事件写入中继日志。从主库的bin log中读取事件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读写分离：即只在MySQL主库上写，只在MySQL从库上读，以减少数据库压力，提高性能。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;sql-truncate-delete和drop的异同&#34;&gt;SQL truncate 、delete和drop的异同&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/biglxl/article/details/73301965&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相同点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.truncate和不带where子句的delete、以及drop都会删除表内的数据。&lt;/p&gt;
&lt;p&gt;2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.truncate 和 delete 只删除数据不删除表的结构(定义)&lt;br&gt;
drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态（无效状态）。&lt;/p&gt;
&lt;p&gt;2.delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger（触发器），执行的时候将被触发。&lt;/p&gt;
&lt;p&gt;truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger（触发器）。&lt;br&gt;
（rollback segment可以理解为是一个存储状态的区域，它相当于保存操作前数据库的状态信息，当操作执行成功后继续存储当前状态，当操作失败时回滚即恢复到操作之前保存的状态）&lt;/p&gt;
&lt;p&gt;3.速度，一般来说: drop&amp;gt; truncate &amp;gt; delete&lt;br&gt;
原因：&lt;br&gt;
drop 删除了表的数据及表的结构即从数据库中删除该表&lt;br&gt;
truncate 只删除数据&lt;br&gt;
delete 有条件的删除表中数据（没有条件即没有where语句即删除表中所有数据）&lt;/p&gt;
&lt;h2 id=&#34;数据模型描述&#34;&gt;数据模型描述&lt;/h2&gt;
&lt;p&gt;数据模型的组成要素有：&lt;/p&gt;
&lt;p&gt;1**.数据结构**，描述数据库的组成对象以及对象之间的联系，数据结构是所描述的对象类型的集合，是对系统静态特征的描述&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;数据操作&lt;/strong&gt;，是指对数据库中各种对象的实例允许执行的操作的集合，主要有查询和更新。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;数据的完整性约束条件&lt;/strong&gt;，是一组完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的之约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。&lt;/p&gt;
&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;
&lt;p&gt;删除操作异常是指不该删除的数据被删除；&lt;/p&gt;
&lt;p&gt;插入操作异常是指应该插入的数据未被插入；&lt;/p&gt;
&lt;h2 id=&#34;having条件&#34;&gt;Having条件&lt;/h2&gt;
&lt;p&gt;having和group by 区别&lt;/p&gt;
&lt;p&gt;having是对于group by分组后结果进行筛选，group by是进行分组&lt;/p&gt;
&lt;p&gt;where 子句和 having子句区别&lt;/p&gt;
&lt;p&gt;where是对查询进行限制条件，&lt;strong&gt;having只是对于group by后的结果进行限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以用having就一定要和group by连用，且是先group by XXX 再having XXX，用group by不一有having（&lt;strong&gt;它只是一个筛选条件用的&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;where后不可以加聚合函数，但是having可以添加聚合函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;都是实际的比预期操作的少&lt;/strong&gt;3&lt;/p&gt;
&lt;h2 id=&#34;select执行顺序&#34;&gt;select执行顺序&lt;/h2&gt;
&lt;p&gt;写法顺序：select--from--where--group by--having--order by&lt;/p&gt;
&lt;p&gt;执行顺序：from--where--group by--having--select--order by  就是select要放后面，如果有order by，则order by放最后，因为order by 是对结果进行排序&lt;/p&gt;
&lt;h2 id=&#34;用于调用存储过程的对象&#34;&gt;用于调用存储过程的对象&lt;/h2&gt;
&lt;p&gt;CallableStatemet 用于调用存储过程的对象&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/borter/p/9562391.html&#34;&gt;Statement和PreparedStatement都是用来发送和执行SQL语句的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/borter/p/9562403.html&#34;&gt;ResultSet是结果集对象&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;sql注入和解决方法&#34;&gt;SQL注入和解决方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是SQL注入？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL注入就是在系统登陆窗口或其他一切可输入文本中输入一段SQL语句，由于“SQL注入”是利用未过滤/未审核用户输入的攻击方法，其实就是让应用运行本不应该运行的SQL代码，如果应用毫无防备地创建了SQL字符串并且运行了它们，就会造成一些出人意料的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的sql注入语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String sql = &amp;quot;select * from user_table where username=&lt;/p&gt;
&lt;p&gt;&#39; &amp;quot;+userName+&amp;quot; &#39; and password=&#39; &amp;quot;+password+&amp;quot; &#39;&amp;quot;;&lt;/p&gt;
&lt;p&gt;改写成&lt;/p&gt;
&lt;p&gt;SELECT * FROM user_table WHERE username=&lt;/p&gt;
&lt;p&gt;&#39;’or 1 = 1 -- and password=&#39;’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL注入解决方法&lt;/strong&gt;&lt;br&gt;
解决SQL注入问题的关键是对所有可能来自用户输入的数据进行严格的检查、对数据库配置使用最小权限原则。&lt;/p&gt;
&lt;p&gt;1、所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。&lt;/p&gt;
&lt;p&gt;​	MyBatis提供了两种支持动态 sql 的语法 #{} 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;其&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{}，其中&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;其&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{} 是简单的&lt;a href=&#34;https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2&amp;amp;spm=1001.2101.3001.7020&#34;&gt;字符串替换&lt;/a&gt;，而 #{} 在预处理时，会把参数部分用一个占位符 ? 代替，可以有效的防止sql的注入&lt;/p&gt;
&lt;p&gt;2、对进入数据库的特殊字符（’”\尖括号&amp;amp;*;等）进行转义处理，或编码转换。&lt;/p&gt;
&lt;p&gt;3、严格限制变量类型，比如整型变量就采用intval()函数过滤，数据库中的存储字段必须对应为int型。&lt;/p&gt;
&lt;p&gt;4、数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。&lt;/p&gt;
&lt;p&gt;5、网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。&lt;/p&gt;
&lt;p&gt;6、严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。&lt;/p&gt;
&lt;p&gt;7、避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。&lt;/p&gt;
&lt;p&gt;8、在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。&lt;/p&gt;
&lt;p&gt;9、确认PHP配置文件中的magicquotesgpc选项保持开启&lt;/p&gt;
&lt;h2 id=&#34;log日志有几个级别&#34;&gt;log日志有几个级别&lt;/h2&gt;
&lt;p&gt;https://blog.csdn.net/jYF_666/article/details/102776645&lt;/p&gt;
&lt;p&gt;log4j定义了8个级别的log（除去OFF和ALL，可以说分为6个级别），优先级从高到低依次为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、 ALL。&lt;br&gt;
Log4j建议只使用四个级别，优先级从高到低分别是 &lt;strong&gt;ERROR、WARN、INFO、DEBUG&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;mysql常用函数&#34;&gt;Mysql常用函数&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/read/cv3838568/&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;聚合函数&lt;/strong&gt;&lt;br&gt;
聚合函数是平时比较常用的一类函数，这里列举如下：&lt;/p&gt;
&lt;p&gt;COUNT(col)   统计查询结果的行数&lt;/p&gt;
&lt;p&gt;MIN(col)   查询指定列的最小值&lt;/p&gt;
&lt;p&gt;MAX(col)   查询指定列的最大值&lt;/p&gt;
&lt;p&gt;SUM(col)   求和，返回指定列的总和&lt;/p&gt;
&lt;p&gt;AVG(col)   求平均值，返回指定列数据的平均值&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;数值型函数&lt;/strong&gt;&lt;br&gt;
数值型函数主要是对数值型数据进行处理，得到我们想要的结果，常用的几个列举如下，具体使用方法大家可以试试看。&lt;/p&gt;
&lt;p&gt;ABS(x)   返回x的绝对值&lt;/p&gt;
&lt;p&gt;BIN(x)   返回x的二进制&lt;/p&gt;
&lt;p&gt;CEILING(x)   返回大于x的最小整数值&lt;/p&gt;
&lt;p&gt;EXP(x)   返回值e（自然对数的底）的x次方&lt;/p&gt;
&lt;p&gt;FLOOR(x)   返回小于x的最大整数值&lt;/p&gt;
&lt;p&gt;GREATEST(x1,x2,...,xn)   返回集合中最大的值&lt;/p&gt;
&lt;p&gt;LEAST(x1,x2,...,xn)   返回集合中最小的值&lt;/p&gt;
&lt;p&gt;LN(x)   返回x的自然对数&lt;/p&gt;
&lt;p&gt;LOG(x,y)   返回x的以y为底的对数&lt;/p&gt;
&lt;p&gt;MOD(x,y)   返回x/y的模（余数）&lt;/p&gt;
">Mysql</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/cao-zuo-xi-tong/"" data-c="
          &lt;h2 id=&#34;操作系统基础&#34;&gt;操作系统基础&lt;/h2&gt;
&lt;h3 id=&#34;什么是操作系统&#34;&gt;什么是操作系统？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基⽯&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统本质上是⼀个运⾏在计算机上的软件程序 ，⽤于管理计算机硬件和软件资源。&lt;/strong&gt; 举例：运⾏在你电脑上的所有应⽤程序都通过操作系统来调⽤系统内存以及磁盘等等硬件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统存在屏蔽了硬件层的复杂性。&lt;/strong&gt; 操作系统就像是硬件使⽤的负责⼈，统筹着各种相关事项。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作系统的内核（Kernel）是操作系统的核⼼部分，它负责系统的内存管理，硬件设备的管理，⽂件系统的管理以及应⽤程序的管理&lt;/strong&gt;。 内核是连接应⽤程序和硬件的桥梁，决定着系统的性能和稳定。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqezL.png&#34; alt=&#34;dqezL.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调⽤&lt;/h3&gt;
&lt;p&gt;根据进程访问资源的特点，我们可以把进程在系统上的运⾏分为两个级别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;⽤户态(user mode) : &lt;strong&gt;⽤户态运⾏的进程或可以直接读取⽤户程序的数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;系统态(kernel mode):可以&lt;strong&gt;简单的理解系统态运⾏的进程或程序⼏乎可以访问计算机的任何资源，不受限制。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们运⾏的程序基本都是运⾏在⽤户态，如果我们调⽤操作系统提供的系统态级别的⼦功能就需要用到系统调用也就是说在我们运⾏的⽤户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调⽤⽅式向操作系统提出服务请求，并由操作系统代为完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备管理。完成设备的请求或释放，以及设备启动等功能。&lt;/li&gt;
&lt;li&gt;⽂件管理。完成⽂件的读、写、创建及删除等功能。&lt;/li&gt;
&lt;li&gt;进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。&lt;/li&gt;
&lt;li&gt;进程通信。完成进程之间的消息传递或信号传递等功能。&lt;/li&gt;
&lt;li&gt;内存管理。完成内存的分配、回收以及获取作业占⽤内存区⼤⼩及地址等功&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程和线程&#34;&gt;进程和线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程是资源分配的最小单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程是CPU调度的最小单位&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别&lt;/h3&gt;
&lt;h3 id=&#34;进程有哪几种状态&#34;&gt;进程有哪⼏种状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建状态(new) ：进程正在被创建，尚未到就绪状态&lt;/li&gt;
&lt;li&gt;就绪状态(ready) ：进程已处于准备运⾏状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间⽚)即可运⾏。&lt;/li&gt;
&lt;li&gt;运⾏状态(running) ：进程正在处理器上上运⾏(单核 CPU 下任意时刻只有⼀个进程处于运⾏状态)。&lt;/li&gt;
&lt;li&gt;阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件⽽暂停运⾏如等待某资源为可⽤或等待 IO 操作完成。即使处理器空闲，该进程也不能运⾏。&lt;/li&gt;
&lt;li&gt;结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出&lt;br&gt;
运⾏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间的通信方式和优缺点&#34;&gt;进程间的通信⽅式和优缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;管道/匿名管道(Pipes)&lt;/strong&gt; ：⽤于具有&lt;strong&gt;亲缘关系的⽗⼦进程间或者兄弟进程之间的通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;优点:比较简单&lt;br&gt;
缺点:效率低下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有名管道(Names Pipes)&lt;/strong&gt; : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名&lt;strong&gt;管道严格遵循先进先出(first in first out)&lt;/strong&gt;。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号(Signal)&lt;/strong&gt; ：信号是⼀种比较复杂的通信⽅式，⽤于&lt;strong&gt;通知接收进程某个事件已经发⽣&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消息队列(Message Queuing)&lt;/strong&gt; ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在&lt;strong&gt;内核&lt;/strong&gt;中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。&lt;strong&gt;消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取&lt;/strong&gt;.⽐ FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载⽆格式字 节流以及缓冲区⼤⼩受限等缺。&lt;/p&gt;
&lt;p&gt;​	优点:进程的数据放在某个内存之后就马上让进程返回&lt;br&gt;
​	缺点:如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号量(Semaphores)&lt;/strong&gt; ：信号量是⼀个&lt;strong&gt;计数器&lt;/strong&gt;，⽤于多进程对共享数据的访问，&lt;strong&gt;信号量的意图在于进程间同步&lt;/strong&gt;。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。&lt;/p&gt;
&lt;p&gt;​	优点:解决多进程竞争内存的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**共享内存(Shared memory) ：**使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。&lt;/p&gt;
&lt;p&gt;​	优点:解决拷贝所消耗的时间了&lt;br&gt;
​	缺点:多进程竞争内存的问题，就像类似于我们平时说的线程安全问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;套接字(Sockets) :&lt;/strong&gt; 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持 TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。&lt;br&gt;
优点:两个相隔几千里的进程能够进行通信&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程间的同步的方式&#34;&gt;线程间的同步的⽅式&lt;/h3&gt;
&lt;p&gt;线程同步是两个或多个共享关键资源的线程的并发执⾏。应该同步线程以避免关键的资源使⽤冲突。操作系统⼀般有下⾯三种线程同步方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**互斥量(Mutex)：**采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。⽐如 Java 中的&lt;br&gt;
synchronized 关键词和各种 Lock 都是这种机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量(Semphares)&lt;/strong&gt; ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件(Event) :Wait/Notify&lt;/strong&gt;：通过通知操作的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的比较&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程同步互斥的四种方式&#34;&gt;线程同步/互斥的四种方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、临界区&lt;/strong&gt;：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。&lt;strong&gt;在任意时刻只允许一个线程对共享资源进行访问&lt;/strong&gt;，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。&lt;/p&gt;
&lt;p&gt;总结下关键段：&lt;br&gt;
1）关键段共初始化化、销毁、进入和离开关键区域四个函数。&lt;br&gt;
2）关键段可以解决线程的互斥问题，但因为具有“线程所有权”，所以无法解决同步问题。&lt;br&gt;
3）推荐关键段与旋转锁配合使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、互斥对象&lt;/strong&gt;：互斥对象和临界区很像，采用互斥对象机制，&lt;strong&gt;只有拥有互斥对象的线程才有访问公共资源的权限&lt;/strong&gt;。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。&lt;strong&gt;当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结下互斥量Mutex：&lt;br&gt;
1）互斥量是内核对象，它与关键段都有“线程所有权”所以不能用于线程的同步。&lt;br&gt;
2）互斥量能够用于多个进程之间线程互斥问题，并且能完美的解决某进程意外终止所造成的“遗弃”问题。&lt;br&gt;
&lt;strong&gt;3、信号量&lt;/strong&gt;：信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目&lt;/p&gt;
&lt;p&gt;在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，&lt;strong&gt;当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号&lt;/strong&gt;。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、事件对象&lt;/strong&gt;： **通过通知操作的方式来保持线程的同步，**还可以方便实现对多个线程的优先级比较的操作&lt;/p&gt;
&lt;p&gt;总结下事件&lt;strong&gt;Event&lt;/strong&gt;&lt;br&gt;
1）事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。&lt;br&gt;
2）事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。&lt;br&gt;
3）事件可以解决线程间同步问题，因此也能解决互斥问题。&lt;/p&gt;
&lt;h3 id=&#34;进程的调度算法&#34;&gt;进程的调度算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先到先服务(FCFS)调度算法&lt;/strong&gt; : 从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;短作业优先(SJF)的调度算法&lt;/strong&gt; : 从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间⽚轮转调度算法&lt;/strong&gt; : 时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许&lt;br&gt;
运⾏的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多级反馈队列调度算法&lt;/strong&gt; ：前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级调度&lt;/strong&gt; ： 为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来&lt;br&gt;
确定优先级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的要素&#34;&gt;进程的要素&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqrPi.png&#34; alt=&#34;dqrPi.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;进程控制块：标识信息 现场信息 控制信息&lt;/p&gt;
&lt;p&gt;进程映像 ：静态特征-进程程序块 进程数据块&lt;/p&gt;
&lt;p&gt;​                     动态特征-进程控制块 进程核心数&lt;/p&gt;
&lt;p&gt;进程队列 ：单向链接 双向链接&lt;/p&gt;
&lt;h2 id=&#34;内存管理基础&#34;&gt;内存管理基础&lt;/h2&gt;
&lt;h3 id=&#34;内存管理介绍&#34;&gt;内存管理介绍&lt;/h3&gt;
&lt;p&gt;操作系统的内存管理主要负责&lt;strong&gt;内存的分配与回收&lt;/strong&gt;（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。&lt;/p&gt;
&lt;h3 id=&#34;常见的几种内存管理机制&#34;&gt;常见的几种内存管理机制&lt;/h3&gt;
&lt;p&gt;简单分为&lt;strong&gt;连续分配管理⽅式&lt;/strong&gt;和&lt;strong&gt;⾮连续分配管理⽅式&lt;/strong&gt;这两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续分配管理⽅式&lt;/strong&gt;是指为⼀个⽤户程序分配⼀个&lt;strong&gt;连续的内存空间&lt;/strong&gt;，常⻅的如 &lt;strong&gt;块式管理&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⾮连续分配管理⽅式&lt;/strong&gt;允许⼀个程序使⽤的内存分布在&lt;strong&gt;离散或者说不相邻的内存&lt;/strong&gt;中，常⻅的如&lt;strong&gt;⻚式管理&lt;/strong&gt; 和 &lt;strong&gt;段式管理。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;块式管理&lt;/strong&gt; ： 远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未被利⽤的空间，我们称之为碎⽚。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;⻚式管理&lt;/strong&gt; ：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，页较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。&lt;strong&gt;⻚式管理通过⻚表对应逻辑地址和物理地址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段式管理&lt;/strong&gt; ： ⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意&lt;br&gt;
义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重要的是&lt;strong&gt;段是有实际意义&lt;/strong&gt;的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段页式管理&lt;/strong&gt;：&lt;strong&gt;段⻚式管理机制结合了段式管理和⻚式管理的优点&lt;/strong&gt;。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;快表和多级页表&#34;&gt;快表和多级页表&lt;/h3&gt;
&lt;p&gt;在分⻚内存管理中，很重要的两点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;虚拟地址到物理地址的转换要快&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决虚拟地址空间⼤，⻚表也会很⼤的问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;快表&lt;/strong&gt;&lt;br&gt;
为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表⽅案 基础之上引⼊了 快表 来加速虚&lt;br&gt;
拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中&lt;br&gt;
的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访&lt;br&gt;
问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只&lt;br&gt;
要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。&lt;/p&gt;
&lt;p&gt;快表的地址转换流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据虚拟地址中的⻚号查快表；2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；&lt;/li&gt;
&lt;li&gt;如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该&lt;br&gt;
映射表项添加到快表中；&lt;/li&gt;
&lt;li&gt;当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。&lt;br&gt;
看完了之后你会发现快表和我们平时经常在我们开发的系统使⽤的缓存（⽐如 Redis）很像，的&lt;br&gt;
确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们⽇常开发使⽤的各种⼯&lt;br&gt;
具或者框架中找到它们的影⼦。&lt;/li&gt;
&lt;li&gt;当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;多级⻚表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本&lt;br&gt;
就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了提⾼内存的空间性能，提出了多级⻚表的概念；但是提到空间性能是以浪费时间性能为基础&lt;br&gt;
的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级⻚表实&lt;br&gt;
际上都利⽤到了程序的局部性原理，局部性原理在后⾯的虚拟内存这部分会介绍到。&lt;/p&gt;
&lt;h3 id=&#34;分页机制和分段机制&#34;&gt;分页机制和分段机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;共同点 ：&lt;/strong&gt;&lt;br&gt;
分⻚机制和分段机制都是为了提⾼内存利⽤率，᫾少内存碎⽚。&lt;br&gt;
⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，&lt;strong&gt;每个⻚和段中的内存是连续的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区别&lt;/strong&gt; ：⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程&lt;br&gt;
序。&lt;br&gt;
分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以&lt;br&gt;
体现为代码段，数据段，能够更好满⾜⽤户的需要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;逻辑虚拟地址和物理地址&#34;&gt;逻辑（虚拟）地址和物理地址&lt;/h3&gt;
&lt;p&gt;⽐如在 C 语⾔中，指针⾥⾯存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地&lt;br&gt;
址。物理地址是内存单元真正的地址。&lt;/p&gt;
&lt;h3 id=&#34;cpu寻址&#34;&gt;CPU寻址&lt;/h3&gt;
&lt;p&gt;现代处理器使⽤的是⼀种称为 &lt;strong&gt;虚拟寻址(Virtual Addressing)&lt;/strong&gt; 的寻址⽅式。&lt;strong&gt;使⽤虚拟寻址，CPU&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。&lt;/strong&gt; 实际上完成虚拟地址转换为&lt;br&gt;
物理地址转换的硬件是 CPU 中含有⼀个被称为 &lt;strong&gt;内存管理单元&lt;/strong&gt;（&lt;strong&gt;Memory Management Unit,&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;MMU）&lt;/strong&gt; 的硬件如下图所示：&lt;br&gt;
&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqAlX.png&#34; alt=&#34;dqAlX.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要有虚拟地址空间呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，&lt;strong&gt;程序都是直接访问和操作的都&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;是物理内存&lt;/strong&gt; 。但是这样有什么问题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者⽆意）破坏操&lt;br&gt;
作系统，造成操作系统崩溃。&lt;/li&gt;
&lt;li&gt;想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个 QQ ⾳乐都不⾏。为什&lt;br&gt;
么呢？举个简单的例⼦：微信在运⾏的时候给内存地址 1xxx 赋值后，QQ ⾳乐也同样给内&lt;br&gt;
存地址 1xxx 赋值，那么 QQ ⾳乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微&lt;br&gt;
信这个程序就会被QQ音乐占用而退出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结来说：如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;及给同时运⾏多个程序造成困难。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过虚拟地址访问内存有以下优势&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序可以使⽤⼀系列相邻的虚拟地址来访问物理内存中不相邻的⼤内存缓冲区。&lt;/li&gt;
&lt;li&gt;程序可以使⽤⼀系列虚拟地址来访问⼤于可⽤物理内存的内存缓冲区。当物理内存的供应量&lt;br&gt;
变⼩时，内存管理器会将物理内存⻚（通常⼤⼩为 4 KB）保存到磁盘⽂件。数据或代码⻚会根据需要在物理内存与磁盘之间移动。&lt;/li&gt;
&lt;li&gt;不同进程使⽤的虚拟地址彼此隔离。⼀个进程中的代码⽆法更改正在由另⼀进程或操作系统使⽤的物理内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h2&gt;
&lt;h3 id=&#34;什么是虚拟内存&#34;&gt;什么是虚拟内存&lt;/h3&gt;
&lt;p&gt;很多时候我们使⽤点&lt;br&gt;
开了很多占内存的软件，这些软件占⽤的内存可能已经远远超出了我们电脑本身具有的物理内&lt;br&gt;
存。为什么可以这样呢？ 正是因为 &lt;strong&gt;虚拟内存&lt;/strong&gt; 的存在，通过 虚拟内存 可以让程序可以拥有超过系&lt;br&gt;
统物理内存⼤⼩的可⽤内存空间。另外，&lt;strong&gt;虚拟内存为每个进程提供了⼀个⼀致的、私有的地址空&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;间，它让每个进程产⽣了⼀种⾃⼰在独享主存的错觉（每个进程拥有⼀⽚连续完整的内存空&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;间）&lt;/strong&gt;。这样会更加有效地管理内存并减少出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存是计算机系统内存管理的⼀种技术&lt;/strong&gt;，我们可以⼿动设置⾃⼰电脑的虚拟内存。不要单纯&lt;br&gt;
认为虚拟内存只是“使⽤硬盘空间来扩展内存“的技术。&lt;strong&gt;虚拟内存的重要意义是它定义了⼀个连续&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;的虚拟地址空间，并且 把内存扩展到硬盘空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;维基百科中介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt; 使得应⽤程序认为它拥有连续的可⽤的内存（⼀个连续完整的地址空间），⽽实&lt;br&gt;
际上，它通常是被分隔成多个物理内存碎⽚，还有部分暂时存储在外部磁盘存储器上，在需&lt;br&gt;
要时进⾏数据交换。与没有使⽤虚拟内存技术的系统相⽐，使⽤这种技术的系统使得⼤型程&lt;br&gt;
序的编写变得更容易，对真正的物理内存（例如 RAM）的使⽤也更有效率。⽬前，⼤多数&lt;br&gt;
操作系统都使⽤了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。&lt;br&gt;
From:https://zh.wikipedia.org/wiki/虚拟内存&lt;/p&gt;
&lt;h3 id=&#34;局部性原理&#34;&gt;局部性原理&lt;/h3&gt;
&lt;p&gt;局部性原理是虚拟内粗技术的基础，正是因为程序运行具有局部性原理，才可以装入部分程序到内存就开始运行&lt;/p&gt;
&lt;p&gt;早在 1968 年的时候，就有⼈指出我们的程序在执⾏的时候往往呈现局部性规律，也就是说在某&lt;br&gt;
个᫾短的时间段内，程序执⾏局限于某⼀⼩部分，程序访问的存储空间也局限于某个区域。&lt;/p&gt;
&lt;p&gt;局部性原理表现在以下两个⽅⾯：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;时间局部性&lt;/strong&gt; ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据&lt;br&gt;
被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在&lt;strong&gt;程序中&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;存在着⼤量的循环操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间局部性&lt;/strong&gt; ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，&lt;br&gt;
即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序&lt;br&gt;
存放、顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结&lt;br&gt;
构实现。空间局部性通常是使⽤᫾⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实&lt;br&gt;
现。虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利⽤局部性原理实现髙&lt;br&gt;
速缓存。&lt;/p&gt;
&lt;h3 id=&#34;虚拟存储器&#34;&gt;虚拟存储器&lt;/h3&gt;
&lt;p&gt;基于局部性原理，在程序装⼊时，可以将程序的⼀部分装⼊内存，⽽将其他部分留在外存，就可&lt;br&gt;
以启动程序执⾏。由于外存往往⽐内存⼤很多，所以我们运⾏的软件的内存⼤⼩实际上是可以⽐&lt;br&gt;
计算机系统实际的内存⼤⼩⼤的。在程序执⾏过程中，当所访问的信息不在内存时，由操作系统&lt;br&gt;
将所需要的部分调⼊内存，然后继续执⾏程序。另⼀⽅⾯，操作系统将内存中暂时不使⽤的内容&lt;br&gt;
换到外存上，从⽽腾出空间存放将要调⼊内存的信息。这样，计算机好像为⽤户提供了⼀个⽐实&lt;br&gt;
际内存⼤的多的存储器——虚拟存储器&lt;/p&gt;
&lt;p&gt;实际上，我觉得虚拟内存同样是⼀种时间换空间的策略，你⽤ CPU 的计算时间，⻚的调⼊调出&lt;br&gt;
花费的时间，换来了⼀个虚拟的更⼤的空间来⽀持程序的运⾏&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存的技术实现&#34;&gt;虚拟内存的技术实现&lt;/h3&gt;
&lt;p&gt;虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下&lt;br&gt;
三种⽅式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;请求分⻚存储管理&lt;/strong&gt; ：建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能&lt;br&gt;
和⻚⾯置换功能。请求分⻚是⽬前最常⽤的⼀种实现虚拟存储器的⽅法。请求分⻚存储管理&lt;br&gt;
系统中，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏。假如在作业运⾏的过&lt;br&gt;
程中发现要访问的⻚⾯不在内存，则由处理器通知操作系统按照对应的⻚⾯置换算法将相应&lt;br&gt;
的⻚⾯调⼊到主存，同时操作系统也可以将暂时不⽤的⻚⾯置换到外存中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求分段存储管理&lt;/strong&gt; ：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求&lt;br&gt;
分段储存管理⽅式就如同请求分⻚储存管理⽅式⼀样，在作业开始运⾏之前，仅装⼊当前要&lt;br&gt;
执⾏的部分段即可运⾏；在执⾏过程中，可使⽤请求调⼊中断动态装⼊要访问但⼜不在内存&lt;br&gt;
的程序段；当内存空间已满，⽽⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便&lt;br&gt;
腾出空间⽽装⼊新的段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求段⻚式存储管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;请求分与分存储管理区别&#34;&gt;请求分⻚与分⻚存储管理区别&lt;/h3&gt;
&lt;p&gt;请求分⻚存储管理建⽴在分⻚管理之上。他们的根本区别是是否将程序全部所需的全部地址空间&lt;br&gt;
都装⼊主存，这也是请求分⻚存储管理可以提供虚拟内存的原因，我们在上⾯已经分析过了。&lt;br&gt;
它们之间的根本区别在于是否将⼀作业的全部地址空间同时装⼊主存。请求分⻚存储管理不要求&lt;br&gt;
将作业全部地址空间同时装⼊主存。基于这⼀点，请求分⻚存储管理可以提供虚存，⽽分⻚存储&lt;br&gt;
管理却不能提供虚存。&lt;br&gt;
不管是上⾯那种实现⽅式，我们⼀般都需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;⼀定容量的内存和外存：在载⼊程序的时候，只需要将程序的⼀部分装⼊内存，⽽将其他部&lt;br&gt;
分留在外存，然后程序就可以执⾏了；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺⻚中断&lt;/strong&gt;：如果**需执⾏的指令或访问的数据尚未在内存（**称为缺⻚或缺段），则由处理器通&lt;br&gt;
知操作系统将相应的⻚⾯或段调⼊到内存，然后继续执⾏程序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟地址空间&lt;/strong&gt; ：逻辑地址到物理地址的变换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h3&gt;
&lt;p&gt;地址映射过程中，若在⻚⾯中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺⻚中断&lt;/strong&gt; 就是要访问的⻚不在主存，需要操作系统将其调⼊主存后再进⾏访问。 在这个时候，被内存映射的⽂件实际上成了⼀个分⻚交换⽂件。&lt;/p&gt;
&lt;p&gt;当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OPT ⻚⾯置换算法（最佳⻚⾯置换算法）&lt;/strong&gt; ：最佳(Optimal, OPT)置换算法所选择的被淘汰&lt;br&gt;
⻚⾯将是以后永不使⽤的，或者是在最⻓时间内不再被访问的⻚⾯,这样可以保证获得最低的&lt;br&gt;
缺⻚率。但由于⼈们⽬前⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被&lt;br&gt;
访问的，因⽽该算法⽆法实现。⼀般作为衡量其他置换算法的⽅法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法）&lt;/strong&gt; : 总是淘汰最先进⼊内&lt;br&gt;
存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LRU （Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法）&lt;/strong&gt; ：LRU算&lt;br&gt;
法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，当须&lt;br&gt;
淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LFU （Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法）&lt;/strong&gt; : 该置换算法选&lt;br&gt;
择在之前时期使⽤最少的⻚⾯作为淘汰⻚。&lt;/p&gt;
">操作系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/ji-suan-ji-wang-luo/"" data-c="
          &lt;h2 id=&#34;osi与tcpip各层的结构与功能都有哪些协议&#34;&gt;OSI与TCP/IP各层的结构与功能,都有哪些协议?&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqUzb.png&#34; alt=&#34;dqUzb.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;低三层&lt;/strong&gt;统称为&lt;strong&gt;通信子网&lt;/strong&gt;，它是为了联网而附加的通信设备，完成数据的&lt;strong&gt;传输功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高三层&lt;/strong&gt;统称为 &lt;strong&gt;资源子网&lt;/strong&gt;。它相当于计算机系统，&lt;strong&gt;完成数据的处理等功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;承上启下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应⽤层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤&lt;/strong&gt;。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。&lt;strong&gt;对于不同的⽹络应⽤需要不同的应⽤层协议&lt;/strong&gt;。在互联⽹中应⽤层协议很多，如&lt;strong&gt;域名系统DNS&lt;/strong&gt;，用于文件传送的&lt;strong&gt;FTP&lt;/strong&gt;，⽀持万维⽹应⽤的&lt;strong&gt;HTTP协议&lt;/strong&gt;，⽀持电⼦邮件的 &lt;strong&gt;SMTP协议&lt;/strong&gt;等等。我们把应⽤层交互的数据单元称为报⽂。&lt;br&gt;
&lt;strong&gt;域名系统DNS&lt;/strong&gt;&lt;br&gt;
域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特⽹的⼀项核⼼服务，它作为可以将域名和IP地址相互映射的⼀个分布式数据库，能够使⼈更⽅便的访问互联⽹，⽽不⽤去记住能够被机器直接读取的IP数串。（百度百科）例如：⼀个公司的&lt;br&gt;
Web ⽹站可看作是它在⽹上的⻔户，⽽域名就相当于其⻔牌地址，通常域名都使⽤该公司的名称或简称。例如上⾯提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP协议超⽂本传输协议（HTTP，HyperText Transfer Protocol)是互联⽹上应⽤最为⼴泛的⼀种⽹络协议。所有的 WWW（万维⽹） ⽂件都必须遵守这个标准。设计 HTTP 最初的⽬的是为了提供⼀种发布和接收 HTML ⻚⾯的⽅法。（百度百科）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运输层&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通⽤的数据传输服务&lt;/strong&gt;。应⽤进程利⽤该服务传送应⽤层报⽂。“通⽤的”是指并不针对某⼀个特定的⽹络应⽤，⽽是多种应⽤可以使⽤同⼀个运输层服务。由于⼀台主机可同时运⾏多个线程，因此运输层有复⽤和分⽤的功能。所谓复⽤就是指多个应⽤层进程可同时使⽤下⾯运输层的服务，分⽤和复⽤相反，是运输层把收到的信息分别交付上⾯应⽤层中的相应进程。&lt;/p&gt;
&lt;p&gt;运输层主要使⽤以下两种协议:&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;传输控制协议 TCP&lt;/strong&gt;（Transmission Control Protocol）--提供⾯向连接的，可靠的数据传输服务。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;⽤户数据协议 UDP&lt;/strong&gt;（User Datagram Protocol）--提供⽆连接的，尽最⼤努⼒的数据传输服务（不保证数据传输的可靠性）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⽹络层&lt;/strong&gt;&lt;br&gt;
在 计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦⽹。&lt;strong&gt;⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在发送数据时，⽹络层把运输层产⽣的报⽂段或⽤户数据报封装成分组和包进⾏传送。TCP/IP 体系结构中，由于⽹络层使⽤ IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。这⾥要注意：不要把运输层的“⽤户数据报 UDP ”和⽹络层的“ IP 数据报”弄混。另外，⽆论是哪⼀层的数据单元，都可笼统地⽤“分组”来表示。这⾥强调指出，⽹络层中的“⽹络”⼆字已经不是我们通常谈到的具体⽹络，⽽是指计算机⽹络体系结构模型中第三层的名称.&lt;br&gt;
互联⽹是由⼤量的异构（heterogeneous）⽹络通过路由器（router）相互连接起来的。互联⽹使⽤的⽹络层协议是⽆连接的⽹际协议（Intert Protocol）和许多路由选择协议，因此互联⽹的⽹络层也叫做⽹际层或IP层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址解析协议ARP&lt;/strong&gt;&lt;br&gt;
由于是IP协议使用了ARP协议，因此通常把&lt;strong&gt;ARP协议划归为网络层&lt;/strong&gt;。用途：为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地也就&lt;strong&gt;MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主要功能：进行路由选择，并实现流量控制，拥塞控制，差错控制和网络互联等功能&lt;/p&gt;
&lt;p&gt;常见的协议：&lt;strong&gt;IP，IPX，ICMP，IGMP，ARP，RARP，OSPF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据链路层(data link layer)通常简称为链路层。&lt;strong&gt;两台主机之间的数据传输&lt;/strong&gt;，总是在⼀段⼀段的链路上传送的，这就需要使⽤专⻔的链路层的协议。 在两个相邻节点之间传送数据时，&lt;strong&gt;数据链路层将⽹络层交下来的 IP 数据报组装成帧&lt;/strong&gt;，在两个相邻节点间的链路上传送帧&lt;/p&gt;
&lt;p&gt;每⼀帧包括数据和必要的控制信息（&lt;strong&gt;如同步信息，地址信息，差错控制等&lt;/strong&gt;）。在接收数据时，控制信息使接收端能够知道⼀个帧从哪个⽐特开始和到哪个⽐特结束。这样，数据链路层在收到⼀个帧后，就可从中提出数据部分，上交给⽹络层。控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在⽹络中传送下去⽩⽩浪费⽹络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，⽽且还要纠错），那么就要采⽤可靠&lt;br&gt;
性传输协议来纠正出现的差错。这种⽅法会使链路层的协议复杂些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能概括&lt;/strong&gt;：成帧,差错控制，流量控制和传输管理等&lt;/p&gt;
&lt;p&gt;典型的数据链路层协议有 SDLC，HDLC，PPP，STP和帧中继。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;&lt;br&gt;
在物理层上所传送的数据单位是&lt;strong&gt;⽐特&lt;/strong&gt;。&lt;strong&gt;物理层(physical layer)的作⽤是实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;体传输介质和物理设备的差异&lt;/strong&gt;。 使其上⾯的数据链路层不必考虑⽹络的具体传输介质是什么。“透明传送⽐特流”表示经实际电路传送后的⽐特流没有发⽣变化，对传送的⽐特流来说，这个电路好像是看不⻅的。在互联⽹使⽤的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在⼈们经常提到的TCP/IP并不⼀定单指TCP和IP这两个具体的协议，⽽往往表示互联⽹所使⽤的整个TCP/IP协议族。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比特流&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;各个层之间的设备&#34;&gt;各个层之间的设备&lt;/h3&gt;
&lt;p&gt;物理层：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中继器，集线器，双绞线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据链路层：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网桥，以太网交换&lt;/strong&gt;机，&lt;strong&gt;网卡&lt;/strong&gt;（一半物理层，一半数据链路层）&lt;/p&gt;
&lt;p&gt;网络层：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由器&lt;/strong&gt;，三层交换机&lt;/p&gt;
&lt;p&gt;传输层：&lt;/p&gt;
&lt;p&gt;四层交换机（常用作负载均衡），&lt;strong&gt;网关&lt;/strong&gt;：对高层协议（包括传输层及更高层次）进行转换的网间连接器&lt;/p&gt;
&lt;h3 id=&#34;ip地址与mac地址的作用和关系&#34;&gt;IP地址与MAC地址的作用和关系&lt;/h3&gt;
&lt;p&gt;IP和MAC两者之间分工明确，默契合作，完成通信过程。&lt;/p&gt;
&lt;p&gt;在数据通信时，IP地址专注于网络层，网络层设备（如路由器）根据IP地址，&lt;strong&gt;将数据包&lt;/strong&gt;从一个网络传递转发到另外一个网络上；&lt;/p&gt;
&lt;p&gt;而MAC地址专注于数据链路层，数据链路层设备（如交换机）根据MAC地址，将一个&lt;strong&gt;数据帧&lt;/strong&gt;从一个节点传送到相同链路的另一个节点上。IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成，ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络。&lt;/p&gt;
&lt;h2 id=&#34;tcp-三次握手和四次挥手&#34;&gt;TCP 三次握⼿和四次挥⼿&lt;/h2&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqblg.png&#34; alt=&#34;dqblg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqzZs.png&#34; alt=&#34;dqzZs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;客户端–发送带有 SYN 标志的数据包–⼀次握⼿–服务端&lt;/li&gt;
&lt;li&gt;服务端–发送带有 SYN/ACK 标志的数据包–⼆次握⼿–客户端&lt;/li&gt;
&lt;li&gt;客户端–发送带有带有 ACK 标志的数据包–三次握⼿–服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由和交换的区别&#34;&gt;路由和交换的区别&lt;/h3&gt;
&lt;p&gt;交换技术和路由技术的最大区别在于他们寻址的方式以及报文的转发方式上.&lt;/p&gt;
&lt;p&gt;交换技术是发生在2层也就是&lt;strong&gt;数据链路层&lt;/strong&gt;上，&lt;strong&gt;是直接利用mac地址建立会话&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;路由技术发生在&lt;strong&gt;网络层&lt;/strong&gt;，需要通过&lt;strong&gt;ip地址建立路由表&lt;/strong&gt;，然后进行数据通信。&lt;/p&gt;
&lt;p&gt;在报文的转发方式上，交换技术是使用&lt;strong&gt;先收再转，路由技术是采用边收边转&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;为什么要三次握手&#34;&gt;为什么要三次握⼿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么tcp握手需要三次两次行不行&#34;&gt;为什么TCP握手需要三次，两次行不行？&lt;/h3&gt;
&lt;p&gt;不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。&lt;/p&gt;
&lt;p&gt;如果只是两次握手， 至多只有&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;的起始序列号能被确认， &lt;strong&gt;服务器端的序列号则得不到确认&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;为什么要传回-syn&#34;&gt;为什么要传回 SYN&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SYN 是 TCP/IP 建⽴连接时使⽤的握⼿信号。在客户机和服务器之间建⽴正常的 TCP ⽹络连接时，客户机⾸先发出⼀个 SYN 消息，服务器使⽤ SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站&lt;br&gt;
发给发送站的⼀种传输控制字符。它表示确认发来的数据已经接受⽆误。 ]）消息响应。这样在客户机和服务器之间才能建⽴起可靠的TCP连接，数据才可以在客户机和服务器之间传递。&lt;/p&gt;
&lt;h3 id=&#34;传了-syn为啥还要传-ack&#34;&gt;传了 SYN,为啥还要传 ACK&lt;/h3&gt;
&lt;p&gt;双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问题，但是接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqFcK.png&#34; alt=&#34;dqFcK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;断开⼀个 TCP 连接则需要“四次挥⼿”：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端-发送⼀个 FIN，⽤来关闭客户端到服务器的数据传&lt;/li&gt;
&lt;li&gt;服务器-收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1 。和 SYN ⼀样，⼀个FIN 将占⽤⼀个序号&lt;/li&gt;
&lt;li&gt;服务器-关闭与客户端的连接，发送⼀个FIN给客户端&lt;/li&gt;
&lt;li&gt;客户端-发回 ACK 报⽂确认，并将确认序号设置为收到序号加1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么要四次挥手&#34;&gt;为什么要四次挥⼿&lt;/h3&gt;
&lt;p&gt;任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后就完全关闭了TCP连接。&lt;/p&gt;
&lt;h3 id=&#34;简述半连接队列&#34;&gt;简述半连接队列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP握手&lt;/strong&gt;中，当服务器处于&lt;strong&gt;SYN_RCVD&lt;/strong&gt; 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。&lt;/p&gt;
&lt;h3 id=&#34;简述syn攻击&#34;&gt;简述SYN攻击&lt;/h3&gt;
&lt;p&gt;SYN攻击即利用TCP协议缺陷，通过&lt;strong&gt;发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;缩短SYN Timeout SYN生效的时间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;记录IP，&lt;strong&gt;若连续受到某个IP的重复SYN报文&lt;/strong&gt;，从这个IP地址来的包会被一概丢弃。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;为什么tcp挥手需要4次&#34;&gt;为什么TCP挥手需要4次&lt;/h3&gt;
&lt;p&gt;主要原因是当服务端收到&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。&lt;/p&gt;
&lt;p&gt;所以服务端会先将 ACK 发过去告诉&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;表示现在可以断了。之后&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;需要收到 FIN 包后发送 ACK 确认断开信息给服务端。&lt;/p&gt;
&lt;h3 id=&#34;为什么四次挥手释放连接时需要等待2msl&#34;&gt;为什么四次挥手释放连接时需要等待2MSL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MSL即报文最大生存时间&lt;/strong&gt;。设置2MSL可以保证上一次连接的报文已经在网络中&lt;strong&gt;消失&lt;/strong&gt;，&lt;strong&gt;不会出现与新TCP连接报文冲突的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;socket_listen里面第二个参数backlog的用处&#34;&gt;socket_listen里面第二个参数backlog的用处&lt;/h3&gt;
&lt;p&gt;当有多个客户端一起请求的时候，&lt;strong&gt;服务端不可能来多少就处理多少，这样如果并发太多，就会因为性能的因素发生拥塞，然后造成雪崩&lt;/strong&gt;。所有就搞了一个队列，先将请求放在队列里面，一个个来。&lt;strong&gt;socket_listen里面的第二个参数backlog就是设置这个队列的长度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果将队列长度设置成10，那么如果有20个请求一起过来，服务端就会先放10个请求进入这个队列，因为长度只有10。然后其他的就直接拒绝。tcp协议这时候不会发送rst给客户端，这样的话客户端就会重新发送SYN，以便能进入这个队列。&lt;/p&gt;
&lt;p&gt;如果三次握手完成了，就会将完成三次握手的请求取出来，放入另一个队列中，这样队列就空出一个位置，其他重发SYN的请求就可以进&lt;/p&gt;
&lt;p&gt;入队列中。&lt;/p&gt;
&lt;p&gt;**服务器监听时，在每次处理一个客户端的连接时是需要一定时间的，这个时间非常的短(也许只有1ms 或者还不到)，但这个时间还是存在的。而这个backlog 存在的意义就是：在这段时间里面除了第一个连接请求是正在进行处理以外，其他的连接请求都在请求队列中等待，而如果超过了队列的最大等待个数时，其他的请求将被忽略或者将不会被处理。**这个backlog 的值就是影响这个队列的大小的。&lt;/p&gt;
&lt;p&gt;简单的来说就是设置最大等待队列的容量 以免造成并发太大的情况造成网络拥塞&lt;/p&gt;
&lt;h2 id=&#34;tcpip和udp报文结构和报头包含的内容&#34;&gt;TCP/IP和UDP报文结构和报头包含的内容！&lt;/h2&gt;
&lt;p&gt;源端口号&lt;/p&gt;
&lt;p&gt;目标端口号&lt;/p&gt;
&lt;p&gt;数据报长度&lt;/p&gt;
&lt;p&gt;校验值&lt;/p&gt;
&lt;h2 id=&#34;tcp和udp&#34;&gt;TCP和UDP&lt;/h2&gt;
&lt;h3 id=&#34;tcpudp-协议的区别&#34;&gt;TCP,UDP 协议的区别&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqiOa.png&#34; alt=&#34;dqiOa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;UDP 在传送数据之前不需要先建⽴连接，远地主机在收到 UDP 报⽂后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是⼀种最有效的⼯作⽅式（⼀般⽤于即时通信）⽐如： QQ 语⾳、 QQ 视频 、直播等等&lt;/p&gt;
&lt;p&gt;**TCP 提供⾯向连接的服务。**在传送数据之前必须先建⽴连接，数据传送结束后要释放连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 不提供⼴播或多播服务&lt;/strong&gt;。由于 TCP 要提供可靠的，⾯向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握⼿来建⽴连接，⽽且在数据传递时，有确认、窗⼝、重传、拥塞控制机制，在数据传完后，还会断开连接⽤来节约系统资源），这⼀难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的⾸部增⼤很多，还要占⽤许多处理机资源。&lt;/p&gt;
&lt;p&gt;TCP ⼀般⽤于&lt;strong&gt;⽂件传输、发送和接收邮件、远程登录&lt;/strong&gt;等场景。&lt;/p&gt;
&lt;h3 id=&#34;tcp-协议如何保证可靠传输&#34;&gt;TCP 协议如何保证可靠传输&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;应⽤数据被&lt;strong&gt;分割&lt;/strong&gt;成 TCP 认为最适合发送的数据块。&lt;/li&gt;
&lt;li&gt;TCP 给发送的每⼀个包进⾏&lt;strong&gt;编号&lt;/strong&gt;，&lt;strong&gt;接收⽅对数据包进⾏排序，把有序数据传送给应⽤层&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和&lt;/strong&gt;： TCP 将保持它&lt;strong&gt;⾸部和数据&lt;/strong&gt;的检验和。这是⼀个&lt;strong&gt;端到端&lt;/strong&gt;的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP 的接收端会丢弃重复的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制&lt;/strong&gt;： TCP 连接的每⼀⽅都有&lt;strong&gt;固定⼤⼩的缓冲空间&lt;/strong&gt;，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，防⽌包丢失。&lt;strong&gt;TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议&lt;/strong&gt;。 （TCP 利⽤滑动窗⼝实现流量控制）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制&lt;/strong&gt;： 当&lt;strong&gt;⽹络拥塞&lt;/strong&gt;时，&lt;strong&gt;减少数据的发送&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARQ协议&lt;/strong&gt;： 也是为了实现可靠传输的，它的基本原理就是&lt;strong&gt;每发完⼀个分组就停⽌发送，等待对⽅确认。在收到确认后再发下⼀个分组。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时重传&lt;/strong&gt;： 当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;简述tcp粘包现象&#34;&gt;简述TCP粘包现象&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP是面向流协议，发送的单位是字节流&lt;/strong&gt;，因此会存在将&lt;strong&gt;多个小尺寸数据被封装在一个tcp报文中发出去的可能性&lt;/strong&gt;。 可以简单的理解成&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;&lt;strong&gt;调用了两次send，服务器端一个recv就把信息都读出来了&lt;/strong&gt;。 简单来说将多份信息一次性发出去了&lt;/p&gt;
&lt;h3 id=&#34;tcp粘包现象处理方法&#34;&gt;TCP粘包现象处理方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;固定发送信息长度，或在两个信息之间加入分隔符&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;arq协议&#34;&gt;ARQ协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;⾃动重传请求（Automatic Repeat-reQuest，ARQ）&lt;strong&gt;是OSI模型中&lt;/strong&gt;数据链路层和传输层&lt;/strong&gt;的错误纠正协议之⼀。它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停⽌等待ARQ协议和连续ARQ协议。&lt;br&gt;
&lt;strong&gt;停⽌等待ARQ协议&lt;/strong&gt;&lt;br&gt;
停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收⽅收到重复分组，就丢弃该分组，但同时还要发送确认；&lt;br&gt;
&lt;strong&gt;优点&lt;/strong&gt;： 简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 信道利⽤率低，&lt;strong&gt;等待时间⻓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1) ⽆差错情况:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送⽅发送分组,接收⽅在规定时间内收到,并且回复确认.发送⽅再次发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 出现差错情况（超时重传）&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;停⽌等待协议中超时重传是指只要超过⼀段时间仍然没有收到确认，就重传前⾯发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完⼀个分组需要设置⼀个超时计时器，其重传时间应⽐数据在分组传输的平均往返时间更⻓⼀些。这种⾃动重传⽅式常称为 &lt;strong&gt;⾃动重传请求 ARQ&lt;/strong&gt;。另外在停⽌等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。&lt;strong&gt;连续 ARQ 协议&lt;/strong&gt; 可提⾼信道利⽤率。发送维持⼀个发送窗⼝，凡位于发送窗⼝内的分组可连续发送出去，⽽不需要等待对⽅确认。接收⽅⼀般采⽤累积确认，对按序到达的最后⼀个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。&lt;br&gt;
&lt;strong&gt;3) 确认丢失和确认迟到&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;确认丢失&lt;/strong&gt; ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了⼀个M1确认消息，但却在传输过程中丢失。⽽A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送&lt;br&gt;
确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息失）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认迟到&lt;/strong&gt; ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内&lt;br&gt;
没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第⼆次发送的确认消息。接着发送其他数据。过了⼀会，A收到了B第⼀次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续ARQ协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗⼝，凡位于发送窗⼝内的分组可以连续发送出去，⽽不需要等待对⽅确认。接收⽅⼀般采⽤累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为⽌的所有分组都已经正确收到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息。 ⽐如：发送⽅发送了 5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，⽽只好把后三个全部重传⼀次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个&lt;/p&gt;
&lt;h3 id=&#34;滑动窗口和流量控制&#34;&gt;滑动窗⼝和流量控制&lt;/h3&gt;
&lt;p&gt;TCP 利⽤滑动窗⼝实现流量控制。&lt;strong&gt;流量控制是为了控制发送⽅发送速率&lt;/strong&gt;，保证接收⽅来得及接收。 接收⽅发送的确认报⽂中的窗⼝字段可以⽤来控制发送⽅窗⼝⼤⼩，从⽽影响发送⽅的发送速率。将窗⼝字段设置为 0，则发送⽅不能发送数据。&lt;/p&gt;
&lt;h3 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h3&gt;
&lt;p&gt;在某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。拥塞控制所要做的都有⼀个前提，就是⽹络能够承受现有的⽹络负荷。拥塞控制是⼀个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低⽹络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。&lt;/p&gt;
&lt;p&gt;为了进⾏拥塞控制，TCP 发送⽅要维持⼀个 &lt;strong&gt;拥塞窗⼝&lt;/strong&gt;(cwnd) 的状态变量。拥塞控制窗⼝的⼤⼩取决于⽹络的拥塞程度，并且动态变化。发送⽅让⾃⼰的发送窗⼝取为拥塞窗⼝和接收⽅的接受窗⼝中较⼩的⼀个。&lt;/p&gt;
&lt;p&gt;TCP的拥塞控制采⽤了四种算法，即 &lt;strong&gt;慢开始 、 拥塞避免 、快重传 和 快恢复&lt;/strong&gt;。在⽹络层也可以使路由器采⽤适当的分组丢弃策略（如主动队列管理 AQM），以减少⽹络拥塞的发⽣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢开始&lt;/strong&gt;： 慢开始算法的思路是当主机开始发送数据时，如果⽴即把⼤量数据字节注⼊到⽹络，那么可能会引起⽹络阻塞，因为现在还不知道⽹络的符合情况。经验表明，较好的⽅法是先探测⼀下，即由⼩到⼤逐渐增⼤发送窗⼝，也就是由⼩到⼤逐渐增⼤拥塞窗⼝数值。cwnd初始值为1，每经过⼀个传播轮次，cwnd加倍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞避免&lt;/strong&gt;： 拥塞避免算法的思路是让拥塞窗⼝cwnd缓慢增⼤，即每经过⼀个往返时间RTT就把发送放的cwnd加1.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快重传与快恢复：&lt;/strong&gt;&lt;br&gt;
在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效地⼯作。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://note.mxecy.cn/docs/%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;tcp四次挥手后有一个timewait有什么用&#34;&gt;TCP四次挥手后有一个TIMEWAIT，有什么用？&lt;/h3&gt;
&lt;p&gt;（1）&lt;strong&gt;为实现TCP连接的可靠释放&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;保证最后一个ACK能到达服务器&lt;/strong&gt;，如果服务器没有收到客户端的确认报文，它会重新进行第四次挥手，这样客户端在2MSL内能收到重发的报文，并给出回应，重置2MSL计时器（MSL是Maximum Segment Lifetime英文的缩写,中文可以译为“报文最大生存时间”）&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;为使旧的重复数据包在网络中因过期而消失&lt;/strong&gt;&lt;br&gt;
服务端发送给客户端的一些报文在传输过程中由于网络拥堵而导致严重推迟，而在它到达客户端之前服务端已经重发了该报文，并完成其任务。如果在被推迟的报文未抵达前客户端就断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱，进而导致无法预知的情况。因此必须维持一段等待时间，使迟到的报文在网络中完全消失。这个时间可以时所有网络中的报文到达应该到的位置，新的连接中不会出现旧的连接的报文&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TIME_WAIT造成的危害&lt;/strong&gt;&lt;br&gt;
2.&lt;strong&gt;1 消耗资源&lt;/strong&gt;&lt;br&gt;
为释放的socket会占用&lt;strong&gt;内存、CPU、文件描述符数量&lt;/strong&gt;等等，还有一个时端口数量，在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！除非设置了端口重用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1开启重用 允许将TIME-WAIT sockets重新用于新的TCP连接&lt;/p&gt;
&lt;p&gt;2开启快速回收 开启TCP连接中TIME-WAIT sockets的快速回收&lt;/p&gt;
&lt;p&gt;3减少timewait的存活时间&lt;/p&gt;
&lt;p&gt;4.不主动关闭socket&lt;/p&gt;
&lt;p&gt;5短连接改为长连接&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;在浏览器中输入url地址-显示主的过程&#34;&gt;在浏览器中输⼊url地址 -&amp;gt;&amp;gt; 显示主⻚的过程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据域名，解析域名DNS&lt;/li&gt;
&lt;li&gt;拿到解析的IP地址，建立TCP连接&lt;/li&gt;
&lt;li&gt;向IP地址发送HTTP连接&lt;/li&gt;
&lt;li&gt;服务器处理请求&lt;/li&gt;
&lt;li&gt;服务器返回响应请求&lt;/li&gt;
&lt;li&gt;关闭TCP连接&lt;/li&gt;
&lt;li&gt;浏览器解析HTML&lt;/li&gt;
&lt;li&gt;浏览器渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述dns解析过程&#34;&gt;简述DNS解析过程&lt;/h3&gt;
&lt;p&gt;1、客户机发出查询请求，在本地&lt;strong&gt;计算机缓存&lt;/strong&gt;查找，若没有找到，就会将请求发送给本地dns服务器&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;本地dns服务器&lt;/strong&gt;会在自己的区域里面查找，找到即根据此记录进行解析。&lt;/p&gt;
&lt;p&gt;3、本地服务器没有找到客户机查询的信息，就会将此请求发送到&lt;strong&gt;根域名dns服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到&lt;strong&gt;客户机的dns服务器地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器&lt;/p&gt;
&lt;p&gt;6、这样&lt;strong&gt;递归&lt;/strong&gt;的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息&lt;/p&gt;
&lt;p&gt;7、&lt;strong&gt;客户机&lt;/strong&gt;的本地的dns服务器会将查询结果返回给我们的客户机&lt;/p&gt;
&lt;p&gt;8、客户机根据得到的ip信息访问目标主机，完成解析过程&lt;/p&gt;
&lt;h2 id=&#34;状态码&#34;&gt;状态码&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqn7S.png&#34; alt=&#34;dqn7S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2XX 成功&lt;/p&gt;
&lt;p&gt;· 200 OK，表示从客户端发来的请求在服务器端被正确处理&lt;/p&gt;
&lt;p&gt;· 204 No content，表示请求成功，但响应报文不含实体的主体部分&lt;/p&gt;
&lt;p&gt;· 206 Partial Content，进行范围请求&lt;/p&gt;
&lt;p&gt;3XX 重定向&lt;/p&gt;
&lt;p&gt;· 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· 302 found，临时性重定向，表示资源临时被分配了新的 URL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;· 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;· 307 temporary redirect，临时重定向，和302含义相同&lt;/p&gt;
&lt;p&gt;4XX 客户端错误&lt;/p&gt;
&lt;p&gt;· 400 bad request，请求报文存在语法错误&lt;/p&gt;
&lt;p&gt;· 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· 403 forbidden，表示对请求资源的访问被服务器拒绝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;· 404 not found，表示在服务器上没有找到请求的资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5XX 服务器错误&lt;/p&gt;
&lt;p&gt;502 网关错误 badgetway&lt;/p&gt;
&lt;p&gt;503 服务不可用是的一种状态 Service Unaviailable&lt;/p&gt;
&lt;p&gt;504 Getway Time-out 网关超时&lt;/p&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;h3 id=&#34;各种协议与http协议之间的关系&#34;&gt;各种协议与HTTP协议之间的关系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://img-blog.csdn.net/20180203130314494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzczMzExMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先发给DNS服务器，进行域名解析，得到IP地址后生成针对目标Web服务器的HTTP请求报文，然后报文由TCP协议负责传输，为了方便通信，HTTP请求报文被分为报文段，然后每个报文段可靠的传输给对方，然后报文段由IP层负责一边中转一遍传送，服务器收到报文段后重组报文段，然后由应用层的HTTP协议处理请求的内容，请求的结果以 同样的方式进行回传。&lt;/p&gt;
&lt;h3 id=&#34;转发和重定向的区别&#34;&gt;转发和重定向的区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;转发是服务器&lt;/strong&gt;行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，&lt;strong&gt;转发页面和转发到的页面可以共享request里面的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重定向是利用&lt;strong&gt;服务器返回的状态码来实现的&lt;/strong&gt;，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且&lt;strong&gt;不能共享数据&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;简述http10&#34;&gt;简述http1.0&lt;/h3&gt;
&lt;p&gt;规定了请求头和请求尾，响应头和响应尾（get post）  每一个请求都是&lt;strong&gt;一个单独的连接&lt;/strong&gt;，做不到&lt;strong&gt;连接的复用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;简述http11的改进&#34;&gt;简述http1.1的改进&lt;/h3&gt;
&lt;p&gt;HTTP1.1默认开启长连接，&lt;strong&gt;在一个TCP连接上可以传送多个HTTP请求和响应&lt;/strong&gt;。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持管道（pipeline）网络传输&lt;/strong&gt;，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。&lt;/p&gt;
&lt;p&gt;服务端无法主动push&lt;/p&gt;
&lt;h3 id=&#34;http2&#34;&gt;hTTP2&lt;/h3&gt;
&lt;h6 id=&#34;特性&#34;&gt;&lt;a href=&#34;https://note.mxecy.cn/#/./docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80?id=%E7%89%B9%E6%80%A7&#34;&gt;特性&lt;/a&gt;&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用二进制形式传输而非文本格式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;比起http1的文本传输，二进制解析起来更为&lt;strong&gt;高效.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;http2将请求和响应分割为更小的帧，并对其采用&lt;strong&gt;二进制编码&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了&lt;strong&gt;请求/响应阻塞&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用了报头压缩
&lt;ul&gt;
&lt;li&gt;压缩策略：
&lt;ul&gt;
&lt;li&gt;HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；&lt;/li&gt;
&lt;li&gt;首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;&lt;/li&gt;
&lt;li&gt;每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多路复用：
&lt;ul&gt;
&lt;li&gt;特性：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同域名下所有通信都在单个连接上完成&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;单个连接可以承载任意数量的双向数据流。&lt;/li&gt;
&lt;li&gt;数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;单个连接上可以并行交错的请求和响应，之间互不干扰。&lt;/li&gt;
&lt;li&gt;在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Server Push：
&lt;ul&gt;
&lt;li&gt;服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为&amp;quot;服务器推送&amp;quot;（ Server Push，也叫 Cache push）
&lt;ul&gt;
&lt;li&gt;服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3&#34;&gt;&lt;a href=&#34;https://note.mxecy.cn/#/./docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80?id=http3&#34;&gt;HTTP3&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;相比与HTTP2使用的TCP协议，HTTP3使用了&lt;strong&gt;UDP协议，并且通过QUIC协议来保证连接的可靠性。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简述tlsssl-http-https的关系&#34;&gt;简述TLS/SSL, HTTP, HTTPS的关系&lt;/h3&gt;
&lt;p&gt;SSL全称为Secure Sockets Layer即&lt;strong&gt;安全套接层&lt;/strong&gt;，其继任为TLSTransport Layer Security&lt;strong&gt;传输层安全协议&lt;/strong&gt;，均用于在&lt;strong&gt;传输层&lt;/strong&gt;为数据通讯提供安全支持。&lt;/p&gt;
&lt;p&gt;可以将HTTPS协议简单理解为&lt;strong&gt;HTTP协议＋TLS/SSL&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;https的连接过程&#34;&gt;https的连接过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;浏览器将支持的加密&lt;a href=&#34;&#34;&gt;算法&lt;/a&gt;信息发给服务器&lt;/li&gt;
&lt;li&gt;服务器选择一套浏览器支持的加密&lt;a href=&#34;&#34;&gt;算法&lt;/a&gt;，以证书的形式回发给浏览器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;(SSL/TLS)解析证书验证证书合法性，生成&lt;strong&gt;对称加密&lt;/strong&gt;的密钥，我们将该密钥称之为client key，即&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;密钥，用服务器的公钥对&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;密钥进行&lt;strong&gt;非对称加密&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;会发起HTTPS中的第二个HTTP请求，将加密之后的&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;对称密钥发送给服务器&lt;/li&gt;
&lt;li&gt;服务器接收到&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;密钥，然后用&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;密钥对数据进行对称加密，这样数据就变成了密文。&lt;/li&gt;
&lt;li&gt;服务器将加密后的密文发送给&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;收到服务器发送来的密文，用&lt;a href=&#34;&#34;&gt;客户端&lt;/a&gt;密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;简述http20的改进&#34;&gt;简述http2.0的改进&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;提出多路复用&lt;/strong&gt;。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。&lt;strong&gt;引入多路复用，a文件b文件可以同时传输&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本传输改成了二进制传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传&lt;/p&gt;
&lt;h3 id=&#34;http连接短连接&#34;&gt;HTTP⻓连接,短连接&lt;/h3&gt;
&lt;p&gt;在HTTP/1.0中默认使⽤短连接。也就是说，客户端和服务器每进⾏⼀次HTTP操作，就建⽴⼀次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其他的Web资源（如JavaScript⽂件、图像⽂件、CSS⽂件等），每遇到这样⼀个Web资源，浏览器就会重新建⽴⼀个HTTP会话。&lt;/p&gt;
&lt;p&gt;⽽从HTTP/1.1起，默认使⽤&lt;strong&gt;⻓连接，⽤以保持连接特性&lt;/strong&gt;。使⽤⻓连接的HTTP协议，会在响应头加⼊这⾏代码：&lt;/p&gt;
&lt;p&gt;Connection keep -alive&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq1LN.png&#34; alt=&#34;dq1LN.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的&lt;br&gt;
TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。KeepAlive不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客户端和服务端都⽀持⻓连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;http是不保存状态的协议如何保存用户状态&#34;&gt;HTTP是不保存状态的协议,如何保存⽤户状态?&lt;/h3&gt;
&lt;p&gt;HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。那么我们保存⽤户状态呢？Session 机制的存在就是为了解决这个问题，&lt;strong&gt;Session&lt;/strong&gt; 的主要作⽤就是通过&lt;strong&gt;服务端记录⽤户的状态&lt;/strong&gt;。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。在服务端保存 Session 的⽅法很多，最常⽤的就是内存和数据库(⽐如是使⽤内存数据库redis保存)。既然 Session 存放在服务器端，&lt;/p&gt;
&lt;p&gt;那么我们如何实现 Session 跟踪呢？⼤部分情况下，我们都是通过在 Cookie 中附加⼀个 &lt;strong&gt;Session ID&lt;/strong&gt; 来⽅式来跟踪。&lt;/p&gt;
&lt;h3 id=&#34;http-10和http-11的主要区别是什么&#34;&gt;HTTP 1.0和HTTP 1.1的主要区别是什么?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;⻓连接 :&lt;/strong&gt; 在HTTP/1.0中,默认使用的是短连接,也就是说每次请求都要重新建立一次连接。 HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销,如 果每次请求都要这样的话,开销会比较大。因此最好能维持一个⻓连接,可以用个⻓连接来发多个请求。HTTP 1.1起,默认使用⻓连接 ,默认开启Connection: keep-alive。 HTTP/1.1 的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前 就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发 送下一个请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误状态响应码&lt;/strong&gt; :在HTTP1.1中新增了24个错误状态响应码,如409(Conflict)表示请求的 资源与资源的当前状态发生冲突;410(Gone)表示服务器上的某个资源被永久性的删除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存处理&lt;/strong&gt; :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标 准,HTTP1.1则引入了更多的缓存控制策略例如Entity tag,If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带宽优化及网络连接的使用&lt;/strong&gt; :HTTP1.0中,存在一些浪费带宽的现象,例如客户端只是需要 某个对象的一部分,而服务器却将整个对象送过来了,并且不支持断点续传功能,HTTP1.1 则在请求头引入了&lt;strong&gt;range头域,它允许只请求资源的某个部分&lt;/strong&gt;,即返回码是206(Partial Content),这样就方便了开发者自由的选择以便于充分利用带宽和连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个-tcp-连接可以对应几个-http-请求提示这在问你http10和11的区别&#34;&gt;一个 TCP 连接可以对应几个 HTTP 请求？(提示，这在问你HTTP1.0和1.1的区别)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果keep-alive的话可以发送多个请求。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个-tcp-连接中-http-请求发送可以一起发送么比如一起发三个请求再三个响应一起接收提示这就是在问你http20和http11协议的区别&#34;&gt;一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？(提示，这就是在问你HTTP2.0和HTTP1.1协议的区别)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;HTTP/1.1&lt;/strong&gt; 存在 &lt;strong&gt;Pipelining&lt;/strong&gt;  流水线技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;HTTP2 中由于 Multiplexing  多路复用特点的存在&lt;/strong&gt;，&lt;strong&gt;多个 HTTP 请求可以在同一个 TCP 连接中并行进行&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浏览器对同一host建立tcp连接到数量有没有限制&#34;&gt;浏览器对同一Host建立TCP连接到数量有没有限制？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不同浏览器支持不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-和-https-的区别&#34;&gt;HTTP 和 HTTPS 的区别？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;端⼝ ：HTTP的URL由“http://”起始且默认使⽤端⼝&lt;strong&gt;80&lt;/strong&gt;，⽽HTTPS的URL由“https://”起始且默认使⽤端⼝&lt;strong&gt;443&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性和资源消耗： &lt;strong&gt;HTTP协议运⾏在TCP&lt;/strong&gt;之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。HTTPS是运⾏在&lt;strong&gt;SSL/TLS&lt;/strong&gt;之上的HTTP协议，&lt;strong&gt;SSL/TLS 运⾏在TCP之&lt;/strong&gt;上。所有传输的内容都经过加密**，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密**。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密算法有DES、AES等；&lt;br&gt;
&lt;strong&gt;⾮对称加密&lt;/strong&gt;：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），&lt;br&gt;
加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称&lt;br&gt;
加密速度较慢，典型的⾮对称加密算法有RSA、DSA&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cookie和session&#34;&gt;Cookie和Session&lt;/h2&gt;
&lt;h3 id=&#34;cookie的作用是什么和session有什么区别&#34;&gt;Cookie的作⽤是什么?和Session有什么区别&lt;/h3&gt;
&lt;p&gt;Cookie ⼀般⽤来保存⽤户信息 ⽐如&lt;/p&gt;
&lt;p&gt;①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；&lt;/p&gt;
&lt;p&gt;②⼀般的⽹站都会有保持登录也就是说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token 重写)；&lt;/p&gt;
&lt;p&gt;登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。Session 的主要作⽤就是通过服务端记录⽤户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。&lt;/p&gt;
&lt;h3 id=&#34;cookie-被禁用怎么办&#34;&gt;Cookie 被禁用怎么办&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最常用的就是利用 &lt;strong&gt;URL 重写把 Session ID 直接附加在URL路径&lt;/strong&gt;的后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uri和url的区别&#34;&gt;URI和URL的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;URI(Uniform Resource Identifier) 是&lt;strong&gt;统⼀资源标志符&lt;/strong&gt;，可以唯⼀标识⼀个资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL(Uniform Resource Location) 是&lt;strong&gt;统⼀资源定位符&lt;/strong&gt;，可以提供该资源的路径。它是⼀种具体的 URI，即 URL 可以⽤来标识⼀个资源，⽽且还指明了如何 locate 这个资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连不上网排查&#34;&gt;连不上网排查&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过ping dns服务器，如果能ping通说明到互联网的路由没有问题
&lt;ul&gt;
&lt;li&gt;相关协议：&lt;strong&gt;ICMP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用nslookup 域名，查看是否能够获取到ip地址，如果不能则是dns问题（应用层）&lt;/li&gt;
&lt;li&gt;使用telnet 域名 端口，如果不能则是TCP问题（传输层）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ICMP协议是一个网络层协议。&lt;br&gt;
一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。&lt;br&gt;
所以我们就需要一种协议来完成这样的功能–ICMP协议。&lt;/p&gt;
&lt;p&gt;ICMP协议的功能&lt;/p&gt;
&lt;p&gt;ICMP协议的功能主要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确认IP包是否成功到达目标地址&lt;/li&gt;
&lt;li&gt;通知在发送过程中IP包被丢弃的原因&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;网络性能指标&#34;&gt;网络性能指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;速率&lt;/strong&gt;：单位比特，指的是数据的传送速率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带宽&lt;/strong&gt;：单位时间内网络中某信道所能通过的最高数据率，单位是bit/s&lt;/li&gt;
&lt;li&gt;吞吐率：单位时间内通过某网络的数据量&lt;/li&gt;
&lt;li&gt;时延：指数据从网络的一端到另外一端所需的时间
&lt;ul&gt;
&lt;li&gt;发送时延：发送时延=数据帧长度/发送速率&lt;/li&gt;
&lt;li&gt;传播时延：传播时延=信号长度/在信道上的传播速率&lt;/li&gt;
&lt;li&gt;处理时延&lt;/li&gt;
&lt;li&gt;排队时延&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时延带宽积：时延带宽积=传播时延x带宽。又称以比特位单位的链路长度&lt;/li&gt;
&lt;li&gt;往返时间：RT&lt;/li&gt;
&lt;li&gt;利用率
&lt;ul&gt;
&lt;li&gt;信道利用率&lt;/li&gt;
&lt;li&gt;网络利用率：全网络信道利用率的加权平均&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get请求和post请求的区别&#34;&gt;Get请求和Post请求的区别&lt;/h2&gt;
&lt;p&gt;对于GET方式的请求，浏览器会把&lt;strong&gt;http header和data一并发送出去&lt;/strong&gt;，&lt;strong&gt;服务器响应200（返回数据）&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;而对于POST，浏览器&lt;strong&gt;先发送header&lt;/strong&gt;，服务器先响应&lt;strong&gt;100 continue&lt;/strong&gt;，浏览器&lt;strong&gt;再发送data&lt;/strong&gt;，服务器&lt;strong&gt;响应200 ok（返回数据）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;GET产生&lt;strong&gt;一个TCP数据包&lt;/strong&gt;；POST产生&lt;strong&gt;两个TCP数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本质上来说这两个请求都是通过tcp/ip 协议 只是具体的应用不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;数据传输方式不同：GET请求通过&lt;strong&gt;URL&lt;/strong&gt;传输数据，而POST的数据通过&lt;strong&gt;请求体&lt;/strong&gt;传输。&lt;/li&gt;
&lt;li&gt;安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。&lt;/li&gt;
&lt;li&gt;数据类型不同：&lt;strong&gt;GET只允许 ASCII 字符，而POST无限制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单&lt;/li&gt;
&lt;li&gt;特性不同：GET是安全（这里的安全是指&lt;strong&gt;只读&lt;/strong&gt;特性，就是使用这个方法&lt;strong&gt;不会引起服务器状态变化&lt;/strong&gt;）且幂等（&lt;strong&gt;幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同&lt;/strong&gt;），而POST是非安全非幂等
&lt;ul&gt;
&lt;li&gt;POST的两次提交对应的是新增两个内容，不是幂等的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get和post的使用场景&#34;&gt;Get和Post的使用场景&lt;/h2&gt;
&lt;p&gt;当请求无副作用时（如进行&lt;strong&gt;搜索&lt;/strong&gt;），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的&lt;strong&gt;URL&lt;/strong&gt;，或许会超过某些浏览器与服务器对URL长度的限制。&lt;/p&gt;
&lt;p&gt;若符合下列任一情况，则用POST方法：&lt;/p&gt;
&lt;p&gt;请求的结果有持续性的副作用，例如，数据库内添加新的数据行。&lt;br&gt;
若使用GET方法，则表单上收集的数据可能让URL过长。&lt;br&gt;
要传送的数据不是采用7位的ASCII编码。&lt;/p&gt;
&lt;p&gt;若符合下列任一情况，则用GET方法：&lt;/p&gt;
&lt;p&gt;请求是为了&lt;strong&gt;查找资源&lt;/strong&gt;，HTML表单数据仅用来帮助搜索。&lt;br&gt;
请求结果无持续性的副作用。&lt;/p&gt;
&lt;p&gt;\收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。&lt;/p&gt;
&lt;h2 id=&#34;rest-api&#34;&gt;REST API&lt;/h2&gt;
&lt;p&gt;REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create ： POST&lt;/li&gt;
&lt;li&gt;Read ： GET&lt;/li&gt;
&lt;li&gt;Update ： PUT/PATCH&lt;/li&gt;
&lt;li&gt;Delete： DELETE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xss过滤攻击&#34;&gt;XSS过滤攻击&lt;/h2&gt;
&lt;h3 id=&#34;xss&#34;&gt;XSS&lt;/h3&gt;
&lt;p&gt;XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意的特殊目的。XSS属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。&lt;/p&gt;
&lt;p&gt;在WEB2.0时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。&lt;/p&gt;
&lt;h3 id=&#34;xss攻击的主要途径&#34;&gt;XSS攻击的主要途径&lt;/h3&gt;
&lt;p&gt;XSS攻击方法只是利用HTML的属性，作各种的尝试，找出注入的方法。现在对三种主要方式进行分析。&lt;br&gt;
第一种：对普通的用户输入，页面原样内容输出。&lt;/p&gt;
&lt;p&gt;打开http://go.ent.163.com/goproducttest/test.jsp(限公司IP)，输 入：&lt;/p&gt;
&lt;p&gt;第二种：在代码区里有用户输入的内容&lt;/p&gt;
&lt;p&gt;原则就是，代码区中，绝对不应含有用户输入的东西。&lt;/p&gt;
&lt;p&gt;第三种：允许用户输入HTML标签的页面。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq7XC.png&#34; alt=&#34;dq7XC.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;xss攻击解决办法&#34;&gt;XSS攻击解决办法&lt;/h3&gt;
&lt;p&gt;请记住两条原则：&lt;strong&gt;过滤输入和转义输出&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体执行的方式有以下几点：&lt;br&gt;
第一、在输入方面对所有用户提交内容进行可靠的输入验证，提交内容包括URL、查询关键字、http头、post数据等&lt;/p&gt;
&lt;p&gt;第二、在输出方面，在用户输内容中使用标签。标签内的内容不会解释，直接显示。&lt;/p&gt;
&lt;p&gt;第三、严格执行字符输入字数控制。&lt;/p&gt;
&lt;p&gt;四、在脚本执行区中，应绝无用户输入。&lt;/p&gt;
&lt;h2 id=&#34;dns记录类型&#34;&gt;DNS记录类型&lt;/h2&gt;
&lt;p&gt;参考：https://blog.csdn.net/u013920085/article/details/42552987&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;A记录：（WEB服务器的IP指向 ）：A （Address）记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 简单的说，A记录是指定域名对应的IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AAAA记录：该记录是将域名解析到一个指定的IPV6的IP上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CNAME记录：通常称别名解析。可以将注册的不同域名都转到一个域名记录上，由这个域名记录统一解析管理，与A记录不同的是，CNAME别名记录设置的可以是一个域名的描述而不一定是IP地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NS记录 ：NS（Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。 您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个DNS域名服务器来进行解析的，DNS服务器NS记录地址一般以以下的形式出现： ns1.domain.com、ns2.domain.com等。 简单的说，NS记录是指定由哪个DNS服务器解析你的域名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MX记录 ：MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TXT记录：TXT记录，一般指某个主机名或域名的说明，如：admin IN TXT &amp;quot;管理员, 电话：XXXXXXXXXXX&amp;quot;，mail IN TXT &amp;quot;邮件主机，存放在xxx , 管理人：AAA&amp;quot;，Jim IN TXT &amp;quot;contact: abc@mailserver.com&amp;quot;，也就是您可以设置 TXT 内容以便使别人联系到您。 TXT的应用之一，SPF（Sender Policy Framework）反垃圾邮件。SPF是跟DNS相关的一项技术，它的内容写在DNS的TXT类型的记录里面。MX记录的作用是给寄信者指明某个域名的邮件服务器有哪些。SPF的作用跟MX相反，它向收信者表明，哪些邮件服务器是经过某个域名认可会发送邮件的。SPF的作用主要是反垃圾邮件，主要针对那些发信人伪造域名的垃圾邮件。例如：当邮件服务器收到自称发件人是spam@gmail.com的邮件，那么到底它是不是真的gmail.com的邮件服务器发过来的呢，我们可以查询gmail.com的SPF记录，以此防止别人伪造你来发邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PTR记录：PTR是pointer 的简写。 &amp;quot;PTR&amp;quot;就是&amp;quot;反向DNS&amp;quot;,&lt;br&gt;
domain name pointer，可以粗略的理解为DNS反向&lt;br&gt;
Domain Name Pointer. 是一个指针记录，用于将一个IP地址映射到对应的主机名,也可以看成是A记录的反向,通过IP访问域名,原来是通过域名访问IP)&lt;br&gt;
如何顺利做好反向解析？首先要有固定公网IP地址、可用域名（最好不要被其它服务所用），例如您有lunch-time.com的域名，您可以要求您的域名注册商为您添加一个okmail.lunch-time.com的域名　　并将其A记录指向您的SMTP服务器出口公网IP地址，如：220.112.20.18，接着请与您的固定IP所属ISP联系要求为您的IP反向解析至okmail.lunch-time.com。完成后别忘了将您的SMTP服务器的HELO域名改为okmail.lunch-time.com，这样才可以达到目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">计算机网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/ji-ben-suan-fa/"" data-c="
          &lt;h1 id=&#34;比较算法&#34;&gt;比较算法&lt;/h1&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;p&gt;实现代码(逆序)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;

public class BubbleSort {
    //排序方法
    public static void bubbleSort(int[] arr) {
        if(arr == null || arr.length == 0)
            return ;
        for(int i=0; i&amp;lt;arr.length;i++) {
            //如果内循环的索引大于外层的就无法进行排序了
            for(int j=arr.length-1; j&amp;gt;i; j--) {
                if(arr[j]&amp;lt;arr[j-1]) {
                    swap(arr, j-1, j);
                }
            }
        }
    }
    //交换方法
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{....};
        bubbleSort(arr);
        for (int i : arr) {
            System.out.print(&amp;quot; &amp;quot;+i);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正序实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;
/*
 *@Description:冒泡排序算法实现（正序）
 */
public class BubbleSort2 {
    public static void bubbleSort(int[] arr) {
        if(arr == null || arr.length == 0)
            return ;
        for(int i=1;i&amp;lt;arr.length;i++) {
           //当内循环小于数组的长度再减去i的时候就退出
            for(int j=0; j&amp;lt;arr.length-i; j++) {
                if(arr[j]&amp;gt;arr[j+1]) {
                    swap(arr, j+1, j);
                }
            }
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{....};
        bubbleSort(arr);
        for (int i : arr) {
            System.out.print(&amp;quot; &amp;quot;+i);
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;p&gt;实现代码（正序) ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;
/*
@Description 正序的选择排序算法
 */
public class SelectSort {
    public static void selectSort(int[] arr) {
        if(arr == null || arr.length == 0)
            return ;
        //先定义最小的数字

        for(int i=0; i&amp;lt;arr.length;i++){//只需要比较n-1次
            //先定义最小值的索引 从0开始
            int minIndex = i;
            for(int j=i+1; j&amp;lt;arr.length;j++)
            {
            //从i+1开始比较，因为minIndex默认为i了就是0，i就没必要比了。
                //判断前面的值是否小于后面
                if(arr[j]&amp;lt;arr[minIndex])
                {
                    //如果前面的数字 小于后面的值就将后面的索引和之前的交换
                    minIndex = j;
                }
            }
            //当内循环找到最小值的时候才进行一次交换
            if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，执行交换的方法
                swap(arr, i, minIndex);
            }
    }
}
public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        }

    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{5,4,8,6,3,2,2};
        selectSort(arr);
        for (int i : arr) {
            System.out.print(&amp;quot; &amp;quot;+i);
        }
    }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;
/**
 *@Description:简单插入排序算法实现(正序)
 */
public class InsertSort {
    public static void insertSort(int[] a) {
        int i, j, insertNote;// 要插入的数据
        for (i = 1; i &amp;lt; a.length; i++) {// 从数组的第二个元素开始循环将数组中的元素插入
            insertNote = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据 依次往后
            j = i - 1;
            //不断的判断插入的元素是否小于前面的所有元素 是的话就循环将元素往右边放
            while (j &amp;gt;= 0 &amp;amp;&amp;amp; insertNote &amp;lt; a[j]) {
                a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动
                j--;
            }
            a[j + 1] = insertNote;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中
        }
    }


    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{3,5,4,8,6,3};
        insertSort(arr);
        for (int i : arr) {
            System.out.print(&amp;quot; &amp;quot;+i);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;

public class ShellSort {


    public static int[] shellSort(int[] array){
        //控制步长，每循环一次就除二
        for (int n = array.length/2; n &amp;gt; 0; n /= 2 ){
            //从下标为步长的元素开始，依次向后循环
            
            //不用担心前面的元素，因为下面j层的循环，会依次和前面的数字进行比较。

            for (int i = n; i &amp;lt; array.length; i++) {
                // 从下标为[步长]的数字开始，向前 隔一个步长 进行比较
                // 如果后一个比前一个小，则交换，如果不是，则返回上一层循环，
                // i+1后再进行【如果后一个比前一个小，则交换】的比较
                // 之后j-n，再和一开始位置的两个步长距离的数字进行比较
                // 如此反复
                for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; j-n &amp;gt;= 0 &amp;amp;&amp;amp; array[j] &amp;lt; array[j-n]; j-=n) {
                    int temp = array[j];
                    array[j] = array[j-n];
                    array[j-n] = temp;
                }
            }
        }
        return array;
    }
    public static void main(String[] args) {
        int[] array = {3,5,4,8,6,3};
        int[] ints = shellSort(array);
        for (int anInt : ints) {
            System.out.print(&amp;quot; &amp;quot;+anInt);
        }
//        int[] array = new int[80000];
//        for (int i = 0; i &amp;lt; array.length; i++) {
//            array[i] = (int)(Math.random()*800000);
//        }
        long startTime=System.currentTimeMillis();
        shellSort(array);
        long endTime=System.currentTimeMillis();
        System.out.println(&amp;quot;  程序运行时间： &amp;quot;+(endTime - startTime)+&amp;quot;ms&amp;quot;);
        //希尔排序排序80k长度的数组，在我这台电脑上只用了不到0.1秒，而插入排序则需要2秒多
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Random;
/**
 * 912. 排序数组 快排 三指针
 * https://leetcode.cn/problems/sort-an-array/description/
 */
public class sortArray {
        // 快速排序 3：三指针快速排序
        /**
         * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序
         */
        private static final int INSERTION_SORT_THRESHOLD = 7;

        private  final Random RANDOM = new Random();

        public int[] sortArray(int[] nums) {
            int len = nums.length;
            quickSort(nums, 0, len - 1);
            return nums;
        }

        private void quickSort(int[] nums, int left, int right) {
            // 小区间使用插入排序
            if (right - left &amp;lt;= INSERTION_SORT_THRESHOLD) {
                insertionSort(nums, left, right);
//                这里记得return掉 否则会抛异常
                return;
            }
            // 产生[left,right]的某个索引
            int randomIndex = left + RANDOM.nextInt(right - left + 1);
            swap(nums, randomIndex, left);

            // 循环不变量：
            // all in [left + 1, lt] &amp;lt; pivot
            // all in [lt + 1, i) = pivot
            // all in [gt, right] &amp;gt; pivot
//            哨兵
            int pivot = nums[left];
            int lt = left;
            int gt = right + 1;

            int i = left + 1;
            //当i==gt的时，第二个数组和第三个数组还没连起来，所以循环还应该继续
            while (i &amp;lt; gt) {
                if (nums[i] &amp;lt; pivot) {
                    lt++;
                    swap(nums, i, lt);
                    i++;
                } else if (nums[i] == pivot) {
                    i++;
                } else {
                    gt--;
                    swap(nums, i, gt);
                }
            }
            swap(nums, left, lt);
            // 注意这里，大大减少了两侧分治的区间
            quickSort(nums, left, lt - 1);
            quickSort(nums, gt, right);
        }

        /**
         * 对数组 nums 的子区间 [left, right] 使用插入排序
         *
         * @param nums  给定数组
         * @param left  左边界，能取到
         * @param right 右边界，能取到
         */
        private void insertionSort(int[] nums, int left, int right) {
            for (int i = left + 1; i &amp;lt;= right; i++) {
                int insertNumber = nums[i];
                int j = i;
                while (j &amp;gt; left &amp;amp;&amp;amp; nums[j - 1] &amp;gt; insertNumber) {
                    nums[j] = nums[j - 1];
                    j--;
                }
                nums[j] = insertNumber;
            }
        }

        private void swap(int[] nums, int index1, int index2) {
            int temp = nums[index1];
            nums[index1] = nums[index2];
            nums[index2] = temp;
        }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;

public class MergeSort {
    //两路归并算法，两个排好序的子序列合并为一个子序列
    //mid为取子序列前面和后面之和的对半索引
    public static void merge(int[] a, int left, int mid, int right){
        int []tmp=new int[a.length];//辅助数组 将改变的子序列复制到a数组当中
        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针 通过k的索引赋值到temp的数组上面
        //当子序列的索引都小于检测指针进行循环
        while(p1&amp;lt;=mid &amp;amp;&amp;amp; p2&amp;lt;=right){
            if(a[p1]&amp;lt;=a[p2])
                //如果前面值小于后面的 就把前面的值先放到辅助数组当中
                tmp[k++]=a[p1++];
            else
                //否则就将后面的值放到辅助数组当中
                tmp[k++]=a[p2++];
        }
        
        while(p1&amp;lt;=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中
        
        while(p2&amp;lt;=right) tmp[k++]=a[p2++];//同上

        //复制回原素组
        for (int i = left; i &amp;lt;=right; i++)
            a[i]=tmp[i];
    }

    public static void mergeSort(int[] a, int start, int end){
        //递归调用函数 先把子序列分完再开始排序
        if(start&amp;lt;end){//当子序列中只有一个元素时结束递归
            int mid=(start+end)/2;//划分子序列
            mergeSort(a, start, mid);//对左侧子序列进行递归排序
            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序
            merge(a, start, mid, end);//合并 完成一次排序合并就会satrt 和mid 还有end 的值都会增加 两两元素之间发生交交换
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;

import java.util.Arrays;

public class HeapSort {
        //大函数
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i=arr.length/2-1;i&amp;gt;=0;i--){
            //从最后一个非叶子结点开始（arr.length/2-1） 从下至上，从右至左调整结构 一直到找到最后的非叶子结点 最后也就到了0索引为0的那里
            //循环执行调用调大顶堆的函数
            adjustHeap(arr,i,arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j=arr.length-1;j&amp;gt;0;j--){
            //j-1 的原因是交换完就最后一个元素后 除去最后一个元素并对剩下的元素进行重新堆积大顶堆
            swap(arr,0,j);//将堆顶元素与末尾元素进行交换

            adjustHeap(arr,0,j);//对重新对堆进行调整
        }

    }

    /**
     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
     * @param arr
     * @param i
     * @param length
     */
            //调整大顶堆函数
    public static void adjustHeap(int []arr,int i,int length){
        int temp = arr[i];//先取出当前元素i 也就是父节点 2k+1的原因调整因为交换元素的大顶堆 使其满足大顶堆定义
        for(int k=i*2+1;k&amp;lt;length;k=k*2+1){//从i结点的左子结点开始，也就是2i+1处开始
            //k为i结点的子节点的第一个结点 也就是左子节点
            //判断找出最大的子节点
            if(k+1&amp;lt;length &amp;amp;&amp;amp; arr[k]&amp;lt;arr[k+1]){
                //如果没有右结点的时候直接进行下面的比较
                //如果左子结点小于右子结点，k指向右子结 然后将索引+1
                k++;
            }
            //最后将那个最大的子节点
            if(arr[k] &amp;gt;temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） 并将当前的子节点变为子节点然后回到上面的循环再与其子节点进行比较
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }

    /**
     * 交换元素
     * @param arr
     * @param a
     * @param b
     */

        //交换函数
    public static void swap(int []arr,int a ,int b){
        int temp=arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;非比较算法&#34;&gt;非比较算法&lt;/h1&gt;
&lt;h2 id=&#34;比较和非比较的区别&#34;&gt;比较和非比较的区别&lt;/h2&gt;
&lt;p&gt;常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。&lt;br&gt;
在&lt;strong&gt;冒泡排序&lt;/strong&gt;之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在&lt;strong&gt;归并排序、快速排序&lt;/strong&gt;之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均&lt;strong&gt;O(nlogn)&lt;/strong&gt;。&lt;br&gt;
比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。&lt;/p&gt;
&lt;p&gt;计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。&lt;br&gt;
非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度&lt;strong&gt;O(n)&lt;/strong&gt;。&lt;br&gt;
非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。&lt;/p&gt;
&lt;h2 id=&#34;计数排序&#34;&gt;计数排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;

public class CountSort {
    public static int[] countSort1(int[] arr){
        if (arr == null || arr.length == 0) {
            return null;
        }
        //定义待排数组中的最大值 先将其最小为为最大的值 这样肯定有比它大的数 然后返回更大的值
        int max = Integer.MIN_VALUE;
        //定义待排数组中的最小值 先将其最小为为最小的值 这样肯定有比它小的数 然后返回更小的值
        int min = Integer.MAX_VALUE;
        //根据Math函数找出数组中的最大最小值
        for(int i = 0; i &amp;lt; arr.length; i++){

            max = Math.max(max, arr[i]);

            min = Math.min(min, arr[i]);
        }
        //辅助计数数组 help该数组大小为待排序数组中的最大值减最小值+1 保证了如果是以步长为1增的数字都能够排在数组当中
        int help[] = new int[max-min+1];
        //找出每个数字出现的次数 从索引为0的开始
        for(int i = 0; i &amp;lt; arr.length; i++){
            //position 为索引的位置
            int position= arr[i] - min;

            //有这个数的话在索引上的值+1
            help[position]++;
        }
        int index = 0;
        for(int i = 0; i &amp;lt; help.length; i++){
            //如果数组上有此值 按照个数依次将他排完
            while(help[i]-- &amp;gt; 0){
                //从最小值开始加起来 因为最小值排在最前面  然后根据出现的位置进行排序 就可以将正确的顺序排放下去了
                //arr[index++]的值为当前的索引值加上最小值 
                arr[index++] = i+min;
            }
        }
        return arr;
    }

    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{3,5,4,8,6,3};
        countSort1(arr);
        for (int i : arr) {
            System.out.print(&amp;quot; &amp;quot;+i);
        }
    }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;桶排序&#34;&gt;桶排序&lt;/h2&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.lin;
import java.util.ArrayList;
import java.util.Collections;
public class BucketSort {
    public static void bucketSort(int[] arr) {

        int max = Integer.MIN_VALUE;

        int min = Integer.MAX_VALUE;
        //找出待排序数组中的最大值max、最小值min
        for (int i = 0; i &amp;lt; arr.length; i++) {

            max = Math.max(max, arr[i]);

            min = Math.min(min, arr[i]);
        }

        //桶数
        int bucketNum = (max - min) / arr.length + 1;
        //创建动态ArrayList数组作为桶 桶里面放的元素也用ArrayList 储存
        //数组当中的元素声明为整形
        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; bucketArr = new ArrayList&amp;lt;&amp;gt;(bucketNum);
        for (int i = 0; i &amp;lt; bucketNum; i++) {
            bucketArr.add(new ArrayList&amp;lt;Integer&amp;gt;());
        }

        //将每个元素放入桶
        for (int i = 0; i &amp;lt; arr.length; i++) {

            int num = (arr[i] - min) / (arr.length);
            bucketArr.get(num).add(arr[i]);

        }

        //对每个桶进行排序
        for (int i = 0; i &amp;lt; bucketArr.size(); i++) {
            Collections.sort(bucketArr.get(i));
        }
        System.out.println(bucketArr.toString());

    }

    public static void main(String[] args) {
        int[] arr;
        arr = new int[]{1,8,7,44,42,46,38,34,33,17,15,16,27,28,24};
        bucketSort(arr);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;冒泡排序，插入排序，是稳定的排序算法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不稳定算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择排序，希尔排序，堆排序，归并排序，快速排序不稳定的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;稳定性&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;空间复杂度&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;冒泡&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;td&gt;O(n*n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;适用的情景为数据量量不大，对稳定性有要求，且数据基本有序的情况下&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;分布散乱随机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;td&gt;O(n*n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;适用于数据量不大，对算法的稳定性有要求，且数据局部或者整体有序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选择&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;O(n*n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;当数据量不大，且对稳定性没有要求的时候，适用于选择排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(nlogn)到O(n)&lt;/td&gt;
&lt;td&gt;分布散乱随机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;桶&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;仅适用于数据的分布相对比较集中的时候，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;堆&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;O(nlog)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;希尔&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;O(nlogn)到O(n*n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;其排序的效率受到比较距离大小的影响&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;查找顺序速度&#34;&gt;查找顺序速度&lt;/h2&gt;
&lt;p&gt;顺序 分块 折半 哈希&lt;/p&gt;
&lt;p&gt;顺序查找的时间复杂度为o(n)&lt;/p&gt;
&lt;p&gt;分块查找的时间复杂度为o(logn)到o(n)之间&lt;/p&gt;
&lt;p&gt;二分查找的时间复杂度为o(log n)&lt;/p&gt;
&lt;p&gt;哈希查找的时间复杂度为o(1)&lt;/p&gt;
">基本算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/ji-he/"" data-c="
          &lt;h2 id=&#34;listsetmap三者的区别&#34;&gt;List,Set,Map三者的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt; (对付顺序的好帮⼿)： 存储的元素是&lt;strong&gt;有序的、可重复的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt; (注重独⼀⽆⼆的性质): 存储的元素是&lt;strong&gt;⽆序的&lt;/strong&gt;、&lt;strong&gt;不可重复的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt; (⽤ Key 来搜索的专家): 使⽤&lt;strong&gt;键值对&lt;/strong&gt;（kye-value）存储，类似于数学上的函数y=f(x)，“x”代表 key，&amp;quot;y&amp;quot;代表 value，&lt;strong&gt;Key 是⽆序的、不可重复的&lt;/strong&gt;，&lt;strong&gt;value 是⽆序的、可重复&lt;/strong&gt;的，每个键最多映射到⼀个值。&lt;br&gt;
&lt;img src=&#34;https://i.imgtg.com/2023/02/14/do1kr.png&#34; alt=&#34;do1kr.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;List&lt;/h2&gt;
&lt;h3 id=&#34;copyonwritearraylist&#34;&gt;CopyOnWriteArrayList&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;读写分离list&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写操作在一个&lt;strong&gt;复制的数组&lt;/strong&gt;上进行，读操作还是在&lt;strong&gt;原始数组&lt;/strong&gt;中进行，&lt;strong&gt;读写分离&lt;/strong&gt;，互不影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写操作需要加锁&lt;/strong&gt;，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用于读多写少的场景&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    private E get(Object[] a, int index) {
        return (E) a[index];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arraylist-与-linkedlist-区别&#34;&gt;Arraylist 与 LinkedList 区别?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否保证线程安全&lt;/strong&gt;： ArrayList 和 LinkedList 都是&lt;strong&gt;不同步&lt;/strong&gt;的，也就是&lt;strong&gt;不保证线程安全&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt;： Arraylist 底层使⽤的是 &lt;strong&gt;Object 数组&lt;/strong&gt;； LinkedList 底层使⽤的是 &lt;strong&gt;双向链表 数据结构&lt;/strong&gt;（&lt;strong&gt;JDK1.6 之前为循环链表&lt;/strong&gt;，J&lt;strong&gt;DK1.7 取消了循环&lt;/strong&gt;。注意双向链表和双向循环链表的区别）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插⼊和删除是否受元素位置的影响&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。&lt;/p&gt;
&lt;p&gt;②&lt;br&gt;
LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, Eelement) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。&lt;/p&gt;
&lt;p&gt;arraylist实现了randomaccess接口 但是linked没有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否⽀持快速随机访问&lt;/strong&gt;： LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过&lt;strong&gt;元素的序号&lt;/strong&gt;快速获取元素对象(对应于 get(int index)**** ⽅法)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存空间占⽤&lt;/strong&gt;： ArrayList 的空 间浪费主要体现在在 &lt;strong&gt;list 列表的结尾会预留⼀定的容量空间&lt;/strong&gt;预留给将要插入的元素 ⽽ LinkedList 的空间花费则体现在它的每⼀**个元素都需要消耗⽐ ArrayList 更多的空间（**&lt;strong&gt;因为要存放直接后继和直接前驱以及数据&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;arraylist-与-linkedlist的有些成员变量为什么使用transient关键字&#34;&gt;Arraylist 与 LinkedList的有些成员变量为什么使用transient关键字&lt;/h3&gt;
&lt;p&gt;1.ArrayList中将elementData修饰成transient是为了&lt;strong&gt;节省空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.LinkedList中将first和last修饰成transient是为了&lt;strong&gt;节省空间&lt;/strong&gt;和&lt;strong&gt;重新连接链表&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;arraylist源码分析&#34;&gt;Arraylist源码分析&lt;/h3&gt;
&lt;p&gt;https://baijiahao.baidu.com/s?id=1637926321175819771&amp;amp;wfr=spider&amp;amp;for=pc&lt;/p&gt;
&lt;h3 id=&#34;arraylist为什么用15倍扩容&#34;&gt;Arraylist为什么用1.5倍扩容&lt;/h3&gt;
&lt;p&gt;k=1.5时，&lt;strong&gt;就能充分利用前面已经释放的空间&lt;/strong&gt;。如果k &amp;gt;= 2，&lt;strong&gt;新容量刚刚好永远大于过去所有废弃的数组容量会造成空间利用资源的浪费&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么不取扩容固定容量呢？&lt;br&gt;
扩容的目的需要综合考虑这两种情况：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;扩容容量不能&lt;strong&gt;太小&lt;/strong&gt;，&lt;strong&gt;防止频繁扩容，频繁申请内存空间 + 数组频繁复制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;扩容容量不能&lt;strong&gt;太大&lt;/strong&gt;，&lt;strong&gt;需要充分利用空间，避免浪费过多空间&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而扩容固定容量，很难决定到底取多少值合适，取任何具体值都不太合适，因为所需数据量往往由数组的客户端在具体应用场景决定。依赖于当前已经使用的量 * 系数， 比较符合实际应用场景。比如，我现在已经用到一个数组100的容量，接下来很可能会有这个数量级的数据需要插入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么是1.5，而不是1.2，1.25，1.8或者1.75？&lt;br&gt;
&lt;strong&gt;因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数 提示计算的效率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;双向链表和双向循环链表&#34;&gt;双向链表和双向循环链表&lt;/h3&gt;
&lt;p&gt;双向链表： 包含两个指针，⼀个 prev 指向前⼀个节点，⼀个 next 指向后⼀个节点&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/do7pM.png&#34; alt=&#34;do7pM.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;arraylist-与-vector-区别呢为什么要用arraylist取代vector呢&#34;&gt;ArrayList 与 Vector 区别呢?为什么要⽤Arraylist取代Vector呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList 是 List 的主要实现类，底层使⽤ Object[ ] 存储，适⽤于频繁的查找⼯作，线程不安全 ；&lt;/li&gt;
&lt;li&gt;Vector 是 List 的古⽼实现类，底层使⽤ Object[ ] 存储，线程安全的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist-的扩容机制&#34;&gt;ArrayList 的扩容机制&lt;/h3&gt;
&lt;p&gt;概括的说，ArrayList 是一个动态数组，它是线程不安全的，允许元素为null。其底层数据结构依然是数组，它实现了List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable接口，其中&lt;strong&gt;RandomAccess&lt;/strong&gt;代表了其拥有随机快速访问的能力，ArrayList可以以**O(1)**的时间复杂度去根据下标访问元素。&lt;/p&gt;
&lt;p&gt;因其&lt;strong&gt;底层数据结构是数组&lt;/strong&gt;，所以可想而知，它是占据一块&lt;strong&gt;连续&lt;/strong&gt;的内存空间（&lt;strong&gt;容量就是数组的length&lt;/strong&gt;），所以它也有数组的&lt;strong&gt;缺点&lt;/strong&gt;，空间效率不高。&lt;/p&gt;
&lt;p&gt;由于数组的&lt;strong&gt;内存连续&lt;/strong&gt;，可以根据下标以O(1)的时间读写(改查)元素，因此时间效率很高。&lt;/p&gt;
&lt;p&gt;当集合中的元素&lt;strong&gt;超出&lt;/strong&gt;这个容量，便会进行&lt;strong&gt;扩容&lt;/strong&gt;操作。扩容操作也是ArrayList 的一个&lt;strong&gt;性能消耗比较大&lt;/strong&gt;的地方，所以若我们可以提前预知数据的规模，应该通过public ArrayList(int initialCapacity) {}构造方法，&lt;strong&gt;指定集合的大小，去构建ArrayList实例，以减少扩容次数，提高效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或者在需要扩容的时候，&lt;strong&gt;手动调用&lt;/strong&gt;public void ensureCapacity(int minCapacity) {}方法扩容。不过该方法是ArrayList的API，不是List接口里的，所以使用时需要&lt;strong&gt;强转&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;((ArrayList)list).ensureCapacity(30);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当每次修改结构时，增加导致扩容，或者删，都会修改modCount&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先点进源码查看&lt;/p&gt;
&lt;h6 id=&#34;构造方法&#34;&gt;&lt;strong&gt;构造方法：&lt;/strong&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//存储集合元素的底层实现：真正存放元素的数组
transient Object[] elementData; // non-private to simplify nested class access
//当前元素数量
private int size;

//默认构造方法
public ArrayList() {
    //默认构造方法只是简单的将 空数组赋值给了elementData
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

//空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//带初始容量的构造方法
//如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下： 
public ArrayList(int initialCapacity) {
    //如果初始容量大于0，则新建一个长度为initialCapacity的Object数组.
    //注意这里并没有修改size(对比第三个构造函数)
    if (initialCapacity &amp;gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {//如果容量为0，直接将EMPTY_ELEMENTDATA赋值给elementData
        this.elementData = EMPTY_ELEMENTDATA;
    } else {//容量小于0，直接抛出异常
        throw new IllegalArgumentException(&amp;quot;Illegal Capacity: &amp;quot;+
                                           initialCapacity);
    }
}

//利用别的集合类来构建ArrayList的构造函数
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    //直接利用Collection.toArray()方法得到一个对象数组，并赋值给elementData 
    elementData = c.toArray();
    //因为size代表的是集合元素数量，所以通过别的集合来构造ArrayList时，要给size赋值
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)//这里是当c.toArray出错，没有返回Object[]时，利用Arrays.copyOf 来复制集合c中的元素到elementData数组中
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        //如果集合c元素数量为0，则将空数组EMPTY_ELEMENTDATA赋值给elementData 
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;参数&#34;&gt;参数&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// 序列化id
	private static final long serialVersionUID = 8683452581122892189L;
	// 默认初始的容量
	private static final int DEFAULT_CAPACITY = 10;
	// 一个空对象
	private static final Object[] EMPTY_ELEMENTDATA = new Object[0];
	// 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值
	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = new Object[0];
	// 当前数据对象存放地方，当前对象不参与序列化
	transient Object[] elementData;
	// 当前数组长度
	private int size;
	// 数组最大长度
	private static final int MAX_ARRAY_SIZE = 2147483639;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//这是一个空的数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？&lt;/p&gt;
&lt;p&gt;这就得看看add方法的源码了：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里大家要注意一下&lt;strong&gt;Collection.toArray()&lt;strong&gt;这个方法，在Collection子类各大集合的源码中，高频使用了这个方法去&lt;/strong&gt;获得某Collection的所有元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于方法：&lt;strong&gt;Arrays.copyOf(elementData, size, Object[].class)&lt;/strong&gt;，就是根据class的类型来决定是new 还是反射去构造一个泛型数组，同时利用native函数，批量赋值元素至新数组中。&lt;br&gt;
如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T,U&amp;gt; T[] copyOf(U[] original, int newLength, Class&amp;lt;? extends T[]&amp;gt; newType) {
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    //根据class的类型来决定是new 还是反射去构造一个泛型数组
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    //利用native函数，批量赋值元素至新数组中。
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;System.arraycopy&lt;/strong&gt;也是一个很高频的函数，大家要留意一下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;常用api&#34;&gt;常用API：&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;1.增&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;add的方法有两个，一个是&lt;strong&gt;带一个参数&lt;/strong&gt;的，一个是&lt;strong&gt;带两个参数&lt;/strong&gt;的。&lt;br&gt;
&lt;strong&gt;add(E e) 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;add主要的&lt;strong&gt;执行逻辑&lt;/strong&gt;如下：&lt;br&gt;
1）确保数组已使用长度（size）加1之后足够存下 下一个数据&lt;br&gt;
2）修改次数modCount 标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用&lt;strong&gt;grow&lt;/strong&gt;方法，增长数组。&lt;/p&gt;
&lt;p&gt;grow方法会将当前数组的长度变为原来容量的1.5倍。&lt;br&gt;
3）确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。&lt;br&gt;
4）返回添加成功布尔值。&lt;/p&gt;
&lt;p&gt;添加元素方法入口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean add(E e) {
        //扩容的操作 当容量不够的时候就把容量扩大
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //想数组中添加元素
        elementData[size++] = e;
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保添加的元素有地方存储，当第一次添加元素的时候this.size+1 的值是&lt;strong&gt;1&lt;/strong&gt;，所以第一次添加的时候会将当前elementData数组的长度变为10：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//最初的数组容量为0     
private void ensureCapacityInternal(int minCapacity) {
		//第一次判断数组当中为空 默认的数组的数组也是空 所以第一次添加条件成立
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
           	//max函数比较当前容量和默认容量 当前为0 默认为10 所以返回大的是10 所以第一次添加完成之后就变成了10
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
    //扩容完成执行下面的操作
        ensureExplicitCapacity(minCapacity);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将修改次数（modCount）&lt;strong&gt;自增1&lt;/strong&gt;，判断是否需要扩充数组长度,判断条件就是用当前所需的数组最小长度与数组的长度对比，如果大于0，则增长数组长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//当前容量为10private void ensureExplicitCapacity(int minCapacity) {    	//修改次数+1        modCount++;        // overflow-conscious code    	//当前容量为哦10 减去数组的长度0大于0        if (minCapacity - elementData.length &amp;gt; 0)            //执行扩容操作            grow(minCapacity);    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果当前的数组已使用空间（size）加1之后 大于数组长度，则增大数组容量，扩大为原来的1.5倍。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//此时的minCapacity为10private void grow(int minCapacity) {        // overflow-conscious code    	//旧的容量为当前数组的长度为0        int oldCapacity = elementData.length;    	//扩容操作    	//新的长度为旧的加上旧的右移1位 0+0还是0    	//假设此时的数组的长度已经到达10 的时候 就会变成15        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);    	//判断最新的容量是否大于之前的最小容量 目的是让最新的容量要大于等于之前的最小容量        if (newCapacity - minCapacity &amp;lt; 0)                    newCapacity = minCapacity;        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)            //MAX_ARRAY_SIZE是个超级大的数字 如果数组不是很大的话是下面的条件一般是不会成立的            newCapacity = hugeCapacity(minCapacity);        // minCapacity is usually close to size, so this is a win:    	//第一次创建数组 此时的数组长度为newCapacity的大小     	//后面也是如此        elementData = Arrays.copyOf(elementData, newCapacity);    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;add(int index, E element)方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法其实和上面的add类似，该方法可以按照元素的位置，指定位置插入元素，具体的执行逻辑如下：&lt;br&gt;
1）rangeCheckForAdd(index)&lt;strong&gt;确保数插入的位置小于等于当前数组长度，并且不小于0&lt;/strong&gt;，否则抛出异常&lt;/p&gt;
&lt;p&gt;2）确保数组已使用长度（size）加1之后足够存下 下一个数据&lt;/p&gt;
&lt;p&gt;3）修改次数（modCount）标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;grow&lt;/strong&gt;方法会将当前数组的长度变为原来容量的1.5倍。&lt;/p&gt;
&lt;p&gt;5）确保有足够的容量之后，使用System.arraycopy 将需要插入的位置（index）&lt;strong&gt;后面的元素统统往后移动一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;6）将新的数据内容存放到数组的指定位置（&lt;strong&gt;index&lt;/strong&gt;）上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public void add(int index, E element) {        rangeCheckForAdd(index);        ensureCapacityInternal(size + 1);  // Increments modCount!!     	//通过数组复制的方式复制一次数组        System.arraycopy(elementData, index, elementData, index + 1,                         size - index);        elementData[index] = element;        size++;    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：使用该方法的话将导致指定位置后面的数组元素&lt;strong&gt;全部重新移动，即往后移动一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;br&gt;
add、addAll。&lt;br&gt;
先判断是否越界，是否需要扩容。&lt;br&gt;
如果扩容， 就复制数组。	&lt;br&gt;
然后设置对应下标元素值。&lt;/p&gt;
&lt;p&gt;值得注意的是：&lt;br&gt;
1 &lt;strong&gt;如果需要扩容的话，默认扩容一半。如果扩容一半不够，就用目标的size作为扩容后的容量。&lt;/strong&gt;&lt;br&gt;
2 &lt;strong&gt;在扩容成功后，会修改modCount&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;map-set&#34;&gt;Map Set&lt;/h2&gt;
&lt;h3 id=&#34;hashmap-和-hashtable-的区别&#34;&gt;HashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程是否安全&lt;/strong&gt;： HashMap 是⾮线程安全的， HashTable 是线程安全的,因为 HashTable 内部的⽅法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使⽤ConcurrentHashMap 吧！）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;效率&lt;/strong&gt;： 因为线程安全的问题， HashMap 要⽐ HashTable 效率⾼⼀点。另外， HashTable基本被淘汰，不要在代码中使⽤它；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对 Null key 和 Null value 的⽀持&lt;/strong&gt;： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有⼀个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出NullPointerException 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始容量⼤⼩和每次扩充容量⼤⼩的不同&lt;/strong&gt; ：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;① 创建时如果不指定容量初始值， Hashtable默认的初始⼤⼩为 &lt;strong&gt;11&lt;/strong&gt;，之后每次扩充，容量变为原来的 &lt;strong&gt;2n+1&lt;/strong&gt;。 HashMap 默认的初始化⼤⼩为 16。之后每次扩充，容量变为原来的 2 倍。&lt;/p&gt;
&lt;p&gt;② 创建时如果给定了容量初始值，那么Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为 2 的幂次⽅⼤⼩（ HashMap 中的 tableSizeFor() ⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤ 2 的幂作为哈希表的⼤⼩,后⾯会介绍到为什么是 2 的幂次⽅。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt;： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间Hashtable 没有这样的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、继承：&lt;br&gt;
HashTable继承自&lt;strong&gt;Dirctionary&lt;/strong&gt;，HashMap继承自AbstractMap，二者均实现了Map接口；&lt;br&gt;
2、线程安全性：&lt;br&gt;
HashTable的方法是同步的，即是线程安全的。HaspMap的方法不是同步的，不是线程安全的的。在多线程并发的情况下，我们可以直接使用HashTable，如果 要使用HashMap，就需要自行对HashMap的同步处理。&lt;br&gt;
3、键值：&lt;br&gt;
HashTable中不允许有null键和null值，HashMap中允许出现一个null键，可以存在一个或者多个键的值都为null。程序中，对HashMap，如果使用get(参数为 键)方法时，返回结果为null，可能是该键不存在，也可能是该键对应的值为null，这就出现了结果的二义性。因此，在HashMap中，我们不能使用get()方法来查询键 对应的值，应该使用containskey()方法。&lt;br&gt;
4、遍历：&lt;br&gt;
这两个在遍历方式的实现不同。HashTable和HashMap两者都实现了Iterator。但是，由于历史原因，HashTable还使用Enumeration。&lt;br&gt;
5、哈希值：&lt;br&gt;
&lt;strong&gt;HashTable是直接使用对象的hashCode。HashMap是重新计算hash值。&lt;/strong&gt;&lt;br&gt;
6、扩容：&lt;br&gt;
HashTable和HashMap的底层实现的数组和初始大小和扩容方式。HashTable初始大小为11，并且每次扩容都为：2&lt;em&gt;old+1。HashMap的默认大小为16，并且一 定是2的指数，每次扩容都为old&lt;/em&gt;2。&lt;/p&gt;
&lt;h3 id=&#34;hashmap-和-hashset区别&#34;&gt;HashMap 和 HashSet区别&lt;/h3&gt;
&lt;p&gt;HashSet 底层就是基于 HashMap 实现的。&lt;/p&gt;
&lt;p&gt;因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。&lt;br&gt;
&lt;img src=&#34;https://i.imgtg.com/2023/02/14/doNYG.png&#34; alt=&#34;doNYG.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;hashset当中为什么要对hashmap使用transient关键字&#34;&gt;HashSet当中为什么要对HashMap使用transient关键字&lt;/h3&gt;
&lt;p&gt;在源码当中查看 其实HashSet当中还有这两个方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;private void writeObject(java.io.ObjectOutputStream s){}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;private void readObject(java.io.ObjectInputStream s){}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析得出结论：&lt;/p&gt;
&lt;p&gt;在序列化HashSet的时候，会调HashSet中的&lt;strong&gt;writeObject&lt;/strong&gt;，将hashSet中的hashMap中的数据序列化存起来，而在反序列化的时候，会调用Hashset中的readObject来&lt;strong&gt;重新构造&lt;/strong&gt;hashSet中的hashMap，这样的话，&lt;strong&gt;就完全没必要序列化hashSet中的HashMap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反射调用HashSet的writeObject方法，同理反序列化也就是在反射调用HashSet中的readObjcet方法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;hashset如何检查重复&#34;&gt;HashSet如何检查重复&lt;/h3&gt;
&lt;p&gt;当你把对象加⼊ HashSet 时， HashSet 会先计算对象的 &lt;strong&gt;hashcode&lt;/strong&gt; 值来判断对象加⼊的位置，同时也会与其他加⼊的对象的 hashcode 值作比较，如果没有相符的 hashcode ，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让加⼊操作成功。&lt;/p&gt;
&lt;h3 id=&#34;hashmap的底层实现&#34;&gt;HashMap的底层实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8 之前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8 之前 HashMap 底层是 &lt;strong&gt;数组和链表&lt;/strong&gt; 结合在⼀起使⽤也就是 链表散列。HashMap 通过key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp;amp; hash 判断当前元素存放的位置（这⾥的 n 指的是数组的⻓度），如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash 值以及 key 是否相同，&lt;strong&gt;如果相同的话，直接覆盖&lt;/strong&gt;，&lt;strong&gt;不相同就通过拉链法解决冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓扰动函数指的就是 HashMap 的 hash ⽅法。使⽤ hash ⽅法也就是扰动函数是为了防⽌⼀些实现⽐较差的 hashCode() ⽅法 换句话说使⽤扰动函数之后可以减少&lt;/p&gt;
&lt;p&gt;相⽐于 JDK1.8 的 hash ⽅法 ，JDK 1.7 的 hash ⽅法的性能会稍差⼀点点，因为毕竟扰动了 4次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链表。&lt;strong&gt;若遇到哈希冲突，则将冲突的值加到链表中即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8 之后&lt;/strong&gt;&lt;br&gt;
相⽐于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当&lt;strong&gt;链表⻓度⼤于阈值&lt;/strong&gt;（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 &lt;strong&gt;64&lt;/strong&gt;，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间&lt;/p&gt;
&lt;h3 id=&#34;hashmap-多线程操作导致死循环问题&#34;&gt;HashMap 多线程操作导致死循环问题&lt;/h3&gt;
&lt;p&gt;主要原因在于 并发下的&lt;strong&gt;Rehash 会造成元素之间会形成⼀个循环链表&lt;/strong&gt;。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使⽤ HashMap,因为多线程下使⽤ HashMap 还是会存在其他问题⽐如数据丢失。并发环境下推荐使⽤ &lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void transfer(Entry[] newTable, boolean rehash) {    //新数组的长度    int newCapacity = newTable.length;    //遍历旧数组    for (Entry&amp;lt;K,V&amp;gt; e : table) {        while(null != e) {            Entry&amp;lt;K,V&amp;gt; next = e.next;            if (rehash) {                //重新计算hash值                e.hash = null == e.key ? 0 : hash(e.key);            }            //这里根据刚刚得到的新hash重新调用indexFor方法计算下标索引            int i = indexFor(e.hash, newCapacity);            //假设当前数组中某个位置的链表结构为a-&amp;gt;b-&amp;gt;c;women             //（1）当为原链表中的第一个结点的时候：e.next=null;newTable[i]=e;e=e.next            //（2）当遍历到原链表中的后续节点的时候：e.next=head;newTable[i]=e（这里将头节点设置为新插入的结点，即头插法）;e=e.next            //（3）这里也是导致扩容后，链表顺序反转的原理（代码就是这样写的，链表反转，当然前提是计算的新下标还是相同的）            e.next = newTable[i];             newTable[i] = e;            e = next;        }    }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在jdk7中使用头插法可能会导致出现死环（a.next = b，b.next = a）。导致在put的时候一直获取不到数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个线程同时对一个hashMap resize。线程a执行到&lt;code&gt;Entry&amp;lt;K,V&amp;gt; next = e.next;&lt;/code&gt;被阻塞了，线程b执行完了resize，此时a再继续执行时，可能会导致死环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请查看：https://coolshell.cn/articles/9606.html&lt;/p&gt;
&lt;h3 id=&#34;concurrenthashmap-和-hashtable-的区别&#34;&gt;ConcurrentHashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的⽅式上不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt;： JDK1.7 的 ConcurrentHashMap 底层采⽤ &lt;strong&gt;分段的数组+链表&lt;/strong&gt; 实现，JDK1.8采⽤的数据结构跟 HashMap1.8 的结构⼀样，数组+链表/红⿊⼆叉树。 Hashtable 和JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ 数组+链表 的形式，数组是HashMap 的主体，&lt;strong&gt;链表则是主要为了解决哈希冲突&lt;/strong&gt;⽽存在的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现线程安全的⽅式（重要&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;① 在 &lt;strong&gt;JDK1.7&lt;/strong&gt; 的时候， ConcurrentHashMap （分段锁）对整个桶数组进⾏了&lt;strong&gt;分割分段( Segment )&lt;/strong&gt;，每⼀把锁只锁容器其中&lt;strong&gt;⼀部分数据&lt;/strong&gt;，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 到了 JDK1.8 的时候已经摒弃了 &lt;strong&gt;Segment&lt;/strong&gt; 的概念，⽽是直接⽤ &lt;strong&gt;Node 数组+链表+红⿊树的数据结构&lt;/strong&gt;来实现，并发控制使⽤ &lt;strong&gt;synchronized&lt;/strong&gt; 和 &lt;strong&gt;CAS&lt;/strong&gt; 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） &lt;strong&gt;整个看起来就像是优化过且线程安全的 HashMap&lt;/strong&gt; ，虽然在 JDK1.8 中还能看到&lt;strong&gt;Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;② Hashtable (同⼀把锁) :使⽤ &lt;strong&gt;synchronized 来保证线程安全&lt;/strong&gt;，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊&lt;strong&gt;阻塞或轮询状&lt;/strong&gt;态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。&lt;/p&gt;
&lt;p&gt;两者的对⽐图：&lt;br&gt;
HashTable&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/do3lM.png&#34; alt=&#34;do3lM.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;JDK1.7 的 ConcurrentHashMap：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dowBG.png&#34; alt=&#34;dowBG.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8 的 ConcurrentHashMap：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8 的 ConcurrentHashMap 不在是 Segment 数组 + HashEntry 数组 + 链表，⽽是 Node 数组 + 链表 / 红⿊树。不过，&lt;strong&gt;Node&lt;/strong&gt; 只能⽤于链表的情况，红⿊树的情况需要使⽤ &lt;strong&gt;TreeNode&lt;/strong&gt; 。当冲突链表达到⼀定⻓度时，链表会转换成红⿊树。&lt;/p&gt;
&lt;h3 id=&#34;concurrenthashmap线程安全的具体实现方式底层具体实现&#34;&gt;ConcurrentHashMap线程安全的具体实现⽅式/底层具体实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JDK1.7&lt;/strong&gt;&lt;br&gt;
⾸先将&lt;strong&gt;数据分为⼀段⼀段的存储&lt;/strong&gt;，然后给每⼀段数据配⼀把锁，当⼀个线程占⽤锁访问其中⼀个段数据时，其他段的数据也能被其他线程访问。&lt;br&gt;
&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; 是由 &lt;strong&gt;Segment&lt;/strong&gt; 数组结构和 &lt;strong&gt;HashEntry&lt;/strong&gt; 数组结构组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Segment&lt;/strong&gt; 实现了 &lt;strong&gt;ReentrantLock&lt;/strong&gt; ,所以 &lt;strong&gt;Segment&lt;/strong&gt; 是⼀种可重⼊锁，扮演锁的⻆⾊。 &lt;strong&gt;HashEntry&lt;/strong&gt; 用于储存键值对数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqMZ1.png&#34; alt=&#34;dqMZ1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⼀个 &lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; ⾥包含⼀个 &lt;strong&gt;Segment&lt;/strong&gt; 数组。 &lt;strong&gt;Segment&lt;/strong&gt; 的结构和 &lt;strong&gt;HashMap&lt;/strong&gt; 类似，是⼀种数组和链表结构，⼀个 &lt;strong&gt;Segment&lt;/strong&gt; 包含⼀个 &lt;strong&gt;HashEntry&lt;/strong&gt; 数组，每个 &lt;strong&gt;HashEntry&lt;/strong&gt; 是⼀个链表结构的元素，每个 &lt;strong&gt;Segment&lt;/strong&gt; 守护着⼀个 &lt;strong&gt;HashEntry&lt;/strong&gt; 数组⾥的元素，当对 &lt;strong&gt;HashEntry&lt;/strong&gt; 数组的数据进⾏修改时，必须⾸先获得对应的 &lt;strong&gt;Segment&lt;/strong&gt; 的锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt; 取消了 &lt;strong&gt;Segment&lt;/strong&gt; 分段锁，采⽤ &lt;strong&gt;CAS&lt;/strong&gt; 和 &lt;strong&gt;synchronized&lt;/strong&gt; 来保证并发安全。数据结构跟 HashMap1.8 的结构类&lt;/p&gt;
&lt;p&gt;似，&lt;strong&gt;数组+链表/红⿊⼆叉树&lt;/strong&gt;。Java 8 在链表⻓度超过⼀定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红⿊树（寻址时间复杂度为 O(log(N))）&lt;br&gt;
&lt;strong&gt;synchronized&lt;/strong&gt; &lt;strong&gt;只锁定当前链表或红⿊⼆叉树的⾸节点&lt;/strong&gt;，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍。&lt;/p&gt;
&lt;h3 id=&#34;比较-hashset-linkedhashset-和-treeset-三者的异同&#34;&gt;⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt; 是 Set 接⼝的主要实现类 ， HashSet 的底层是 HashMap ，线程不安全的，可以存储 null 值； 无序&lt;br&gt;
&lt;strong&gt;LinkedHashSet&lt;/strong&gt; 是 HashSet 的⼦类，&lt;strong&gt;能够按照添加的顺序遍历&lt;/strong&gt;；有序&lt;br&gt;
&lt;strong&gt;TreeSet 底层使⽤红⿊树&lt;/strong&gt;，能够按照添加元素的顺序进⾏遍历，排序的⽅式有⾃然排序和定制排序 。有序&lt;/p&gt;
&lt;h3 id=&#34;hashmap的扩容为什么要选用2倍&#34;&gt;HashMap的扩容为什么要选用2倍&lt;/h3&gt;
&lt;p&gt;当HashMap的容量达&lt;strong&gt;到threshold域值&lt;/strong&gt;时，就会触发扩容。扩容前后，哈希桶的&lt;strong&gt;长度&lt;/strong&gt;一定会是&lt;strong&gt;2的次方&lt;/strong&gt;。&lt;strong&gt;这样在根据key的hash值寻找对应的哈希桶时&lt;/strong&gt;，可以用&lt;strong&gt;位运算替代取余操作&lt;/strong&gt;，更加高效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;capacity 为 2的整数次幂的话，计算桶的位置 h&amp;amp;(length-1) 就相当于对 length 取模，&lt;strong&gt;提升了计算效率&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;capacity 为 2 的整数次幂的话，便保证了 h&amp;amp;(capacity-1) 的结果可能是0也可能是1，&lt;strong&gt;保证了散列的均匀性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;capacity 为 2 的整数次幂可以使得在resize的时候&lt;strong&gt;不用重新计算hash值&lt;/strong&gt;。而通过&lt;code&gt;(e.hash &amp;amp; oldCap) == 0 ? 原来位置 : 原来位置+原来哈希表大小&lt;/code&gt;就能算出在新哈希表的正确位置（能通过&lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt;正确获取元素）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hashmap的负载因子为什么为075&#34;&gt;HashMap的负载因子为什么为0.75&lt;/h3&gt;
&lt;p&gt;负载因子，默认值是0.75。负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。 所以&lt;strong&gt;负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低&lt;/strong&gt;。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子&lt;/strong&gt;，每个碰撞位置的链表长度超过８个是几乎不可能的。&lt;/p&gt;
&lt;h3 id=&#34;hashmap的遍历方式&#34;&gt;HashMap的遍历方式&lt;/h3&gt;
&lt;p&gt;https://www.cnblogs.com/xyfer1018/p/10434827.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种：遍历HashMap的entrySet&lt;strong&gt;键值对&lt;/strong&gt;集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.通过**HashMap.entrySet()**得到键值对集合；&lt;/p&gt;
&lt;p&gt;2.通过迭代器&lt;strong&gt;Iterator&lt;/strong&gt;遍历键值对集合得到key值和value值；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;Iterator it = map.entrySet().iterator();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种：遍历HashMap键的Set集合获取值；&lt;/p&gt;
&lt;p&gt;1.通过&lt;strong&gt;HashMap.keySet(&lt;/strong&gt;)获得键的Set集合；&lt;/p&gt;
&lt;p&gt;2.遍历键的Set集合获取值；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator it = map.keySet().iterator();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种：遍历HashMap“值”的集合；&lt;/p&gt;
&lt;p&gt;1.通过HashMap.values()得到“值”的集合&lt;/p&gt;
&lt;p&gt;2.遍历“值”的集合；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator it = map.values().iterator();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何用一个数组构造hashmap&#34;&gt;如何用一个数组构造hashmap&lt;/h3&gt;
&lt;p&gt;hashmap的底层是通过&lt;strong&gt;数组+链表+红黑树的形&lt;/strong&gt;式&lt;/p&gt;
&lt;p&gt;关键是构造entry数组&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqO0I.png&#34; alt=&#34;dqO0I.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;https://blog.csdn.net/miracleon/article/details/102542395&lt;/p&gt;
&lt;h2 id=&#34;解决hash冲突的方法&#34;&gt;解决hash冲突的方法&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/kaleidoscope/p/9588151.html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拉链法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;散列法（开放地址法）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有&lt;strong&gt;输入的元素全部存放在哈希表&lt;/strong&gt;里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;每次冲突都要重新散列，计算时间增加&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hash表相关考点&#34;&gt;hash表相关考点&lt;/h2&gt;
&lt;p&gt;解决哈希冲突的链地址算法 插入新数据项的时间表述中 随装载因子线性增长&lt;/p&gt;
&lt;p&gt;哈希表的装填因子&lt;/p&gt;
&lt;p&gt;装填因子 = （哈希表中的记录数） /  （哈希表的长度）。&lt;/p&gt;
&lt;p&gt;装填因子是哈希表装满程度的标记因子。值越大，填入表中的数据元素越多，产生冲突的可能性越大。&lt;/p&gt;
&lt;h2 id=&#34;集合框架底层数据结构总结&#34;&gt;集合框架底层数据结构总结&lt;/h2&gt;
&lt;h3 id=&#34;list-2&#34;&gt;List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arraylist ： Object[] 数组&lt;/li&gt;
&lt;li&gt;Vector ： Object[] 数组&lt;/li&gt;
&lt;li&gt;LinkedList ： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arraylist ： Object[] 数组&lt;/li&gt;
&lt;li&gt;Vector ： Object[] 数组&lt;/li&gt;
&lt;li&gt;LinkedList ： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;map&#34;&gt;Map&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HashMap ： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较	⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链转化为红⿊树，以减少搜索时间&lt;/li&gt;
&lt;li&gt;LinkedHashMap ： LinkedHashMap 继承⾃ HashMap ，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》&lt;/li&gt;
&lt;li&gt;Hashtable ： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的&lt;/li&gt;
&lt;li&gt;TreeMap ： 红⿊树（⾃平衡的排序⼆叉树）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何选用集合&#34;&gt;如何选⽤集合&lt;/h2&gt;
&lt;p&gt;主要根据集合的特点来选⽤，⽐如我们需要根据键值获取到元素值时就选⽤ Map 接⼝下的集合，需要排序时选择 TreeMap ,不需要排序时就选择 HashMap ,需要保证线程安全就选⽤ConcurrentHashMap 。&lt;/p&gt;
&lt;p&gt;当我们只需要存放元素值时，就选择实现 Collection 接⼝的集合，需要保证元素唯⼀时选择实现Set 接⼝的集合⽐如 TreeSet 或 HashSet ，不需要就选择实现 List 接⼝的⽐如 ArrayList 或LinkedList ，然后再根据实现这些接⼝的集合的特点来选⽤。&lt;/p&gt;
&lt;h2 id=&#34;线程同步的集合&#34;&gt;线程同步的集合&lt;/h2&gt;
&lt;p&gt;线程同步：喂，SHE&lt;/p&gt;
&lt;p&gt;喂（Vector）&lt;/p&gt;
&lt;p&gt;S（Stack）&lt;/p&gt;
&lt;p&gt;H（hashtable）&lt;/p&gt;
&lt;p&gt;E（enumeration）&lt;/p&gt;
">集合</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lindamao.cn/post/java-ji-chu/"" data-c="
          &lt;!-- more --&gt;
&lt;h2 id=&#34;面向对象和面向过程的区别&#34;&gt;⾯向对象和⾯向过程的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;⾯向过程 ：⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销比较大,比较消耗资源，所以当性能是最重要的考量因素的时候，⽐如单⽚机、嵌⼊式开发、Linux/Unix 等⼀般采⽤⾯向过程开发。但是，⾯向过程没有⾯向对象易维护、易复⽤、易扩展。&lt;/li&gt;
&lt;li&gt;⾯向对象 ：⾯向对象易维护、易复⽤、易扩展。 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，系统更加灵活、更加易于维护。但是，⾯向对象性能⽐⾯向过程低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⾯向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直&lt;br&gt;
接被 CPU 执⾏的⼆进制机械码。&lt;/p&gt;
&lt;p&gt;⽽⾯向过程语⾔⼤多都是直接编译成机械码在电脑上执⾏，并且其它⼀些⾯向过程的脚本语&lt;br&gt;
⾔性能也并不⼀定⽐ Java 好。&lt;/p&gt;
&lt;h2 id=&#34;java-语言有哪些特点&#34;&gt;Java 语⾔有哪些特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;简单易学；&lt;/li&gt;
&lt;li&gt;⾯向对象（封装，继承，多态）；&lt;/li&gt;
&lt;li&gt;平台⽆关性（ Java 虚拟机实现平台⽆关性）；&lt;/li&gt;
&lt;li&gt;可靠性；&lt;/li&gt;
&lt;li&gt;安全性；&lt;/li&gt;
&lt;li&gt;⽀持多线程（ C++ 语⾔没有内置的多线程机制，因此必须调⽤操作系统的多线程功能来进⾏多线程程序设计，⽽ Java 语⾔却提供了多线程⽀持）；&lt;/li&gt;
&lt;li&gt;⽀持⽹络编程并且很⽅便（ Java 语⾔诞⽣本身就是为简化⽹络编程设计的，因此 Java 语⾔不仅⽀持⽹络编程⽽且很⽅便）；&lt;/li&gt;
&lt;li&gt;编译与解释并存；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;修正&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;c++ 在2011年开始引进了多线程库&lt;/p&gt;
&lt;h2 id=&#34;java的安全性&#34;&gt;Java的安全性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语言层次的安全性主要体现在&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Java取消了强大但又危险的指针，而代之以引用。由于指针可进行移动运算，指针可随便指向一个内存区域，而不管这个区域是否可用，这样做是危险的，因为原来这个内存地址可能存储着重要数据或者是其他程序运行所占用的，并且使用指针也容易数组越界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序忘记及时回收，导致内存泄露。避免程序错误回收程序核心类库的内存，导致系统崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常处理机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强制类型转换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;强制类型转换只有在满足强制转换规则的情况下才能强转成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底层的安全性可以从以下方面来说明&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;之编辑Java在字节码的传输过程中使用了公开密钥加密机制(PKC)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在运行环境提供了四级安全性保障机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;字节码校验器 -类装载器 -运行时内存布局 -文件访问&lt;/p&gt;
&lt;h2 id=&#34;什么是jvm什么是jdk-什么是jre&#34;&gt;什么是JVM？什么是JDK？ 什么是JRE？&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq9Ug.png&#34; alt=&#34;dq9Ug.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作&lt;strong&gt;是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用&lt;/strong&gt;，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JRE&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bin:&lt;/strong&gt; 最主要的是编译器(javac.exe)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;include:&lt;/strong&gt; java和JVM交互用的头文件&lt;/p&gt;
&lt;p&gt;**lib：**类库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jre:&lt;/strong&gt; java运行环境&lt;/p&gt;
&lt;p&gt;（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK,JRE,JVM三者关系概括如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。&lt;strong&gt;JRE是JAVA程序运行时需要的运行环境&lt;/strong&gt;，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。&lt;strong&gt;JDk、JRE内部都包含JAVA虚拟机JVM&lt;/strong&gt;，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。ss而没有编译的功能。eclipse、现他们只要求你选jre路径就ok行环境JRE。JRE是JAVA程序运行E就能运行已经存在的JAVA程序的解释器和类加载器等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是字节码?采⽤字节码的好处是什么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时比较⾼效，⽽且，由于字节码并不针对⼀种特定的机器此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。&lt;/p&gt;
&lt;h2 id=&#34;简述java访问修饰符&#34;&gt;简述Java访问修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;default: 默认访问修饰符，在同一包内可见&lt;/li&gt;
&lt;li&gt;private: 在同一类内可见，只能修饰方法或者属性不能修饰类&lt;/li&gt;
&lt;li&gt;protected : 对同一包内的类和所有子类可见，不能修饰类&lt;/li&gt;
&lt;li&gt;public: 对所有类可见&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqjyB.png&#34; alt=&#34;dqjyB.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;java和c的区别&#34;&gt;java和C的区别&lt;/h2&gt;
&lt;p&gt;1、语法不同；&lt;/p&gt;
&lt;p&gt;2、单文件的编译时间java比C语言快；&lt;/p&gt;
&lt;p&gt;3、C语言可以直接操作内存，java不能直接操作；&lt;/p&gt;
&lt;p&gt;4、C语言可以封装动态库，java不行；&lt;/p&gt;
&lt;p&gt;5、C语言的代码不容易跨平台，java的代码容易跨平台；&lt;/p&gt;
&lt;p&gt;6、C语言有指针，java没有指针；&lt;/p&gt;
&lt;p&gt;7、C语言可以直接操作串口，java需要第三方jar包支持；&lt;/p&gt;
&lt;p&gt;8、C语言的线程更加灵活，java的线程都已经封装好了；&lt;/p&gt;
&lt;p&gt;9、C语言做单独功能，可以增加效率，java适用做web应用开发；&lt;/p&gt;
&lt;h2 id=&#34;java-和-c的区别&#34;&gt;Java 和 C++的区别?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;都是⾯向对象的语⾔，都⽀持封装、继承和多态&lt;/li&gt;
&lt;li&gt;Java 不提供指针来直接访问内存，程序内存更加安全&lt;/li&gt;
&lt;li&gt;Java 的类是单继承的，C++ ⽀持多重继承；虽然 Java 的类不可以多继承，但是接⼝可以多继承。&lt;/li&gt;
&lt;li&gt;Java 有⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存&lt;/li&gt;
&lt;li&gt;在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口和抽象类的相同点和区别&#34;&gt;接口和抽象类的相同点和区别？&lt;/h2&gt;
&lt;p&gt;相同点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都不能被实例化。&lt;/li&gt;
&lt;li&gt;接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。&lt;/li&gt;
&lt;li&gt;实现接口的关键字为implements,继承抽象类的关键字为extends。一个类可以实现多个接口，只能继承一个抽象类。&lt;/li&gt;
&lt;li&gt;当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。&lt;/li&gt;
&lt;li&gt;接口当中只有常量，没有变量。抽象类当中可以由常量和变量&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;字符型常量和字符串常量的区别&#34;&gt;字符型常量和字符串常量的区别?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;形式上: 字符常量是单引号引起的⼀个字符; 字符串常量是双引号引起的若⼲个字符&lt;/li&gt;
&lt;li&gt;含义上: 字符常量相当于⼀个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表⼀个地&lt;br&gt;
址值(该字符串在内存中存放位置)&lt;/li&gt;
&lt;li&gt;占内存⼤⼩ 字符常量只占 2 个字节; 字符串常量占若⼲个字节 (注意： char 在 Java 中占两&lt;br&gt;
个字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java的基本数据类型不会像大多数语言那样子随机器硬件架构的变化而变化 。&lt;/p&gt;
&lt;h2 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq2ds.png&#34; alt=&#34;dq2ds.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;引用数据类型&#34;&gt;引用数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interface 接口&lt;/li&gt;
&lt;li&gt;Class 类&lt;/li&gt;
&lt;li&gt;Array 集合&lt;/li&gt;
&lt;li&gt;枚举&lt;/li&gt;
&lt;li&gt;String也属于因引用数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关键字static的作用&#34;&gt;关键字static的作用&lt;/h2&gt;
&lt;p&gt;static的主要作用有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。&lt;/li&gt;
&lt;li&gt;使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体而言static又可分为4种使用方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;修饰成员变量&lt;/strong&gt;。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用&#39;&#39;类.静态变量&#39;&#39;和&#39;&#39;对象.静态变量&#39;&#39;的方法使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修饰成员方法&lt;/strong&gt;。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt;。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static代码块只会被执行一次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修饰内部类&lt;/strong&gt;。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;构造器是否可被-override&#34;&gt;构造器是否可被 override?&lt;/h2&gt;
&lt;p&gt;Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到⼀个类中有多个构造函数的情况。&lt;/p&gt;
&lt;h2 id=&#34;重载和重写的区别&#34;&gt;重载和重写的区别&lt;/h2&gt;
&lt;p&gt;重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理&lt;/p&gt;
&lt;p&gt;重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dq8aK.png&#34; alt=&#34;dq8aK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。&lt;/p&gt;
&lt;p&gt;覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。&lt;/p&gt;
&lt;p&gt;覆盖要求参数列表相同；重载要求参数列表不同。&lt;/p&gt;
&lt;p&gt;覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。&lt;/p&gt;
&lt;p&gt;重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。&lt;/p&gt;
&lt;h2 id=&#34;java-面向对象编程三大特性&#34;&gt;Java ⾯向对象编程三⼤特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;br&gt;
封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法，如果属性不想被外界访问，我们⼤可不必提供⽅法给外界访问。但是如果⼀个类没有提供给外界访问的⽅法，那么这个类也没有什么意义了。&lt;br&gt;
&lt;strong&gt;继承&lt;/strong&gt;&lt;br&gt;
继承是使⽤已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能，也可以⽤⽗类的功能，但不能选择性地继承⽗类。通过使⽤继承我们能够⾮常⽅便地复⽤以前的代码。&lt;br&gt;
关于继承如下 3 点请记住：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性&lt;br&gt;
和⽅法⼦类是⽆法访问，只是&lt;strong&gt;拥有&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。&lt;/li&gt;
&lt;li&gt;⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。（以后介绍）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;**多态 **&lt;br&gt;
所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。&lt;/p&gt;
&lt;h2 id=&#34;string-stringbuffer-和-stringbuilder-的区别是什么&#34;&gt;String StringBuffer 和 StringBuilder 的区别是什么?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;br&gt;
String 类中使⽤ &lt;strong&gt;final&lt;/strong&gt; 关键字修饰字符数组来保存字符串， private final cha value[] ，所以 String 对象是不可变的。&lt;br&gt;
在 Java 9 之后，String 类的实现改⽤ &lt;strong&gt;byte&lt;/strong&gt; 数组存储字符串&lt;br&gt;
&lt;strong&gt;private final byte[] value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⽽ StringBuilder 与 StringBuffer 都继承⾃ &lt;strong&gt;AbstractStringBuilder&lt;/strong&gt; 类，在 &lt;strong&gt;AbstractStringBuilder&lt;/strong&gt; 中也是使⽤&lt;strong&gt;字符数组保存字符串&lt;/strong&gt; char[]value 但是没有⽤ &lt;strong&gt;final&lt;/strong&gt; 关键字修饰，所以这两种对象都是可变的。&lt;/p&gt;
&lt;p&gt;StringBuilder 与 StringBuffer 的构造⽅法都是调⽤⽗类构造⽅法也就是 AbstractStringBuilder 实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是StringBuilder 与 StringBuffer 的公共⽗类，定义了⼀些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共⽅法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StringBuffer&lt;/strong&gt; 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁，所以是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StringBuilder&lt;/strong&gt; 并没有对⽅法进⾏加同步锁，所以是⾮线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象&lt;br&gt;
引⽤。&lt;/p&gt;
&lt;p&gt;相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用总结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作少量的数据: 适⽤ String&lt;/li&gt;
&lt;li&gt;单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder&lt;/li&gt;
&lt;li&gt;多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;String常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;concat() 方法用于将指定的字符串参数连接到字符串上。&lt;/p&gt;
&lt;p&gt;不推荐使用StringTokenizer&lt;/p&gt;
&lt;h2 id=&#34;简述java的垃圾回收机制&#34;&gt;简述Java的垃圾回收机制&lt;/h2&gt;
&lt;p&gt;传统的C/C++语言，需要程序员负责回收已经分配内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式回收垃圾回收的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）程序忘记及时回收，从而导致内存泄露，降低系统性能。&lt;/p&gt;
&lt;p&gt;2）程序错误回收程序核心类库的内存，导致系统崩溃。Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制，简称GC；&lt;/p&gt;
&lt;p&gt;1）可以提高编程效率。&lt;/p&gt;
&lt;p&gt;2）保护程序的完整性。&lt;/p&gt;
&lt;p&gt;3）其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收机制的特点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）垃圾回收机制回收&lt;strong&gt;JVM&lt;/strong&gt;堆内存里的对象空间,&lt;strong&gt;不负责回收栈内存数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2）对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。&lt;/p&gt;
&lt;p&gt;3）垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;可以将对象的引用变量设置为null&lt;/strong&gt;，暗示垃圾回收机制可以回收该对象。&lt;/p&gt;
&lt;p&gt;现在的JVM有多种垃圾回收实现算法，表现各异。&lt;/p&gt;
&lt;p&gt;垃圾回收机制回收任何对象之前，总会先调用它的&lt;strong&gt;finalize&lt;/strong&gt;方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。&lt;/p&gt;
&lt;p&gt;程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，&lt;strong&gt;会有一些效果，但是系统是否进行垃圾回收依然不确定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间以及顺序，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。&lt;/p&gt;
&lt;p&gt;程序可以任意指定释放内存的时间，这句话显然不对。&lt;/p&gt;
&lt;p&gt;程序可明确地标识某个局部变量的引用不再被使用。这句话也不对，局部变量是放在栈内存上的，栈上的垃圾回收，由**finalize()**来实现。&lt;/p&gt;
&lt;h2 id=&#34;integer与int的区别&#34;&gt;Integer与int的区别&lt;/h2&gt;
&lt;p&gt;int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。&lt;/p&gt;
&lt;p&gt;int的默认值为&lt;strong&gt;0&lt;/strong&gt;，而Integer的默认值为&lt;strong&gt;null&lt;/strong&gt;，即Integer可以区分出未赋值和值为0的区别，int则&lt;strong&gt;无法表达出未赋值&lt;/strong&gt;的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。&lt;/p&gt;
&lt;p&gt;在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;Integer提供了多个与整数相关的操作方法&lt;/strong&gt;，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。&lt;/p&gt;
&lt;h2 id=&#34;javasqldate和javautildate的联系和区别&#34;&gt;java.sql.Date和java.util.Date的联系和区别&lt;/h2&gt;
&lt;p&gt;1）、java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许 JDBC 将毫秒值标识为 SQLDATE 值。毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 为了与 SQL DATE 的定义一致，由java.sql.Date 实例包装的毫秒值必须通过将时间、分钟、秒和毫秒设置为与该实例相关的特定时区中的零来“规范化”。 说白了，java.sql.Date就是与数据库Date相对应的一个类型，而java.util.Date是纯java的Date。&lt;/p&gt;
&lt;p&gt;2）、JAVA里提供的日期和时间类java.sql.Date和java.sql.Timestamp,只会从数据库里读取某部分值，这有时会导致丢失数据。例如一个包含2002/05/22 5:00:57 PM的字段，读取日期时得到的是2002/05/22,而读取时间时得到的是5:00:57 PM. 你需要了解数据库里存储时间的精度。有些数据库，比如MySQL,精度为毫秒，然而另一些数据库，包括Oracle,存储SQL DATE类型数据时，毫秒部分的数据是不保存的。&lt;/p&gt;
&lt;p&gt;以下操作中容易出现不易被发现的BUG：获得一个JAVA里的日期对象。 从数据库里读取日期 , 试图比较两个日期对象是否相等。如果毫秒部分丢失，本来认为相等的两个日期对象 , 用Equals方法可能返回false。.sql.Timestamp类比java.util.Date类精确度要高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java.sql.Date&lt;/strong&gt; 和 &lt;strong&gt;java.util.Date&lt;/strong&gt; 最大的不同在于 &lt;strong&gt;java.sql.Date&lt;/strong&gt; 只记录日期，而没有具体这一天的时间。所以举例来说，如果当前是2009-12-24 23:20，你创建一个 java.sql.Date 将只记下2009-12-24这个信息。若你需要保留时间进行JDBC操作，请使用 java.sql.Timestamp 代替。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;java.util.Date 就是Java的日期对象，而java.sql.Date 是针对SQL语句使用的，只包含日期而没有时间部分。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;静态方法和实例方法有何不同&#34;&gt;静态⽅法和实例⽅法有何不同&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在外部调⽤静态⽅法时，可以使⽤&amp;quot;类名.⽅法名&amp;quot;的⽅式，也可以使⽤&amp;quot;对象名.⽅法名&amp;quot;的⽅式。⽽实例⽅法只有后⾯这种⽅式。也就是说，调⽤静态⽅法可以⽆需创建对象。&lt;/li&gt;
&lt;li&gt;静态⽅法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态⽅法），⽽不允许访问实例成员变量和实例⽅法；实例⽅法则⽆此限制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;静态变量和实例变量的区别&#34;&gt;静态变量和实例变量的区别&lt;/h2&gt;
&lt;p&gt;静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；&lt;/p&gt;
&lt;p&gt;实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存。两者的相同点：都有默认值而且在类的任何地方都可以调用。在Java开发中，上下文类和工具类中通常会有大量的静态成&lt;/p&gt;
&lt;h2 id=&#34;在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是&#34;&gt;在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;帮助⼦类做初始化工作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;对象的相等与指向他们的引用相等两者有什么不同&#34;&gt;对象的相等与指向他们的引⽤相等,两者有什么不同?&lt;/h2&gt;
&lt;p&gt;对象的相等，⽐的是内存中存放的内容是否相等。⽽引⽤相等，比较的的是他们指向的内存地址是否等。&lt;/p&gt;
&lt;h2 id=&#34;与-equals&#34;&gt;== 与 equals&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;==&lt;/strong&gt; : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(&lt;strong&gt;基本数据类型&lt;mark&gt;⽐的是值，引⽤数据类型&lt;/mark&gt;比较的是内存地址&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;equals() :&lt;/strong&gt; 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt; 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐该类的两个对象时，等价于通过“==”⽐᫾这两个对象。&lt;/p&gt;
&lt;p&gt;**情况 2：**类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;equals方法在没有重写equals的情况下也只是比较内存地址是否相等&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqXea.png&#34; alt=&#34;dqXea.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;String 中的 equals ⽅法是被重写过&lt;/strong&gt;的，因为 object 的 equals ⽅法是比较的对象的内存地址，⽽ String 的 equals ⽅法⽐的是对象的值。&lt;/li&gt;
&lt;li&gt;当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引⽤。如果没有就在常量池中重新创建⼀个 String 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;object类中的方法&#34;&gt;Object类中的方法&lt;/h2&gt;
&lt;p&gt;2 getClass()    //返回此 Object 的运行类。&lt;br&gt;
3 hashCode()    //用于获取对象的哈希值。&lt;br&gt;
4 equals(Object obj)     //用于确认两个对象是否“相同”。&lt;br&gt;
5 clone()    //创建并返回此对象的一个副本。&lt;br&gt;
6 toString()   //返回该对象的字符串表示。&lt;br&gt;
7 notify()    //唤醒在此对象监视器上等待的单个线程。&lt;br&gt;
8 notifyAll()     //唤醒在此对象监视器上等待的所有线程。&lt;br&gt;
9 wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。&lt;br&gt;
10 wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。&lt;br&gt;
11 wait()    //用于让当前线程失去操作权限，当前线程进入等待序列&lt;br&gt;
12 finalize() java提供&lt;a href=&#34;http://www.51testing.com/javascr%C4%ABpt:;&#34;&gt;&lt;strong&gt;finalize&lt;/strong&gt;&lt;/a&gt;()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。&lt;/p&gt;
&lt;p&gt;​     (1).对象不一定会被回收。&lt;/p&gt;
&lt;p&gt;​    (2).垃圾回收不是析构函数。&lt;/p&gt;
&lt;p&gt;​    (3).垃圾回收只与内存有关。&lt;/p&gt;
&lt;p&gt;​    (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。&lt;/p&gt;
&lt;h2 id=&#34;hashcode-与-equals&#34;&gt;hashCode 与 equals&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1)hashCode()介绍:&lt;/strong&gt;&lt;br&gt;
hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode ⽅法是本地⽅法，也就是⽤ c 语⾔或 c++ 实现的，该⽅法通常⽤来将对象的 &lt;strong&gt;内存地址 转换为整数&lt;/strong&gt;之后返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public native int hashCode();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利⽤到了散列码！（可以快速找到所需要的对象）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)为什么要有 hashCode？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们以“ HashSet 如何检查重复”为例⼦来说明为什么要有 hashCode？当你把对象加⼊ HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的 hashcode 值作，如果没有相符的 hashcode， HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。（摘⾃我的 Java 启蒙书《Head First Java》第⼆版）。这样我们就⼤⼤减少了 equals 的次数，相应就⼤⼤提⾼了执⾏速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)为什么重写 equals 时必须重写 hashCode ⽅法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。也就是说如果重写equals方法而不重写hashcode方法是没有意义的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4)为什么两个对象有相同的 hashcode 值，它们也不⼀定是相等的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 hashCode() 所使⽤的&lt;strong&gt;杂凑算法&lt;/strong&gt;也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode 。我们刚刚也提到了 HashSet ,如果 HashSet 在对⽐的时候，同样的 hashcode 有多个对象，它会使⽤ equals() 来判断是否真的相同。也就是说 hashcode 只是⽤来缩⼩查找成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是两个对象相等的情况下hashcode一定相等！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么-java-中只有值传递&#34;&gt;为什么 Java 中只有值传递？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java 程序设计语⾔对对象采⽤的不是引⽤调⽤，实际上，对象引⽤是按值传递的。&lt;/strong&gt;&lt;br&gt;
下⾯再总结⼀下 Java 中⽅法参数的使⽤情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⼀个⽅法不能修改⼀个基本数据类型的参数（即数值型或布尔型）。&lt;/li&gt;
&lt;li&gt;⼀个⽅法可以改变⼀个对象参数的状态。&lt;/li&gt;
&lt;li&gt;⼀个⽅法不能让对象参数引⽤⼀个新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在java中为什么基本类型不能做为hashmap的键值而只能是引用类型把引用类型做为hashmap的健值需要注意哪些地方&#34;&gt;在Java中，为什么基本类型不能做为HashMap的键值，而只能是引用类型，把引用类型做为HashMap的健值，需要注意哪些地方？&lt;/h2&gt;
&lt;p&gt;在Java中是使用泛型来约束HashMap中的key和value的类型的，即HashMap&amp;lt;K, V&amp;gt;；而泛型在Java的规定中必须是对象Object类型的，也就是说**HashMap&amp;lt;K, V&amp;gt;可以理HashMap&amp;lt;Object,Object&amp;gt;，**很显然基本数据类型不是Object类型的，因此不能作为键值，只能是引用类型。虽然我们在HashMap中可以这样添加数据：“map.put(1,“Java”)；”，&lt;strong&gt;但实际上是将其中的key值1进行了自动装箱操作，变为了Integer类型&lt;/strong&gt;。引用数据类型分为两类：系统提供的&lt;/p&gt;
&lt;p&gt;引用数据类型（如包装类、String等）以及自定义引用数据类型。系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；但是自定义的引用数据类型需要自己重写HashCode()和equals()这两个方法，以保证Map中key值的唯一性。ey的唯一性&lt;/p&gt;
&lt;h2 id=&#34;java-中的异常处理&#34;&gt;Java 中的异常处理&lt;/h2&gt;
&lt;h3 id=&#34;java-异常类层次结构图&#34;&gt;&lt;strong&gt;Java 异常类层次结构图&lt;/strong&gt;&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dquES.png&#34; alt=&#34;dquES.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqIIN.png&#34; alt=&#34;dqIIN.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 &lt;strong&gt;Throwable&lt;/strong&gt; 类。 &lt;strong&gt;Throwable&lt;/strong&gt; 类&lt;br&gt;
有两个重要的⼦类 &lt;strong&gt;Exception&lt;/strong&gt; （异常）和 &lt;strong&gt;Error&lt;/strong&gt; （错误）。 Exception 能被程序本身处理( try catch )， Error 是⽆法处理的(只能尽量避免)。&lt;br&gt;
Exception 和 Error ⼆者都是 Java 异常处理的重要⼦类，各⾃都包含⼤量⼦类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Exception&lt;/strong&gt; :程序本身可以处理的异常，可以通过 catch 来进⾏捕获。 Exception ⼜可以分为 受检查异常(必须处理) 和 不受查异常(可以不处理)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Error&lt;/strong&gt; ： Error 属于程序⽆法处理的错误 ，我们没办法通过 catch 来进⾏捕获 。例如，&lt;strong&gt;Java 虚拟机运⾏错误（ Virtual MachineError ）、虚拟机内存不够错误( OutOfMemoryError )、类定义错误（ NoClassDefFoundError ）等 。这异常发⽣时，Java虚拟机（JVM）⼀般会选择线程终⽌。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;受检查异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 代码在编译过程中，如果受检查异常没有被 &lt;strong&gt;catch / throw&lt;/strong&gt; 处理的话，就没办法通过编译&lt;/p&gt;
&lt;p&gt;除了 RuntimeException 及其⼦类以外，其他的 Exception 类及其⼦类都属于检查异常 。常⻅的受检查异常有： IO 相关的异常、 ClassNotFoundException 、 SQLException  等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不受检查异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RuntimeException&lt;/strong&gt; 及其⼦类都统称为⾮受检查异常，如： &lt;strong&gt;NullPointExecrption （空指针异常)、 NumberFormatException&lt;/strong&gt; （字符串转换为数字）、&lt;strong&gt;ArrayIndexOutOfBoundsException&lt;/strong&gt;（数组越界）、 **ClassCastException （**类型转换错误）ArithmeticException （算术错误）常见的就是将0作为除数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Throwable 类常⽤⽅法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;public string getMessage()&lt;/strong&gt; :返回异常发⽣时的简要描述&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public string toString()&lt;/strong&gt; :返回异常发⽣时的详细信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public string getLocalizedMessage() :&lt;strong&gt;返回异常对象的本地化信息。使⽤ &lt;strong&gt;Throwable&lt;/strong&gt; 的⼦类覆&lt;br&gt;
盖这个⽅法，可以⽣成本地化信息。如果⼦类没有覆盖该⽅法，则该⽅法返回的信息与&lt;/strong&gt;getMessage&lt;/strong&gt; 返回的结果相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;public void printStackTrace()&lt;/strong&gt; :在控制台上打印 Throwable 对象封装的异常信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异常处理总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;try&lt;/strong&gt; 块： ⽤于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟⼀个 finally 块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;catch&lt;/strong&gt; 块： ⽤于处理 try 捕获到的异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;finally&lt;/strong&gt; 块： ⽆论是否捕获或处理异常， finally 块⾥的语句都会被执⾏。当在 try 块或catch 块中遇到 return 语句时， finally 语句块将在⽅法返回之前被执⾏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在以下 3 种特殊情况下， finally 块不会被执⾏：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 try 或 finally 块中⽤了 &lt;strong&gt;System.exit(int)&lt;/strong&gt; 退出程序。但是，如果 System.exit(int) 在异常&lt;br&gt;
语句之后， finally 还是会被执⾏&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序所在的线程死亡&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关闭 CPU&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意： 当 try 语句和 finally 语句中都有 return 语句时，在⽅法返回之前，finally 语句的内容将被执⾏，并且 finally 语句的返回值将会覆盖原始的返回值。如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqCFC.png&#34; alt=&#34;dqCFC.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果调⽤ f(2) ，返回值将是 0，因为 finally 语句的返回值覆盖了try 语句块的返回值。&lt;/p&gt;
&lt;h3 id=&#34;简述throw与throws的区别&#34;&gt;简述throw与throws的区别&lt;/h3&gt;
&lt;p&gt;throw一般是用在&lt;strong&gt;方法体的内部&lt;/strong&gt;，由开发者定义当程序语句出现问题后主动抛出一个异常。&lt;/p&gt;
&lt;p&gt;throws一般用于&lt;strong&gt;方法声明&lt;/strong&gt;上，代表该方法可能会抛出的&lt;strong&gt;异常列表&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;java-序列化中如果有些字段不想进行序列化怎么办&#34;&gt;Java 序列化中如果有些字段不想进⾏序列化，怎么办？&lt;/h2&gt;
&lt;p&gt;对于不想进⾏序列化的变量，使⽤ &lt;strong&gt;transient&lt;/strong&gt; 关键字修饰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transient&lt;/strong&gt; 关键字的作⽤是：&lt;strong&gt;阻⽌&lt;/strong&gt;实例中那些⽤此关键字修饰的的变量序列化；&lt;/p&gt;
&lt;p&gt;当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和⽅法。&lt;/p&gt;
&lt;h2 id=&#34;获取用键盘输入常用的两种方法&#34;&gt;获取⽤键盘输⼊常⽤的两种⽅法&lt;/h2&gt;
&lt;p&gt;⽅法 1：通过 Scanner&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/dqwRL.png&#34; alt=&#34;dqwRL.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;⽅法 2：通过 &lt;strong&gt;BufferedReader&lt;/strong&gt; 里面需要再实例化一个InputStreamReader&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/d5Mji.png&#34; alt=&#34;d5Mji.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;深拷-vs-浅拷&#34;&gt;深拷⻉ vs 浅拷⻉&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;浅拷⻉：对基本数据类型进⾏值传递，对&lt;strong&gt;引⽤数据类型进⾏引⽤传递般的拷⻉&lt;/strong&gt;，此为浅拷⻉。被复制的那个变量会随着原变量的改变而改变 简单的来说就是跟定了某个人&lt;/li&gt;
&lt;li&gt;深拷⻉：对基本数据类型进⾏值传递，对&lt;strong&gt;引⽤数据类型，创建⼀个新的对象&lt;/strong&gt;，并复制其内容，此为深拷⻉。被复制的那个变量不会因为原变量的改变而改变 相当于现在自己的状态是由自己做主&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是编译型语言什么是解释型语言java可以归类到那种&#34;&gt;什么是编译型语言，什么是解释型语言？java可以归类到那种？&lt;/h2&gt;
&lt;p&gt;计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行&lt;br&gt;
高级语言所编写的程序。翻译的方式有两种，一个是编译，一个是解释。&lt;/p&gt;
&lt;p&gt;用编译型语言写的程序执行&lt;strong&gt;之前&lt;/strong&gt;，需要一个专门的编译过程，通过编译系统把高级语言翻译成机器语言，把源高级程&lt;br&gt;
序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一&lt;br&gt;
次，运行时不需要翻译，所以一般而言，编译型语言的程序执行效率高。&lt;/p&gt;
&lt;p&gt;解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，&lt;br&gt;
每个语句都是执行时才翻译。这样解释型语言&lt;strong&gt;每执行一次就要翻译一次，效率比较低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大&lt;br&gt;
型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页&lt;br&gt;
脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用&lt;br&gt;
解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。&lt;/p&gt;
&lt;p&gt;JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，&lt;strong&gt;其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件&lt;/strong&gt;，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，&lt;strong&gt;它需要被java虚拟机翻译成本地的机器码后才能执行&lt;/strong&gt;，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，	然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。&lt;/p&gt;
&lt;h2 id=&#34;java反射技术主要实现类有哪些作用分别是什么&#34;&gt;Java反射技术主要实现类有哪些，作用分别是什么？&lt;/h2&gt;
&lt;p&gt;在JDK中，主要由以下类来实现Java反射机制，这些类都位于&lt;strong&gt;java.lang.reflect&lt;/strong&gt;包中&lt;/p&gt;
&lt;p&gt;1）Class类：代表一个类&lt;/p&gt;
&lt;p&gt;2）Field 类：代表类的成员变量(属性)&lt;/p&gt;
&lt;p&gt;3）Method类：代表类的成员方法&lt;/p&gt;
&lt;p&gt;4）Constructor 类：代表类的构造方法&lt;/p&gt;
&lt;p&gt;5）Array类：提供了动态创建数组，以及访问数组的元素的静态方&lt;/p&gt;
&lt;h2 id=&#34;反射的使用场合和作用-及其优缺点&#34;&gt;反射的使用场合和作用、及其优缺点&lt;/h2&gt;
&lt;p&gt;1）使用场合：在编译时根本&lt;strong&gt;无法知道该对象或类可能属于哪些类&lt;/strong&gt;，程序只依靠运行时信息来发现该对象和类的真实信息。&lt;/p&gt;
&lt;p&gt;2）主要作用：通过反射可以使程序代码访问装载到JVM 中的类的内部信息，获取已装载类的属性信息，获取已装载类的方法，获取已装载类的构造方法信息&lt;/p&gt;
&lt;p&gt;3）反射的优点反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类；反射是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的&lt;/p&gt;
&lt;p&gt;4） Java反射技术应用领域很广，如软件测试等；许多流行的开源框架例如Struts、Hibernate、Spring在实现过程中都采用了该技术&lt;/p&gt;
&lt;p&gt;5）反射的缺点&lt;/p&gt;
&lt;p&gt;性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。&lt;/p&gt;
&lt;p&gt;使用反射会模糊程序内部逻辑：程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来&lt;strong&gt;维护问题&lt;/strong&gt;。反射代码比相应的直接代码更复&lt;/p&gt;
&lt;h2 id=&#34;如何实现对象克隆&#34;&gt;如何实现对象克隆？&lt;/h2&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;p&gt;1.实现&lt;strong&gt;Cloneable接口&lt;/strong&gt;并重写Object类中的clone()方法；&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;实现Serializable&lt;/strong&gt;接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;strong&gt;基&lt;/strong&gt;于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;无参构造的作用&#34;&gt;无参构造的作用&lt;/h2&gt;
&lt;p&gt;Java 程序在执⾏⼦类的构造⽅法之前，&lt;strong&gt;如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调⽤⽗类中“没有参数的构造⽅法”&lt;/strong&gt;。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的来说就是用于类的初始化工作&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;可序列化对象为什么要定义serialversionuid值&#34;&gt;可序列化对象为什么要定义serialversionUID值?&lt;/h2&gt;
&lt;p&gt;SerialVersionUid，简言之，&lt;strong&gt;其目的是序列化对象版本控制&lt;/strong&gt;，有关各版本反序列化时是否兼容。如果在新版本中这个值修改了，&lt;strong&gt;新版本就不兼容旧版本，反序列化时会抛出InvalidClassException异常&lt;/strong&gt;。如果修改较小，比如仅仅是增加了一个属性，我们希望向下兼容，老版本的数据都能保留，那就不用修改；如果我们删除了一个属性，或者更改了类的继承关系，必然不兼容旧数据，这时就应该手动更新版本号，即SerialVersionUid。说白了就是为了一个&lt;strong&gt;兼容性判断&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;接口和抽象类的区别&#34;&gt;接口和抽象类的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现**(Java 8 开始接⼝⽅法可以有默认实现**），⽽&lt;strong&gt;抽象类可以有⾮抽象的⽅法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接⼝中除了 &lt;strong&gt;static 、 final&lt;/strong&gt; 变量，不能有其他变量，⽽抽象类中则不⼀定。&lt;/li&gt;
&lt;li&gt;⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 &lt;strong&gt;extends 关键扩展多个接⼝&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰符（抽象⽅法就是为了被&lt;strong&gt;重写所以不能使⽤ private 关键字修饰&lt;/strong&gt;！）。&lt;/li&gt;
&lt;li&gt;从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。&lt;/li&gt;
&lt;li&gt;实现抽象类不需要实现其所有的方法  前提是当这个类也是抽象类的时候&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。(详⻅ issue:https://github.com/Snailclimb/JavaGuide/issues/146。&lt;/li&gt;
&lt;li&gt;jdk9 的接⼝被允许定义私有⽅法 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结⼀下 jdk7~jdk9 Java 中接⼝概念的变化（相关阅读）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。&lt;/li&gt;
&lt;li&gt;jdk 8 的时候接⼝可以有&lt;strong&gt;默认⽅法和静态⽅法功能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Jdk 9 在接⼝中引⼊了&lt;strong&gt;私有⽅法和私有静态⽅法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;抽象类中的方法是可以有方法体的。JDK1.8之后，接口中的方法也可以有方法体，用default关键字修饰方法。&lt;/p&gt;
&lt;p&gt;接口中的成员变量都是&lt;strong&gt;public static final的，一般用作常量&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;成员变量与局部变量的区别有哪些&#34;&gt;成员变量与局部变量的区别有哪些？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。&lt;/li&gt;
&lt;li&gt;从变量在内存中的存储⽅式来看:如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。&lt;/li&gt;
&lt;li&gt;从变量在内存中的⽣存时间上看:成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。&lt;/li&gt;
&lt;li&gt;成员变量如果没有被赋初值:则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽&lt;strong&gt;局部变量则不会⾃动赋值&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;继承中代码的执行顺序&#34;&gt;继承中代码的执行顺序&lt;/h2&gt;
&lt;p&gt;​					    1.父类静态&lt;strong&gt;对象&lt;/strong&gt;，父类静态代码块&lt;/p&gt;
&lt;p&gt;​                        2.子类静态对象，子类静态代码块&lt;/p&gt;
&lt;p&gt;​                        3.父类非静态对象，父类非静态代码块&lt;/p&gt;
&lt;p&gt;​                        4.父类构造函数&lt;/p&gt;
&lt;p&gt;​                        5.子类非静态对象，子类非静态代码块&lt;/p&gt;
&lt;p&gt;​                        6.子类构造函数&lt;/p&gt;
&lt;h2 id=&#34;构造方法有哪些特性&#34;&gt;构造⽅法有哪些特性？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;名字与类名相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有返回值&lt;/strong&gt;，但不能⽤ void 声明构造函数。&lt;/li&gt;
&lt;li&gt;⽣成类的对象时⾃动执⾏，⽆需调⽤。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;java创建对象的几种方式&#34;&gt;Java创建对象的几种方式&lt;/h2&gt;
&lt;p&gt;(1) 用&lt;strong&gt;new语&lt;/strong&gt;句创建对象，这是最常见的创建对象的方法。&lt;/p&gt;
&lt;p&gt;(2) 运用&lt;strong&gt;反射&lt;/strong&gt;手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。&lt;/p&gt;
&lt;p&gt;(3) 调用对象的**clone()**方法。&lt;/p&gt;
&lt;p&gt;(4) 运用&lt;strong&gt;反序列化手&lt;/strong&gt;段，调用java.io.ObjectInputStream对象的readObject()方法。&lt;/p&gt;
&lt;p&gt;(1)和(2)都会明确的显式的调用构造函数；&lt;/p&gt;
&lt;p&gt;(3)是在内存上对已有对象的影印，所以不会调用构造函数；&lt;/p&gt;
&lt;p&gt;(4)是从文件中还原类的对象，也不会调用构造函数。&lt;/p&gt;
&lt;h2 id=&#34;class类的作用&#34;&gt;Class类的作用？&lt;/h2&gt;
&lt;p&gt;Class类是&lt;strong&gt;Java 反射机制的起源和入口&lt;/strong&gt;，&lt;strong&gt;用于获取与类相关的各种信息，提供了获取类信息的相关方法&lt;/strong&gt;。Class类继承自Object类&lt;/p&gt;
&lt;p&gt;Class类是所有类的共同的图纸。每个类有自己的对象，好比图纸和实物的关系；每个类也可看做是一个对象，有共同的图纸Class，存放类的 结构信息，能够通过相应方法取出相应信息：&lt;strong&gt;类的名字、属性、方法、构造方法、父类和接口&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;生成class对象的方法有哪些&#34;&gt;生成Class对象的方法有哪些？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;生成class对象的方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象名.getClass()&lt;/li&gt;
&lt;li&gt;对象名.getSuperClass() 获取当前运行类继承的父类&lt;/li&gt;
&lt;li&gt;Class.froName(&amp;quot;类名&amp;quot;)&lt;/li&gt;
&lt;li&gt;类名.class&lt;/li&gt;
&lt;li&gt;包装类.TYPE 生成的class对象为对应的基本数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;final-关键字的一些总结&#34;&gt;final 关键字的⼀些总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;final修饰基本类型变量，其值不能改变&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是final修饰&lt;strong&gt;引用类型变量&lt;/strong&gt;，&lt;strong&gt;栈内存中的引用&lt;/strong&gt;不能改变，但是所指向的堆内存中的&lt;strong&gt;对象的属性值仍旧可以改变&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/d5aUX.png&#34; alt=&#34;d5aUX.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;java-中的final关键字有哪些用法&#34;&gt;Java 中的final关键字有哪些用法？&lt;/h2&gt;
&lt;p&gt;(1)修饰类：表示该类不能被继承；&lt;/p&gt;
&lt;p&gt;(2)修饰方法：&lt;strong&gt;表示方法不能被重写但是允许重载&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）；&lt;/p&gt;
&lt;p&gt;(4)修饰对象：对象的&lt;strong&gt;引用地址不能变&lt;/strong&gt;，但是&lt;strong&gt;对象的初始化值可以&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;final-finally和finalize的区别是什么&#34;&gt;final、finally和finalize的区别是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;final用于声明属性、方法和类，分别表示&lt;strong&gt;属性不可变、方法不可覆盖、类不可继承&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;finally作为异常处理的一部分，只能在try/catch语句中使用，finally附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。&lt;/p&gt;
&lt;p&gt;注意：在有return语句的情况下会先执行return的语句再执行return语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;finalize是Object类的一个方法，&lt;strong&gt;在垃圾收集器执行的时候会调用被回收对象的finalize()方法&lt;/strong&gt;。当垃圾回收器准备好释放对象占用空间时，首先会调用**finalize()**方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;出现在java程序中的finally代码块是否一定会执行&#34;&gt;出现在Java程序中的finally代码块是否一定会执行？&lt;/h2&gt;
&lt;p&gt;当遇到下面情况不会执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当程序在进入try语句块之前就出现异常时会直接结束&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当程序在try块中强制退出时，如使用&lt;strong&gt;System.exit(0)&lt;/strong&gt;，也不会执行finally块中的代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其它情况下，在try/catch/finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常生，在执行完finally中的代码后，后面代码会继续执行。值得注意的是，当try/catch语句块中有return时，finally语句块中的代码会在return之前执行。如果try/catch/finally块中都有return语句，finally块中的return语句会覆盖try/catch模块中的return语句。&lt;/p&gt;
&lt;h2 id=&#34;泛型中extends和super的区别&#34;&gt;泛型中extends和super的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;? extends T&gt;表示包括**T在内的任何T的⼦类**
&lt;/li&gt;
&lt;li&gt;
&lt;? super T&gt;表示包括**T在内的任何T的⽗类**
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是反射机制&#34;&gt;&lt;strong&gt;什么是反射机制？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法&lt;/strong&gt;。反射机制使得Java具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class类：可获得类属性方法&lt;/li&gt;
&lt;li&gt;Field类：获得类的成员变量&lt;/li&gt;
&lt;li&gt;Method类：获取类的方法信息&lt;/li&gt;
&lt;li&gt;Construct类：获取类的构造方法等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简述注解&#34;&gt;简述注解&lt;/h2&gt;
&lt;p&gt;Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。&lt;/p&gt;
&lt;p&gt;其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。&lt;/p&gt;
&lt;p&gt;1.Java三大注解分别是&lt;a href=&#34;https://www.nowcoder.com/profile/992988&#34;&gt;@Override&lt;/a&gt; &lt;a href=&#34;https://www.nowcoder.com/profile/992988&#34;&gt;@Deprecated @Suppresswarnings&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/profile/992988&#34;&gt;2.@Override&lt;/a&gt; 注解表名子类中覆盖了超类中的某个方法，如果写错了覆盖形式，编译器会报错&lt;/p&gt;
&lt;p&gt;3.@Deprecated 表明不希望别人在以后使用这个类，方法，变量等等&lt;/p&gt;
&lt;p&gt;4.@Suppresswarnings 达到抑制编译器产生警告的目的，但是不建议使用，因为后期编码人员看不懂编译器提示的警告，不能更好的选择更好的类去完成任务&lt;/p&gt;
&lt;h2 id=&#34;abstract和final&#34;&gt;abstract和final&lt;/h2&gt;
&lt;p&gt;**抽象类和接口都不可以实例化。**所以abstract类不能用来创建abstract类的对象；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;final类不能被继承。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;abstract不能和final共用修饰类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象类中可以没有抽象方法，有抽象方法的类一定是抽象类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：abstract是用来修饰类和方法的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 修饰方法：abstract不能和private、final、static共用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 修饰外部类：abstract不能和final、static共用。（外部类的访问修饰符只能是默认和public）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 修饰内部类：abstract不能和final共用。（内部类四种访问修饰符都可以修饰）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;super和this&#34;&gt;super和this&lt;/h2&gt;
&lt;p&gt;1、super()表示调用父类构造函数、this()调用自己的构造函数，&lt;strong&gt;而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块&lt;/strong&gt;(里面不能使用非static类型的)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造器中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.构造器中第一行默认是super()，一旦直接父类的构造器中没有无参的，那么必须显式调用父类的某个有参构造.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 构造器中第一行的super()可以换成this()，但是this()和super()只能出现一个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. super，this关键字与super()，this()不是一回事，前者表示当前调用者的父类与其本身，后者是为了构造器相互调用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;迭代和递归的区别&#34;&gt;迭代和递归的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、含义不同：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;递归是&lt;strong&gt;重复调用函数&lt;/strong&gt;自身实现循环。&lt;/p&gt;
&lt;p&gt;迭代是函数内某段代码实现循环，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。&lt;/p&gt;
&lt;p&gt;递归循环中，遇到&lt;strong&gt;满足终止条件&lt;/strong&gt;的情况时逐层返回来结束。&lt;/p&gt;
&lt;p&gt;迭代则使用&lt;strong&gt;计数器&lt;/strong&gt;结束循环。当然很多情况都是多种循环混合采用，这要根据具体需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、结构不同：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;递归与迭代都是&lt;strong&gt;基于控制结构&lt;/strong&gt;：迭代用重复结构，而递归用选择结构。 递归与迭代都涉及重复：迭代显式使用重复结构，而递归通过重复函数调用实现重复。&lt;/p&gt;
&lt;p&gt;递归与迭代都涉及终止测试：&lt;strong&gt;迭代在循环条件失败时终止&lt;/strong&gt;，&lt;strong&gt;递归在遇到基本情况时终止&lt;/strong&gt;，使用计数器控制重复的迭代和递归都逐渐到达终止点：迭代一直修改计数器，直到计数器值使循环条件失败;递归不断产生最初问题的简化副本，直到达到基本情况。&lt;/p&gt;
&lt;h2 id=&#34;is-a-has-a-like-a&#34;&gt;iS-a has -a like -a&lt;/h2&gt;
&lt;p&gt;is-a  表示继承：Gadget is-a Widget就表示Gadget 继承 Widget；&lt;/p&gt;
&lt;p&gt;has-a表示从属：Gadget has-a Sprocket就表示Gadget中有Sprocket的引用，Sprocket是Gadget的组成部分；&lt;/p&gt;
&lt;p&gt;like-a表示组合：如果A like-a B，那么B就是A的接口&lt;/p&gt;
&lt;h2 id=&#34;string对象&#34;&gt;String对象&lt;/h2&gt;
&lt;p&gt;1.String对象的两种创建方式:&lt;br&gt;
第一种方式: String str1 = &amp;quot;aaa&amp;quot;; 是在常量池中获取对象(&amp;quot;aaa&amp;quot; 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)，&lt;/p&gt;
&lt;p&gt;第二种方式: String str2 = new String(&amp;quot;aaa&amp;quot;) ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 &amp;quot;aaa&amp;quot; 字符串对象）。&lt;/p&gt;
&lt;p&gt;System.out.println(str1==str2);//false&lt;/p&gt;
&lt;p&gt;2.String类型的常量池比较特殊。它的主要使用方法有两种：&lt;br&gt;
直接使用双引号声明出来的String对象会直接存储在常量池中。&lt;br&gt;
如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 &lt;strong&gt;Native 方法&lt;/strong&gt;，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。&lt;br&gt;
String s1 = new String(&amp;quot;AAA&amp;quot;);&lt;br&gt;
String s2 = s1.intern();&lt;br&gt;
String s3 = &amp;quot;AAA&amp;quot;;&lt;br&gt;
System.out.println(s2);//AAA&lt;br&gt;
System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，&lt;br&gt;
System.out.println(s2 == s3);//true， s2,s3指向常量池中的”AAA“&lt;/p&gt;
&lt;h2 id=&#34;stingbuffer-扩容机制&#34;&gt;StingBuffer 扩容机制&lt;/h2&gt;
&lt;p&gt;s.append(&amp;quot;Y&amp;quot;); &amp;quot;Y&amp;quot;表示长度为y的字符串&lt;/p&gt;
&lt;p&gt;length始终返回当前长度即y；&lt;/p&gt;
&lt;p&gt;对于s.capacity()：&lt;/p&gt;
&lt;p&gt;1.当y&amp;lt;x时，值为x&lt;/p&gt;
&lt;p&gt;以下情况，容器容量需要扩展&lt;/p&gt;
&lt;p&gt;2.当x&amp;lt;y&amp;lt;2&lt;em&gt;x+2时，值为 2&lt;/em&gt;x+2&lt;/p&gt;
&lt;p&gt;3.当y&amp;gt;2*x+2时，值为y率问题&lt;/p&gt;
&lt;h2 id=&#34;反射机制性能问题&#34;&gt;&lt;strong&gt;反射机制性能问题：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;反射会降低效率。&lt;/p&gt;
&lt;p&gt;void **setAccessible(**boolean flag):&lt;strong&gt;是否启用访问安全检查的开关&lt;/strong&gt;，true屏蔽Java语言的访问检查，&lt;strong&gt;使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;序列化协议&#34;&gt;序列化协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;**序列化（serialization）**就是将对象序列化为二进制形式（字节数组），一般也将序列化称为编码（Encode），主要用于网络传输、数据持久化等；&lt;/li&gt;
&lt;li&gt;**反序列化（deserialization）**则是将从网络、磁盘等读取的字节数组还原成原始对象，以便后续业务的进行，一般也将反序列化称为解码（Decode），主要用于网络传输对象的解码，以便完成远程调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么java支持重载c语言不支持重载&#34;&gt;为什么java支持重载c语言不支持重载&lt;/h2&gt;
&lt;p&gt;虽然在两个语言中， 函数的调用约定都是_cdecl，但是由于函数在内存中的存储方式不相同，C语言是“ ” + 函数名形式，而java是?函数名@@YA返回值 参数@Z形式，导致C++支持重载，而C语言不支持重载。&lt;/p&gt;
&lt;h2 id=&#34;jdk15中引入泛型的作用&#34;&gt;JDK1.5中引入泛型的作用&lt;/h2&gt;
&lt;p&gt;概念：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型的参数化&lt;/strong&gt;，就是可以把类型像方法的参数那样传递。这一点意义非凡。&lt;/li&gt;
&lt;li&gt;泛型使编译器可以在&lt;strong&gt;编译期间对类型进行检查以提高类型安全&lt;/strong&gt;，减少运行时由于对象类型不匹配引发的异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类和类之间的六种关系&#34;&gt;类和类之间的六种关系&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、继承关系&lt;/strong&gt;   继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。在Java中继承关系通过关键字extends明确标识，在设计时一般没有争议性。在UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112812-ae0eb58c0ba943fba7eaabc064510e58.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;二、实现关系&lt;/strong&gt;   实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。在UML类图设计中，实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112827-e95f95975d124ace86967c62c44f466e.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;三、依赖关系&lt;/strong&gt;   简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。在UML类图设计中，依赖关系用由类A指向类B的带箭头虚线表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112853-be5da3e87f0b4ce8a466a60ca2df1477.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;四、关联关系&lt;/strong&gt; 关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。表现在代码层面，为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。在UML类图设计中，关联关系用由关联类A指向被关联类B的带箭头实线表示，在关联的两端可以标注关联双方的角色和多重性标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112902-e31a5ae618f445918ccb14402ad63dac.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;五、聚合关系&lt;/strong&gt;   聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112913-f3b9083cd039432081bc7574d16c035a.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;六、组合关系&lt;/strong&gt;   组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如人和人的大脑。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，组合关系以实心菱形加实线箭头表示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://images0.cnblogs.com/blog/420264/201305/03112925-d4940d7ea7a241638d4adb5ece507fb8.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;库函数和系统调用的区别&#34;&gt;库函数和系统调用的区别&lt;/h2&gt;
&lt;p&gt;一、系统调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统调用，我们可以理解是操作系统为用户提供的一系列操作的接口（API）&lt;/strong&gt;，这些接口提供了对系统硬件设备功能的操作。这么说可能会比较抽象，举个例子，我们最熟悉的 hello world 程序会在屏幕上打印出信息。程序中调用了 printf() 函数，而库函数 printf 本质上是调用了系统调用 write() 函数，实现了终端信息的打印功能。&lt;/p&gt;
&lt;p&gt;二、库函数&lt;/p&gt;
&lt;p&gt;库函数可以理解为是对系统调用的一层封装。系统调用作为内核提供给用户程序的接口，它的执行效率是比较高效而精简的，但有时我们需要对获取的信息进行更复杂的处理，或更人性化的需要，我们把这些处理过程封装成一个函数再提供给程序员，更方便于程序猿编码。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://i.imgtg.com/2023/02/14/d5oyt.png&#34; alt=&#34;d5oyt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;有了基本类型为什么还要有包装类&#34;&gt;有了基本类型为什么还要有包装类？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.声明方式不同：&lt;/p&gt;
&lt;p&gt;基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；&lt;/p&gt;
&lt;p&gt;2.存储方式及位置不同：&lt;/p&gt;
&lt;p&gt;基本类型是直接将&lt;strong&gt;变量值存储在栈&lt;/strong&gt;中，而&lt;strong&gt;包装类型是将对象放在堆&lt;/strong&gt;中，然后通过&lt;strong&gt;引用&lt;/strong&gt;来使用；&lt;/p&gt;
&lt;p&gt;3.初始值不同：&lt;/p&gt;
&lt;p&gt;基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；&lt;/p&gt;
&lt;p&gt;4.使用方式不同：&lt;/p&gt;
&lt;p&gt;基本类型直接赋值直接使用就好，而包装类型在集合（如：Collection、Map）时会使用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java中的基本数据类型却不是面向对象的，并不具有对象的性质，这在实际生活中存在很多的不便。为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得Java具有了对象的性质，&lt;strong&gt;并且为其添加了属性和方法，丰富了基本类型的操作，方便涉及到对象的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;jdk18新特性&#34;&gt;jdk1.8新特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Lambda表达式&lt;/strong&gt;：Lambda允许函数作为参数传递到方法中。&lt;/p&gt;
&lt;p&gt;方法引用：可以直接引用已有Java类或对象的方法或构造器。&lt;/p&gt;
&lt;p&gt;Date Time API：加强对日期与时间的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt;类：用来解决空指针异常。&lt;/p&gt;
&lt;p&gt;JavaScript引擎：允许程序在JVM上运行特定的javascript应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认方法&lt;/strong&gt;：可以理解为一个在接口里面有了一个实现的方法。&lt;/p&gt;
&lt;p&gt;新工具：加入像是Nashorn引擎 jjs、 类依赖分析器jdeps的新的编译工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream API&lt;/strong&gt;：可以把函数式编程风格引入到Java中。&lt;/p&gt;
&lt;h2 id=&#34;jdk111新特性&#34;&gt;jdk1.11新特性&lt;/h2&gt;
&lt;p&gt;https://www.jianshu.com/p/84a6050c5391&lt;/p&gt;
&lt;h3 id=&#34;对象组成&#34;&gt;对象组成&lt;/h3&gt;
&lt;p&gt;1，对象头&lt;/p&gt;
&lt;p&gt;2，实例数据&lt;/p&gt;
&lt;p&gt;3，对齐填充字节&lt;/p&gt;
&lt;h3 id=&#34;对象头组成&#34;&gt;对象头组成&lt;/h3&gt;
&lt;p&gt;1，Mark Word&lt;/p&gt;
&lt;p&gt;2，指向类的指针&lt;/p&gt;
&lt;p&gt;3，数组长度（只有数组对象才有）&lt;/p&gt;
&lt;h4 id=&#34;1mark-word&#34;&gt;1，Mark Word&lt;/h4&gt;
&lt;p&gt;Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。&lt;/p&gt;
&lt;h4 id=&#34;2指向类的指针&#34;&gt;2，指向类的指针&lt;/h4&gt;
&lt;p&gt;该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。&lt;/p&gt;
&lt;p&gt;Java对象的类数据保存在方法区。&lt;/p&gt;
&lt;h4 id=&#34;3数组长度&#34;&gt;3，数组长度&lt;/h4&gt;
&lt;p&gt;只有数组对象保存了这部分数据。&lt;/p&gt;
&lt;p&gt;该数据在32位和64位JVM中长度都是32bit。&lt;/p&gt;
&lt;h2 id=&#34;jdk自带工具&#34;&gt;jdk自带工具&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;jps&lt;/th&gt;
&lt;th&gt;JVM Process Status Tool，显示指定系统内所有HotSpot虚拟机进程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;jstat&lt;/td&gt;
&lt;td&gt;JVM Statistics Minitoring Tool，用于收集HotSpot虚拟机各方面的运行数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jinfo&lt;/td&gt;
&lt;td&gt;Configuration Info for Java，显示虚拟机配置信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jmap&lt;/td&gt;
&lt;td&gt;Memory Map for Java，生成虚拟机的内存转储快照（heapdump）文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jhat&lt;/td&gt;
&lt;td&gt;JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jstack&lt;/td&gt;
&lt;td&gt;Stack Trace for Java，显示虚拟机的线程快照&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;&#34;&gt;&lt;/h1&gt;
">JAVA基础</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>